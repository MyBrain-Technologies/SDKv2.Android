<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
    <title>Coverage Report :: EncryptionUtils</title>
    <style type="text/css">
    @import "../../.css/coverage.css";

    </style>
</head>

<body>
<div class="header"></div>

<div class="content">
    <div class="breadCrumbs">
        [ <a href="../../index.html">all classes</a> ]
        [ <a href="../index.html">utils</a> ]
    </div>

    <h1>Coverage Summary for Class: EncryptionUtils (utils)</h1>

    <table class="coverageStats">

        <tr>
            <th class="name">Class</th>
            <th class="coverageStat
">
                Method, %
            </th>
            <th class="coverageStat
">
                Line, %
            </th>
        </tr>
        <tr>
            <td class="name">EncryptionUtils</td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 21)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 78)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name">EncryptionUtils$CipherTextIvMac</td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 9)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 45)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name">EncryptionUtils$PrngFixes</td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 9)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 60)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name">EncryptionUtils$PrngFixes$LinuxPRNGSecureRandom</td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 7)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 39)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name">EncryptionUtils$PrngFixes$LinuxPRNGSecureRandomProvider</td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 1)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 3)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name">EncryptionUtils$SecretKeys</td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 8)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 26)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name"><strong>total</strong></td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 55)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    0%
  </span>
                <span class="absValue">
    (0/ 251)
  </span>
            </td>
        </tr>
    </table>

    <br/>
    <br/>


    <div class="sourceCode"><i>1</i>&nbsp;package utils;
        <i>2</i>&nbsp;
        <i>3</i>&nbsp;import android.os.Build;
        <i>4</i>&nbsp;import android.os.Process;
        <i>5</i>&nbsp;import androidx.annotation.Keep;
        <i>6</i>&nbsp;import androidx.annotation.NonNull;
        <i>7</i>&nbsp;import androidx.annotation.Nullable;
        <i>8</i>&nbsp;import android.util.Base64;
        <i>9</i>&nbsp;import android.util.Log;
        <i>10</i>&nbsp;
        <i>11</i>&nbsp;import java.io.ByteArrayOutputStream;
        <i>12</i>&nbsp;import java.io.DataInputStream;
        <i>13</i>&nbsp;import java.io.DataOutputStream;
        <i>14</i>&nbsp;import java.io.File;
        <i>15</i>&nbsp;import java.io.FileInputStream;
        <i>16</i>&nbsp;import java.io.FileOutputStream;
        <i>17</i>&nbsp;import java.io.IOException;
        <i>18</i>&nbsp;import java.io.OutputStream;
        <i>19</i>&nbsp;import java.io.UnsupportedEncodingException;
        <i>20</i>&nbsp;import java.security.GeneralSecurityException;
        <i>21</i>&nbsp;import java.security.InvalidKeyException;
        <i>22</i>&nbsp;import java.security.NoSuchAlgorithmException;
        <i>23</i>&nbsp;import java.security.Provider;
        <i>24</i>&nbsp;import java.security.SecureRandom;
        <i>25</i>&nbsp;import java.security.SecureRandomSpi;
        <i>26</i>&nbsp;import java.security.Security;
        <i>27</i>&nbsp;import java.security.spec.KeySpec;
        <i>28</i>&nbsp;import java.util.Arrays;
        <i>29</i>&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
        <i>30</i>&nbsp;
        <i>31</i>&nbsp;import javax.crypto.Cipher;
        <i>32</i>&nbsp;import javax.crypto.KeyGenerator;
        <i>33</i>&nbsp;import javax.crypto.Mac;
        <i>34</i>&nbsp;import javax.crypto.SecretKey;
        <i>35</i>&nbsp;import javax.crypto.SecretKeyFactory;
        <i>36</i>&nbsp;import javax.crypto.spec.IvParameterSpec;
        <i>37</i>&nbsp;import javax.crypto.spec.PBEKeySpec;
        <i>38</i>&nbsp;import javax.crypto.spec.SecretKeySpec;
        <i>39</i>&nbsp;
        <i>40</i>&nbsp;/**
        <i>41</i>&nbsp; * Source code from :
        https://github.com/tozny/java-aes-crypto/blob/master/aes-crypto/src/main/java/com/tozny/crypto/android/AesCbcWithIntegrity.java
        <i>42</i>&nbsp; * Created by Vincent on 16/09/2015.
        <i>43</i>&nbsp; */
        <i>44</i>&nbsp;@Keep
        <b class="nc"><i>45</i>&nbsp;public final class EncryptionUtils {</b>
        <i>46</i>&nbsp; // If the PRNG fix would not succeed for some reason, we normally will throw
        an exception.
        <i>47</i>&nbsp; // If ALLOW_BROKEN_PRNG is true, however, we will simply log instead.
        <i>48</i>&nbsp; private static final boolean ALLOW_BROKEN_PRNG = false;
        <i>49</i>&nbsp;
        <i>50</i>&nbsp; private static final String CIPHER_TRANSFORMATION = &quot;AES/CBC/PKCS5Padding&quot;;
        <i>51</i>&nbsp; private static final String CIPHER = &quot;AES&quot;;
        <i>52</i>&nbsp; private static final String RANDOM_ALGORITHM = &quot;SHA1PRNG&quot;;
        <i>53</i>&nbsp; private static final int AES_KEY_LENGTH_BITS = 128;
        <i>54</i>&nbsp; private static final int IV_LENGTH_BYTES = 16;
        <i>55</i>&nbsp; private static final int PBE_ITERATION_COUNT = 10000;
        <i>56</i>&nbsp; private static final int PBE_SALT_LENGTH_BITS = AES_KEY_LENGTH_BITS; // same
        size as key output
        <i>57</i>&nbsp; private static final String PBE_ALGORITHM = &quot;PBKDF2WithHmacSHA1&quot;;
        <i>58</i>&nbsp;
        <i>59</i>&nbsp; //Made BASE_64_FLAGS public as it&#39;s useful to know for compatibility.
        <i>60</i>&nbsp; private static final int BASE64_FLAGS = Base64.NO_WRAP;
        <i>61</i>&nbsp; //default for testing
        <b class="nc"><i>62</i>&nbsp; private static final AtomicBoolean prngFixed = new
            AtomicBoolean(false);</b>
        <i>63</i>&nbsp;
        <i>64</i>&nbsp; private static final String HMAC_ALGORITHM = &quot;HmacSHA256&quot;;
        <i>65</i>&nbsp; private static final int HMAC_KEY_LENGTH_BITS = 256;
        <i>66</i>&nbsp;
        <i>67</i>&nbsp; /**
        <i>68</i>&nbsp; * Converts the given AES/HMAC keys into a base64 encoded string suitable for
        <i>69</i>&nbsp; * storage. Sister function of keys.
        <i>70</i>&nbsp; *
        <i>71</i>&nbsp; * @param keys The combined aes and hmac keys
        <i>72</i>&nbsp; * @return a base 64 encoded AES string &amp; hmac key as base64(aesKey) :
        base64(hmacKey)
        <i>73</i>&nbsp; */
        <i>74</i>&nbsp; public static final String keyString(final SecretKeys keys) {
        <b class="nc"><i>75</i>&nbsp; return keys.toString();</b>
        <i>76</i>&nbsp; }
        <i>77</i>&nbsp;
        <i>78</i>&nbsp; /**
        <i>79</i>&nbsp; * An aes key derived from a base64 encoded key. This does not generate the
        <i>80</i>&nbsp; * key. It&#39;s not random or a PBE key.
        <i>81</i>&nbsp; *
        <i>82</i>&nbsp; * @param keysStr a base64 encoded AES key / hmac key as base64(aesKey) :
        base64(hmacKey).
        <i>83</i>&nbsp; * @return an AES &amp; HMAC key set suitable for other functions.
        <i>84</i>&nbsp; */
        <i>85</i>&nbsp; public static final SecretKeys keys(final String keysStr) throws
        InvalidKeyException {
        <b class="nc"><i>86</i>&nbsp; final String[] keysArr = keysStr.split(&quot;:&quot;);</b>
        <i>87</i>&nbsp;
        <b class="nc"><i>88</i>&nbsp; if (keysArr.length != 2) {</b>
        <b class="nc"><i>89</i>&nbsp; throw new IllegalArgumentException(&quot;Cannot parse
            aesKey:hmacKey&quot;);</b>
        <i>90</i>&nbsp;
        <i>91</i>&nbsp; } else {
        <b class="nc"><i>92</i>&nbsp; final byte[] confidentialityKey = Base64.decode(keysArr[0],
            BASE64_FLAGS);</b>
        <b class="nc"><i>93</i>&nbsp; if (confidentialityKey.length != AES_KEY_LENGTH_BITS /8) {</b>
        <b class="nc"><i>94</i>&nbsp; throw new InvalidKeyException(&quot;Base64 decoded key is not
            &quot; + AES_KEY_LENGTH_BITS + &quot; bytes&quot;);</b>
        <i>95</i>&nbsp; }
        <b class="nc"><i>96</i>&nbsp; final byte[] integrityKey = Base64.decode(keysArr[1],
            BASE64_FLAGS);</b>
        <b class="nc"><i>97</i>&nbsp; if (integrityKey.length != HMAC_KEY_LENGTH_BITS /8) {</b>
        <b class="nc"><i>98</i>&nbsp; throw new InvalidKeyException(&quot;Base64 decoded key is not
            &quot; + HMAC_KEY_LENGTH_BITS + &quot; bytes&quot;);</b>
        <i>99</i>&nbsp; }
        <i>100</i>&nbsp;
        <b class="nc"><i>101</i>&nbsp; return new SecretKeys(</b>
        <i>102</i>&nbsp; new SecretKeySpec(confidentialityKey, 0, confidentialityKey.length,
        CIPHER),
        <i>103</i>&nbsp; new SecretKeySpec(integrityKey, HMAC_ALGORITHM));
        <i>104</i>&nbsp; }
        <i>105</i>&nbsp; }
        <i>106</i>&nbsp;
        <i>107</i>&nbsp; /**
        <i>108</i>&nbsp; * A function that generates random AES &amp; HMAC keys and prints out
        exceptions but
        <i>109</i>&nbsp; * doesn&#39;t throw them since none should be encountered. If they are
        <i>110</i>&nbsp; * encountered, the return value is null.
        <i>111</i>&nbsp; *
        <i>112</i>&nbsp; * @return The AES &amp; HMAC keys.
        <i>113</i>&nbsp; * @throws GeneralSecurityException if AES is not implemented on this
        system,
        <i>114</i>&nbsp; * or a suitable RNG is not available
        <i>115</i>&nbsp; */
        <i>116</i>&nbsp; public static final SecretKeys generateKey() throws
        GeneralSecurityException {
        <b class="nc"><i>117</i>&nbsp; fixPrng();</b>
        <b class="nc"><i>118</i>&nbsp; final KeyGenerator keyGen = KeyGenerator.getInstance(CIPHER);</b>
        <i>119</i>&nbsp; // No need to provide a SecureRandom or set a seed since that will
        <i>120</i>&nbsp; // happen automatically.
        <b class="nc"><i>121</i>&nbsp; keyGen.init(AES_KEY_LENGTH_BITS);</b>
        <b class="nc"><i>122</i>&nbsp; final SecretKey confidentialityKey =
            keyGen.generateKey();</b>
        <i>123</i>&nbsp;
        <i>124</i>&nbsp; //Now make the HMAC key
        <b class="nc"><i>125</i>&nbsp; final byte[] integrityKeyBytes =
            randomBytes(HMAC_KEY_LENGTH_BITS / 8);//to get bytes</b>
        <b class="nc"><i>126</i>&nbsp; final SecretKey integrityKey = new
            SecretKeySpec(integrityKeyBytes, HMAC_ALGORITHM);</b>
        <i>127</i>&nbsp;
        <b class="nc"><i>128</i>&nbsp; return new SecretKeys(confidentialityKey, integrityKey);</b>
        <i>129</i>&nbsp; }
        <i>130</i>&nbsp;
        <i>131</i>&nbsp; /**
        <i>132</i>&nbsp; * A function that generates password-based AES &amp; HMAC keys. It prints
        out exceptions but
        <i>133</i>&nbsp; * doesn&#39;t throw them since none should be encountered. If they are
        <i>134</i>&nbsp; * encountered, the return value is null.
        <i>135</i>&nbsp; *
        <i>136</i>&nbsp; * @param password The password to derive the keys from.
        <i>137</i>&nbsp; * @return The AES &amp; HMAC keys.
        <i>138</i>&nbsp; * @throws GeneralSecurityException if AES is not implemented on this
        system,
        <i>139</i>&nbsp; * or a suitable RNG is not available
        <i>140</i>&nbsp; */
        <i>141</i>&nbsp; public static final SecretKeys generateKeyFromPassword(final String
        password, final byte[] salt) throws GeneralSecurityException {
        <b class="nc"><i>142</i>&nbsp; fixPrng();</b>
        <i>143</i>&nbsp; //Get enough random bytes for both the AES key and the HMAC key:
        <b class="nc"><i>144</i>&nbsp; final KeySpec keySpec = new
            PBEKeySpec(password.toCharArray(), salt,</b>
        <i>145</i>&nbsp; PBE_ITERATION_COUNT, AES_KEY_LENGTH_BITS + HMAC_KEY_LENGTH_BITS);
        <b class="nc"><i>146</i>&nbsp; final SecretKeyFactory keyFactory = SecretKeyFactory</b>
        <b class="nc"><i>147</i>&nbsp; .getInstance(PBE_ALGORITHM);</b>
        <b class="nc"><i>148</i>&nbsp; final byte[] keyBytes =
            keyFactory.generateSecret(keySpec).getEncoded();</b>
        <i>149</i>&nbsp;
        <i>150</i>&nbsp; // Split the random bytes into two parts:
        <b class="nc"><i>151</i>&nbsp; final byte[] confidentialityKeyBytes = copyOfRange(keyBytes,
            0, AES_KEY_LENGTH_BITS /8);</b>
        <b class="nc"><i>152</i>&nbsp; final byte[] integrityKeyBytes = copyOfRange(keyBytes,
            AES_KEY_LENGTH_BITS /8, AES_KEY_LENGTH_BITS /8 + HMAC_KEY_LENGTH_BITS /8);</b>
        <i>153</i>&nbsp;
        <i>154</i>&nbsp; //Generate the AES key
        <b class="nc"><i>155</i>&nbsp; final SecretKey confidentialityKey = new
            SecretKeySpec(confidentialityKeyBytes, CIPHER);</b>
        <i>156</i>&nbsp;
        <i>157</i>&nbsp; //Generate the HMAC key
        <b class="nc"><i>158</i>&nbsp; final SecretKey integrityKey = new
            SecretKeySpec(integrityKeyBytes, HMAC_ALGORITHM);</b>
        <i>159</i>&nbsp;
        <b class="nc"><i>160</i>&nbsp; return new SecretKeys(confidentialityKey, integrityKey);</b>
        <i>161</i>&nbsp; }
        <i>162</i>&nbsp;
        <i>163</i>&nbsp; /**
        <i>164</i>&nbsp; * A function that generates password-based AES &amp; HMAC keys. See
        generateKeyFromPassword.
        <i>165</i>&nbsp; * @param password The password to derive the AES/HMAC keys from
        <i>166</i>&nbsp; * @param salt A string version of the salt; base64 encoded.
        <i>167</i>&nbsp; * @return The AES &amp; HMAC keys.
        <i>168</i>&nbsp; * @throws GeneralSecurityException
        <i>169</i>&nbsp; */
        <i>170</i>&nbsp; public static final SecretKeys generateKeyFromPassword(@NonNull final
        String password, final String salt) throws GeneralSecurityException {
        <b class="nc"><i>171</i>&nbsp; return generateKeyFromPassword(password, Base64.decode(salt,
            BASE64_FLAGS));</b>
        <i>172</i>&nbsp; }
        <i>173</i>&nbsp;
        <i>174</i>&nbsp; /**
        <i>175</i>&nbsp; * Generates a random salt.
        <i>176</i>&nbsp; * @return The random salt suitable for generateKeyFromPassword.
        <i>177</i>&nbsp; */
        <i>178</i>&nbsp; @NonNull
        <i>179</i>&nbsp; public static final byte[] generateSalt() throws GeneralSecurityException {
        <b class="nc"><i>180</i>&nbsp; return randomBytes(PBE_SALT_LENGTH_BITS);</b>
        <i>181</i>&nbsp; }
        <i>182</i>&nbsp;
        <i>183</i>&nbsp; /**
        <i>184</i>&nbsp; * Converts the given salt into a base64 encoded string suitable for
        <i>185</i>&nbsp; * storage.
        <i>186</i>&nbsp; *
        <i>187</i>&nbsp; * @param salt
        <i>188</i>&nbsp; * @return a base 64 encoded salt string suitable to pass into
        generateKeyFromPassword.
        <i>189</i>&nbsp; */
        <i>190</i>&nbsp; public static final String saltString(final byte[] salt) {
        <b class="nc"><i>191</i>&nbsp; return Base64.encodeToString(salt, BASE64_FLAGS);</b>
        <i>192</i>&nbsp; }
        <i>193</i>&nbsp;
        <i>194</i>&nbsp;
        <i>195</i>&nbsp; /**
        <i>196</i>&nbsp; * Creates a random Initialization Vector (IV) of IV_LENGTH_BYTES.
        <i>197</i>&nbsp; *
        <i>198</i>&nbsp; * @return The byte array of this IV
        <i>199</i>&nbsp; * @throws GeneralSecurityException if a suitable RNG is not available
        <i>200</i>&nbsp; */
        <i>201</i>&nbsp; @NonNull
        <i>202</i>&nbsp; public static byte[] generateIv() throws GeneralSecurityException {
        <b class="nc"><i>203</i>&nbsp; return randomBytes(IV_LENGTH_BYTES);</b>
        <i>204</i>&nbsp; }
        <i>205</i>&nbsp;
        <i>206</i>&nbsp; @NonNull
        <i>207</i>&nbsp; private static byte[] randomBytes(int length) throws
        GeneralSecurityException {
        <b class="nc"><i>208</i>&nbsp; fixPrng();</b>
        <b class="nc"><i>209</i>&nbsp; final SecureRandom random =
            SecureRandom.getInstance(RANDOM_ALGORITHM);</b>
        <b class="nc"><i>210</i>&nbsp; final byte[] b = new byte[length];</b>
        <b class="nc"><i>211</i>&nbsp; random.nextBytes(b);</b>
        <b class="nc"><i>212</i>&nbsp; return b;</b>
        <i>213</i>&nbsp; }
        <i>214</i>&nbsp;
        <i>215</i>&nbsp; /*
        <i>216</i>&nbsp; * -----------------------------------------------------------------
        <i>217</i>&nbsp; * Encryption
        <i>218</i>&nbsp; * -----------------------------------------------------------------
        <i>219</i>&nbsp; */
        <i>220</i>&nbsp;
        <i>221</i>&nbsp; /**
        <i>222</i>&nbsp; * Generates a random IV and encrypts this plain text with the given key.
        Then attaches
        <i>223</i>&nbsp; * a hashed MAC, which is contained in the CipherTextIvMac class.
        <i>224</i>&nbsp; *
        <i>225</i>&nbsp; * @param plaintext The text that will be encrypted, which
        <i>226</i>&nbsp; * will be serialized with UTF-8
        <i>227</i>&nbsp; * @param secretKeys The AES &amp; HMAC keys with which to encrypt
        <i>228</i>&nbsp; * @return a tuple of the IV, ciphertext, mac
        <i>229</i>&nbsp; * @throws GeneralSecurityException if AES is not implemented on this system
        <i>230</i>&nbsp; * @throws UnsupportedEncodingException if UTF-8 is not supported in this
        system
        <i>231</i>&nbsp; */
        <i>232</i>&nbsp; public static CipherTextIvMac encrypt(@NonNull final String plaintext,
        @NonNull final SecretKeys secretKeys)
        <i>233</i>&nbsp; throws UnsupportedEncodingException, GeneralSecurityException {
        <b class="nc"><i>234</i>&nbsp; return encrypt(plaintext, secretKeys, &quot;UTF-8&quot;);</b>
        <i>235</i>&nbsp; }
        <i>236</i>&nbsp;
        <i>237</i>&nbsp; /**
        <i>238</i>&nbsp; * Generates a random IV and encrypts this plain text with the given key.
        Then attaches
        <i>239</i>&nbsp; * a hashed MAC, which is contained in the CipherTextIvMac class.
        <i>240</i>&nbsp; *
        <i>241</i>&nbsp; * @param plaintext The bytes that will be encrypted
        <i>242</i>&nbsp; * @param secretKeys The AES &amp; HMAC keys with which to encrypt
        <i>243</i>&nbsp; * @return a tuple of the IV, ciphertext, mac
        <i>244</i>&nbsp; * @throws GeneralSecurityException if AES is not implemented on this system
        <i>245</i>&nbsp; * @throws UnsupportedEncodingException if the specified encoding is invalid
        <i>246</i>&nbsp; */
        <i>247</i>&nbsp; public static CipherTextIvMac encrypt(final String plaintext, @NonNull
        final SecretKeys secretKeys, @NonNull final String encoding)
        <i>248</i>&nbsp; throws UnsupportedEncodingException, GeneralSecurityException {
        <b class="nc"><i>249</i>&nbsp; return encrypt(plaintext.getBytes(encoding), secretKeys);</b>
        <i>250</i>&nbsp; }
        <i>251</i>&nbsp;
        <i>252</i>&nbsp; /**
        <i>253</i>&nbsp; * Generates a random IV and encrypts this plain text with the given key.
        Then attaches
        <i>254</i>&nbsp; * a hashed MAC, which is contained in the CipherTextIvMac class.
        <i>255</i>&nbsp; *
        <i>256</i>&nbsp; * @param plaintext The text that will be encrypted
        <i>257</i>&nbsp; * @param secretKeys The combined AES &amp; HMAC keys with which to encrypt
        <i>258</i>&nbsp; * @return a tuple of the IV, ciphertext, mac
        <i>259</i>&nbsp; * @throws GeneralSecurityException if AES is not implemented on this system
        <i>260</i>&nbsp; */
        <i>261</i>&nbsp; public static CipherTextIvMac encrypt(final byte[] plaintext, final
        SecretKeys secretKeys)
        <i>262</i>&nbsp; throws GeneralSecurityException {
        <b class="nc"><i>263</i>&nbsp; byte[] iv = generateIv();</b>
        <b class="nc"><i>264</i>&nbsp; final Cipher aesCipherForEncryption =
            Cipher.getInstance(CIPHER_TRANSFORMATION);</b>
        <b class="nc"><i>265</i>&nbsp; aesCipherForEncryption.init(Cipher.ENCRYPT_MODE,
            secretKeys.getConfidentialityKey(), new IvParameterSpec(iv));</b>
        <i>266</i>&nbsp;
        <i>267</i>&nbsp; /*
        <i>268</i>&nbsp; * Now we get back the IV that will actually be used. Some Android
        <i>269</i>&nbsp; * versions do funny stuff w/ the IV, so this is to work around bugs:
        <i>270</i>&nbsp; */
        <b class="nc"><i>271</i>&nbsp; iv = aesCipherForEncryption.getIV();</b>
        <b class="nc"><i>272</i>&nbsp; final byte[] byteCipherText =
            aesCipherForEncryption.doFinal(plaintext);</b>
        <b class="nc"><i>273</i>&nbsp; final byte[] ivCipherConcat =
            CipherTextIvMac.ivCipherConcat(iv, byteCipherText);</b>
        <i>274</i>&nbsp;
        <b class="nc"><i>275</i>&nbsp; final byte[] integrityMac = generateMac(ivCipherConcat,
            secretKeys.getIntegrityKey());</b>
        <b class="nc"><i>276</i>&nbsp; return new CipherTextIvMac(byteCipherText, iv, integrityMac);</b>
        <i>277</i>&nbsp; }
        <i>278</i>&nbsp;
        <i>279</i>&nbsp; /**
        <i>280</i>&nbsp; * Ensures that the PRNG is fixed. Should be used before generating any
        keys.
        <i>281</i>&nbsp; * Will only run once, and every subsequent call should return immediately.
        <i>282</i>&nbsp; */
        <i>283</i>&nbsp; private static void fixPrng() {
        <b class="nc"><i>284</i>&nbsp; if (!prngFixed.get()) {</b>
        <b class="nc"><i>285</i>&nbsp; synchronized (PrngFixes.class) {</b>
        <b class="nc"><i>286</i>&nbsp; if (!prngFixed.get()) {</b>
        <b class="nc"><i>287</i>&nbsp; PrngFixes.apply();</b>
        <b class="nc"><i>288</i>&nbsp; prngFixed.set(true);</b>
        <i>289</i>&nbsp; }
        <b class="nc"><i>290</i>&nbsp; }</b>
        <i>291</i>&nbsp; }
        <i>292</i>&nbsp; }
        <i>293</i>&nbsp;
        <i>294</i>&nbsp; /*
        <i>295</i>&nbsp; * -----------------------------------------------------------------
        <i>296</i>&nbsp; * Decryption
        <i>297</i>&nbsp; * -----------------------------------------------------------------
        <i>298</i>&nbsp; */
        <i>299</i>&nbsp;
        <i>300</i>&nbsp; /**
        <i>301</i>&nbsp; * AES CBC decrypt.
        <i>302</i>&nbsp; *
        <i>303</i>&nbsp; * @param civ The cipher text, IV, and mac
        <i>304</i>&nbsp; * @param secretKeys The AES &amp; HMAC keys
        <i>305</i>&nbsp; * @param encoding The string encoding to use to decode the bytes after
        decryption
        <i>306</i>&nbsp; * @return A string derived from the decrypted bytes (not base64 encoded)
        <i>307</i>&nbsp; * @throws GeneralSecurityException if AES is not implemented on this system
        <i>308</i>&nbsp; * @throws UnsupportedEncodingException if the encoding is unsupported
        <i>309</i>&nbsp; */
        <i>310</i>&nbsp; public static String decryptString(@NonNull final CipherTextIvMac civ,
        @NonNull final SecretKeys secretKeys, @NonNull final String encoding)
        <i>311</i>&nbsp; throws UnsupportedEncodingException, GeneralSecurityException {
        <b class="nc"><i>312</i>&nbsp; return new String(decrypt(civ, secretKeys), encoding);</b>
        <i>313</i>&nbsp; }
        <i>314</i>&nbsp;
        <i>315</i>&nbsp; /**
        <i>316</i>&nbsp; * AES CBC decrypt.
        <i>317</i>&nbsp; *
        <i>318</i>&nbsp; * @param civ The cipher text, IV, and mac
        <i>319</i>&nbsp; * @param secretKeys The AES &amp; HMAC keys
        <i>320</i>&nbsp; * @return A string derived from the decrypted bytes, which are interpreted
        <i>321</i>&nbsp; * as a UTF-8 String
        <i>322</i>&nbsp; * @throws GeneralSecurityException if AES is not implemented on this system
        <i>323</i>&nbsp; * @throws UnsupportedEncodingException if UTF-8 is not supported
        <i>324</i>&nbsp; */
        <i>325</i>&nbsp; public static String decryptString(@NonNull final CipherTextIvMac civ,
        @NonNull final SecretKeys secretKeys)
        <i>326</i>&nbsp; throws UnsupportedEncodingException, GeneralSecurityException {
        <b class="nc"><i>327</i>&nbsp; return decryptString(civ, secretKeys, &quot;UTF-8&quot;);</b>
        <i>328</i>&nbsp; }
        <i>329</i>&nbsp;
        <i>330</i>&nbsp; /**
        <i>331</i>&nbsp; * AES CBC decrypt.
        <i>332</i>&nbsp; *
        <i>333</i>&nbsp; * @param civ the cipher text, iv, and mac
        <i>334</i>&nbsp; * @param secretKeys the AES &amp; HMAC keys
        <i>335</i>&nbsp; * @return The raw decrypted bytes
        <i>336</i>&nbsp; * @throws GeneralSecurityException if MACs don&#39;t match or AES is not
        implemented
        <i>337</i>&nbsp; */
        <i>338</i>&nbsp; public static byte[] decrypt(final CipherTextIvMac civ, final SecretKeys
        secretKeys)
        <i>339</i>&nbsp; throws GeneralSecurityException {
        <i>340</i>&nbsp;
        <b class="nc"><i>341</i>&nbsp; final byte[] ivCipherConcat =
            CipherTextIvMac.ivCipherConcat(civ.getIv(), civ.getCipherText());</b>
        <b class="nc"><i>342</i>&nbsp; final byte[] computedMac = generateMac(ivCipherConcat,
            secretKeys.getIntegrityKey());</b>
        <b class="nc"><i>343</i>&nbsp; if (constantTimeEq(computedMac, civ.getMac())) {</b>
        <b class="nc"><i>344</i>&nbsp; final Cipher aesCipherForDecryption =
            Cipher.getInstance(CIPHER_TRANSFORMATION);</b>
        <b class="nc"><i>345</i>&nbsp; aesCipherForDecryption.init(Cipher.DECRYPT_MODE,
            secretKeys.getConfidentialityKey(),</b>
        <b class="nc"><i>346</i>&nbsp; new IvParameterSpec(civ.getIv()));</b>
        <b class="nc"><i>347</i>&nbsp; return
            aesCipherForDecryption.doFinal(civ.getCipherText());</b>
        <i>348</i>&nbsp; } else {
        <b class="nc"><i>349</i>&nbsp; throw new GeneralSecurityException(&quot;MAC stored in civ
            does not match computed MAC.&quot;);</b>
        <i>350</i>&nbsp; }
        <i>351</i>&nbsp; }
        <i>352</i>&nbsp;
        <i>353</i>&nbsp; /*
        <i>354</i>&nbsp; * -----------------------------------------------------------------
        <i>355</i>&nbsp; * Helper Code
        <i>356</i>&nbsp; * -----------------------------------------------------------------
        <i>357</i>&nbsp; */
        <i>358</i>&nbsp;
        <i>359</i>&nbsp; /**
        <i>360</i>&nbsp; * Generate the mac based on HMAC_ALGORITHM
        <i>361</i>&nbsp; * @param integrityKey The key used for hmac
        <i>362</i>&nbsp; * @param byteCipherText the cipher text
        <i>363</i>&nbsp; * @return A byte array of the HMAC for the given key &amp; ciphertext
        <i>364</i>&nbsp; * @throws NoSuchAlgorithmException
        <i>365</i>&nbsp; * @throws InvalidKeyException
        <i>366</i>&nbsp; */
        <i>367</i>&nbsp; public static byte[] generateMac(final byte[] byteCipherText, final
        SecretKey integrityKey) throws NoSuchAlgorithmException, InvalidKeyException {
        <i>368</i>&nbsp; //Now compute the mac for later integrity checking
        <b class="nc"><i>369</i>&nbsp; final Mac sha256_HMAC = Mac.getInstance(HMAC_ALGORITHM);</b>
        <b class="nc"><i>370</i>&nbsp; sha256_HMAC.init(integrityKey);</b>
        <b class="nc"><i>371</i>&nbsp; return sha256_HMAC.doFinal(byteCipherText);</b>
        <i>372</i>&nbsp; }
        <i>373</i>&nbsp; /**
        <i>374</i>&nbsp; * Holder class that has both the secret AES key for encryption
        (confidentiality)
        <i>375</i>&nbsp; * and the secret HMAC key for integrity.
        <i>376</i>&nbsp; */
        <i>377</i>&nbsp;
        <i>378</i>&nbsp; public final static class SecretKeys {
        <i>379</i>&nbsp; private SecretKey confidentialityKey;
        <i>380</i>&nbsp; private SecretKey integrityKey;
        <i>381</i>&nbsp;
        <i>382</i>&nbsp; /**
        <i>383</i>&nbsp; * Construct the secret keys container.
        <i>384</i>&nbsp; * @param confidentialityKeyIn The AES key
        <i>385</i>&nbsp; * @param integrityKeyIn the HMAC key
        <i>386</i>&nbsp; */
        <b class="nc"><i>387</i>&nbsp; public SecretKeys(final SecretKey confidentialityKeyIn, final
            SecretKey integrityKeyIn) {</b>
        <b class="nc"><i>388</i>&nbsp; this.confidentialityKey = confidentialityKeyIn;</b>
        <b class="nc"><i>389</i>&nbsp; this.integrityKey = integrityKeyIn;</b>
        <i>390</i>&nbsp; }
        <i>391</i>&nbsp;
        <i>392</i>&nbsp; public final SecretKey getConfidentialityKey() {
        <b class="nc"><i>393</i>&nbsp; return this.confidentialityKey;</b>
        <i>394</i>&nbsp; }
        <i>395</i>&nbsp;
        <i>396</i>&nbsp; public final void setConfidentialityKey(SecretKey confidentialityKey) {
        <b class="nc"><i>397</i>&nbsp; this.confidentialityKey = confidentialityKey;</b>
        <i>398</i>&nbsp; }
        <i>399</i>&nbsp;
        <i>400</i>&nbsp; public final SecretKey getIntegrityKey() {
        <b class="nc"><i>401</i>&nbsp; return this.integrityKey;</b>
        <i>402</i>&nbsp; }
        <i>403</i>&nbsp;
        <i>404</i>&nbsp; public final void setIntegrityKey(SecretKey integrityKey) {
        <b class="nc"><i>405</i>&nbsp; this.integrityKey = integrityKey;</b>
        <i>406</i>&nbsp; }
        <i>407</i>&nbsp;
        <i>408</i>&nbsp; /**
        <i>409</i>&nbsp; * Encodes the two keys as a string
        <i>410</i>&nbsp; * @return base64(confidentialityKey):base64(integrityKey)
        <i>411</i>&nbsp; */
        <i>412</i>&nbsp; @Override
        <i>413</i>&nbsp; public final String toString () {
        <b class="nc"><i>414</i>&nbsp; return
            Base64.encodeToString(getConfidentialityKey().getEncoded(), BASE64_FLAGS)</b>
        <b class="nc"><i>415</i>&nbsp; + &quot;:&quot; +
            Base64.encodeToString(getIntegrityKey().getEncoded(), BASE64_FLAGS);</b>
        <i>416</i>&nbsp; }
        <i>417</i>&nbsp;
        <i>418</i>&nbsp; @Override
        <i>419</i>&nbsp; public final int hashCode() {
        <b class="nc"><i>420</i>&nbsp; final int prime = 31;</b>
        <b class="nc"><i>421</i>&nbsp; int result = 1;</b>
        <b class="nc"><i>422</i>&nbsp; result = prime * result + confidentialityKey.hashCode();</b>
        <b class="nc"><i>423</i>&nbsp; result = prime * result + integrityKey.hashCode();</b>
        <b class="nc"><i>424</i>&nbsp; return result;</b>
        <i>425</i>&nbsp; }
        <i>426</i>&nbsp;
        <i>427</i>&nbsp; @Override
        <i>428</i>&nbsp; public final boolean equals(@Nullable final Object obj) {
        <b class="nc"><i>429</i>&nbsp; if (this == obj)</b>
        <b class="nc"><i>430</i>&nbsp; return true;</b>
        <b class="nc"><i>431</i>&nbsp; if (obj == null)</b>
        <b class="nc"><i>432</i>&nbsp; return false;</b>
        <b class="nc"><i>433</i>&nbsp; if (getClass() != obj.getClass())</b>
        <b class="nc"><i>434</i>&nbsp; return false;</b>
        <b class="nc"><i>435</i>&nbsp; final SecretKeys other = (SecretKeys) obj;</b>
        <b class="nc"><i>436</i>&nbsp; if (!integrityKey.equals(other.integrityKey))</b>
        <b class="nc"><i>437</i>&nbsp; return false;</b>
        <b class="nc"><i>438</i>&nbsp; if (!confidentialityKey.equals(other.confidentialityKey))</b>
        <b class="nc"><i>439</i>&nbsp; return false;</b>
        <b class="nc"><i>440</i>&nbsp; return true;</b>
        <i>441</i>&nbsp; }
        <i>442</i>&nbsp; }
        <i>443</i>&nbsp;
        <i>444</i>&nbsp;
        <i>445</i>&nbsp; /**
        <i>446</i>&nbsp; * Simple constant-time equality of two byte arrays. Used for security to
        avoid timing attacks.
        <i>447</i>&nbsp; * @param a
        <i>448</i>&nbsp; * @param b
        <i>449</i>&nbsp; * @return true iff the arrays are exactly equal.
        <i>450</i>&nbsp; */
        <i>451</i>&nbsp; public static boolean constantTimeEq(final byte[] a, final byte[] b) {
        <b class="nc"><i>452</i>&nbsp; if (a.length != b.length) {</b>
        <b class="nc"><i>453</i>&nbsp; return false;</b>
        <i>454</i>&nbsp; }
        <b class="nc"><i>455</i>&nbsp; int result = 0;</b>
        <b class="nc"><i>456</i>&nbsp; for (int i = 0; i &lt; a.length; i++) {</b>
        <b class="nc"><i>457</i>&nbsp; result |= a[i] ^ b[i];</b>
        <i>458</i>&nbsp; }
        <b class="nc"><i>459</i>&nbsp; return result == 0;</b>
        <i>460</i>&nbsp; }
        <i>461</i>&nbsp;
        <i>462</i>&nbsp; /**
        <i>463</i>&nbsp; * Holder class that allows us to bundle ciphertext and IV together.
        <i>464</i>&nbsp; */
        <i>465</i>&nbsp; public static final class CipherTextIvMac {
        <i>466</i>&nbsp; private final byte[] cipherText;
        <i>467</i>&nbsp; private final byte[] iv;
        <i>468</i>&nbsp; private final byte[] mac;
        <i>469</i>&nbsp;
        <i>470</i>&nbsp; public byte[] getCipherText() {
        <b class="nc"><i>471</i>&nbsp; return cipherText;</b>
        <i>472</i>&nbsp; }
        <i>473</i>&nbsp;
        <i>474</i>&nbsp; public byte[] getIv() {
        <b class="nc"><i>475</i>&nbsp; return iv;</b>
        <i>476</i>&nbsp; }
        <i>477</i>&nbsp;
        <i>478</i>&nbsp; public byte[] getMac() {
        <b class="nc"><i>479</i>&nbsp; return mac;</b>
        <i>480</i>&nbsp; }
        <i>481</i>&nbsp;
        <i>482</i>&nbsp; /**
        <i>483</i>&nbsp; * Construct a new bundle of ciphertext and IV.
        <i>484</i>&nbsp; * @param c The ciphertext
        <i>485</i>&nbsp; * @param i The IV
        <i>486</i>&nbsp; * @param h The mac
        <i>487</i>&nbsp; */
        <b class="nc"><i>488</i>&nbsp; public CipherTextIvMac(final byte[] c, final byte[] i, final
            byte[] h) {</b>
        <b class="nc"><i>489</i>&nbsp; this.cipherText = new byte[c.length];</b>
        <b class="nc"><i>490</i>&nbsp; System.arraycopy(c, 0, cipherText, 0, c.length);</b>
        <b class="nc"><i>491</i>&nbsp; this.iv = new byte[i.length];</b>
        <b class="nc"><i>492</i>&nbsp; System.arraycopy(i, 0, iv, 0, i.length);</b>
        <b class="nc"><i>493</i>&nbsp; this.mac = new byte[h.length];</b>
        <b class="nc"><i>494</i>&nbsp; System.arraycopy(h, 0, mac, 0, h.length);</b>
        <i>495</i>&nbsp; }
        <i>496</i>&nbsp;
        <i>497</i>&nbsp; /**
        <i>498</i>&nbsp; * Constructs a new bundle of ciphertext and IV from a string of the
        <i>499</i>&nbsp; * format &lt;code&gt;base64(iv):base64(ciphertext)&lt;/code&gt;.
        <i>500</i>&nbsp; *
        <i>501</i>&nbsp; * @param base64IvAndCiphertext A string of the format
        <i>502</i>&nbsp; * &lt;code&gt;iv:ciphertext&lt;/code&gt; The IV and ciphertext must each
        <i>503</i>&nbsp; * be base64-encoded.
        <i>504</i>&nbsp; */
        <b class="nc"><i>505</i>&nbsp; public CipherTextIvMac(final String base64IvAndCiphertext) {</b>
        <b class="nc"><i>506</i>&nbsp; final String[] civArray = base64IvAndCiphertext.split(&quot;:&quot;);</b>
        <b class="nc"><i>507</i>&nbsp; if (civArray.length != 3) {</b>
        <b class="nc"><i>508</i>&nbsp; throw new IllegalArgumentException(&quot;Cannot parse
            iv:ciphertext:mac&quot;);</b>
        <i>509</i>&nbsp; } else {
        <b class="nc"><i>510</i>&nbsp; this.iv = Base64.decode(civArray[0], BASE64_FLAGS);</b>
        <b class="nc"><i>511</i>&nbsp; this.mac = Base64.decode(civArray[1], BASE64_FLAGS);</b>
        <b class="nc"><i>512</i>&nbsp; this.cipherText = Base64.decode(civArray[2],
            BASE64_FLAGS);</b>
        <i>513</i>&nbsp; }
        <i>514</i>&nbsp; }
        <i>515</i>&nbsp;
        <i>516</i>&nbsp; /**
        <i>517</i>&nbsp; * Concatinate the IV to the cipherText using array copy.
        <i>518</i>&nbsp; * This is used e.g. before computing mac.
        <i>519</i>&nbsp; * @param iv The IV to prepend
        <i>520</i>&nbsp; * @param cipherText the cipherText to append
        <i>521</i>&nbsp; * @return iv:cipherText, a new byte array.
        <i>522</i>&nbsp; */
        <i>523</i>&nbsp; @NonNull
        <i>524</i>&nbsp; public static byte[] ivCipherConcat(final byte[] iv, final byte[]
        cipherText) {
        <b class="nc"><i>525</i>&nbsp; final byte[] combined = new byte[iv.length +
            cipherText.length];</b>
        <b class="nc"><i>526</i>&nbsp; System.arraycopy(iv, 0, combined, 0, iv.length);</b>
        <b class="nc"><i>527</i>&nbsp; System.arraycopy(cipherText, 0, combined, iv.length,
            cipherText.length);</b>
        <b class="nc"><i>528</i>&nbsp; return combined;</b>
        <i>529</i>&nbsp; }
        <i>530</i>&nbsp;
        <i>531</i>&nbsp; /**
        <i>532</i>&nbsp; * Encodes this ciphertext, IV, mac as a string.
        <i>533</i>&nbsp; *
        <i>534</i>&nbsp; * @return base64(iv) : base64(mac) : base64(ciphertext).
        <i>535</i>&nbsp; * The iv and mac go first because they&#39;re fixed length.
        <i>536</i>&nbsp; */
        <i>537</i>&nbsp; @Override
        <i>538</i>&nbsp; public final String toString() {
        <b class="nc"><i>539</i>&nbsp; final String ivString = Base64.encodeToString(iv,
            BASE64_FLAGS);</b>
        <b class="nc"><i>540</i>&nbsp; final String cipherTextString =
            Base64.encodeToString(cipherText, BASE64_FLAGS);</b>
        <b class="nc"><i>541</i>&nbsp; final String macString = Base64.encodeToString(mac,
            BASE64_FLAGS);</b>
        <b class="nc"><i>542</i>&nbsp; return ivString + &quot;:&quot; + macString + &quot;:&quot; +
            cipherTextString;</b>
        <i>543</i>&nbsp; }
        <i>544</i>&nbsp;
        <i>545</i>&nbsp; @Override
        <i>546</i>&nbsp; public final int hashCode() {
        <b class="nc"><i>547</i>&nbsp; final int prime = 31;</b>
        <b class="nc"><i>548</i>&nbsp; int result = 1;</b>
        <b class="nc"><i>549</i>&nbsp; result = prime * result + Arrays.hashCode(cipherText);</b>
        <b class="nc"><i>550</i>&nbsp; result = prime * result + Arrays.hashCode(iv);</b>
        <b class="nc"><i>551</i>&nbsp; result = prime * result + Arrays.hashCode(mac);</b>
        <b class="nc"><i>552</i>&nbsp; return result;</b>
        <i>553</i>&nbsp; }
        <i>554</i>&nbsp;
        <i>555</i>&nbsp; @Override
        <i>556</i>&nbsp; public final boolean equals(@Nullable final Object obj) {
        <b class="nc"><i>557</i>&nbsp; if (this == obj)</b>
        <b class="nc"><i>558</i>&nbsp; return true;</b>
        <b class="nc"><i>559</i>&nbsp; if (obj == null)</b>
        <b class="nc"><i>560</i>&nbsp; return false;</b>
        <b class="nc"><i>561</i>&nbsp; if (getClass() != obj.getClass())</b>
        <b class="nc"><i>562</i>&nbsp; return false;</b>
        <b class="nc"><i>563</i>&nbsp; final CipherTextIvMac other = (CipherTextIvMac) obj;</b>
        <b class="nc"><i>564</i>&nbsp; if (!Arrays.equals(cipherText, other.cipherText))</b>
        <b class="nc"><i>565</i>&nbsp; return false;</b>
        <b class="nc"><i>566</i>&nbsp; if (!Arrays.equals(iv, other.iv))</b>
        <b class="nc"><i>567</i>&nbsp; return false;</b>
        <b class="nc"><i>568</i>&nbsp; if (!Arrays.equals(mac, other.mac))</b>
        <b class="nc"><i>569</i>&nbsp; return false;</b>
        <b class="nc"><i>570</i>&nbsp; return true;</b>
        <i>571</i>&nbsp; }
        <i>572</i>&nbsp; }
        <i>573</i>&nbsp;
        <i>574</i>&nbsp; /**
        <i>575</i>&nbsp; * Copy the elements from the start to the end
        <i>576</i>&nbsp; *
        <i>577</i>&nbsp; * @param from the source
        <i>578</i>&nbsp; * @param start the start index to copy
        <i>579</i>&nbsp; * @param end the end index to finish
        <i>580</i>&nbsp; * @return the new buffer
        <i>581</i>&nbsp; */
        <i>582</i>&nbsp; @NonNull
        <i>583</i>&nbsp; private static byte[] copyOfRange(@NonNull final byte[] from, final int
        start, final int end) {
        <b class="nc"><i>584</i>&nbsp; final int length = end - start;</b>
        <b class="nc"><i>585</i>&nbsp; final byte[] result = new byte[length];</b>
        <b class="nc"><i>586</i>&nbsp; System.arraycopy(from, start, result, 0, length);</b>
        <b class="nc"><i>587</i>&nbsp; return result;</b>
        <i>588</i>&nbsp; }
        <i>589</i>&nbsp;
        <i>590</i>&nbsp; /**
        <i>591</i>&nbsp; * Fixes for the RNG as per
        <i>592</i>&nbsp; *
        http://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html
        <i>593</i>&nbsp; *
        <i>594</i>&nbsp; * This software is provided &#39;as-is&#39;, without any express or implied
        <i>595</i>&nbsp; * warranty. In no event will Google be held liable for any damages arising
        <i>596</i>&nbsp; * from the use of this software.
        <i>597</i>&nbsp; *
        <i>598</i>&nbsp; * Permission is granted to anyone to use this software for any purpose,
        <i>599</i>&nbsp; * including commercial applications, and to alter it and redistribute it
        <i>600</i>&nbsp; * freely, as long as the origin is not misrepresented.
        <i>601</i>&nbsp; *
        <i>602</i>&nbsp; * Fixes for the output of the default PRNG having low entropy.
        <i>603</i>&nbsp; *
        <i>604</i>&nbsp; * The fixes need to be applied via {@link #apply()} before any use of Java
        <i>605</i>&nbsp; * Cryptography Architecture primitives. A good place to invoke them is in
        <i>606</i>&nbsp; * the application&#39;s {@code onCreate}.
        <i>607</i>&nbsp; */
        <b class="nc"><i>608</i>&nbsp; public static final class PrngFixes {</b>
        <i>609</i>&nbsp;
        <i>610</i>&nbsp; private static final int VERSION_CODE_JELLY_BEAN = 16;
        <i>611</i>&nbsp; private static final int VERSION_CODE_JELLY_BEAN_MR2 = 18;
        <b class="nc"><i>612</i>&nbsp; private static final byte[]
            BUILD_FINGERPRINT_AND_DEVICE_SERIAL = getBuildFingerprintAndDeviceSerial();</b>
        <i>613</i>&nbsp;
        <i>614</i>&nbsp; /** Hidden constructor to prevent instantiation. */
        <b class="nc"><i>615</i>&nbsp; private PrngFixes() {</b>
        <i>616</i>&nbsp; }
        <i>617</i>&nbsp;
        <i>618</i>&nbsp; /**
        <i>619</i>&nbsp; * Applies all fixes.
        <i>620</i>&nbsp; *
        <i>621</i>&nbsp; * @throws SecurityException if a fix is needed but could not be
        <i>622</i>&nbsp; * applied.
        <i>623</i>&nbsp; */
        <i>624</i>&nbsp; public static void apply() {
        <b class="nc"><i>625</i>&nbsp; applyOpenSSLFix();</b>
        <b class="nc"><i>626</i>&nbsp; installLinuxPRNGSecureRandom();</b>
        <i>627</i>&nbsp; }
        <i>628</i>&nbsp;
        <i>629</i>&nbsp; /**
        <i>630</i>&nbsp; * Applies the fix for OpenSSL PRNG having low entropy. Does nothing if
        <i>631</i>&nbsp; * the fix is not needed.
        <i>632</i>&nbsp; *
        <i>633</i>&nbsp; * @throws SecurityException if the fix is needed but could not be
        <i>634</i>&nbsp; * applied.
        <i>635</i>&nbsp; */
        <i>636</i>&nbsp; private static void applyOpenSSLFix() throws SecurityException {
        <b class="nc"><i>637</i>&nbsp; if ((Build.VERSION.SDK_INT &lt; VERSION_CODE_JELLY_BEAN)</b>
        <i>638</i>&nbsp; || (Build.VERSION.SDK_INT &gt; VERSION_CODE_JELLY_BEAN_MR2)) {
        <i>639</i>&nbsp; // No need to apply the fix
        <i>640</i>&nbsp; return;
        <i>641</i>&nbsp; }
        <i>642</i>&nbsp;
        <i>643</i>&nbsp; try {
        <i>644</i>&nbsp; // Mix in the device- and invocation-specific seed.
        <b class="nc"><i>645</i>&nbsp; Class.forName(&quot;org.apache.harmony.xnet.provider.jsse.NativeCrypto&quot;)</b>
        <b class="nc"><i>646</i>&nbsp; .getMethod(&quot;RAND_seed&quot;, byte[].class).invoke(null,
            generateSeed());</b>
        <i>647</i>&nbsp;
        <i>648</i>&nbsp; // Mix output of Linux PRNG into OpenSSL&#39;s PRNG
        <b class="nc"><i>649</i>&nbsp; final int bytesRead = (Integer) Class</b>
        <b class="nc"><i>650</i>&nbsp; .forName(&quot;org.apache.harmony.xnet.provider.jsse.NativeCrypto&quot;)</b>
        <b class="nc"><i>651</i>&nbsp; .getMethod(&quot;RAND_load_file&quot;, String.class,
            long.class)</b>
        <b class="nc"><i>652</i>&nbsp; .invoke(null, &quot;/dev/urandom&quot;, 1024);</b>
        <b class="nc"><i>653</i>&nbsp; if (bytesRead != 1024) {</b>
        <b class="nc"><i>654</i>&nbsp; throw new IOException(&quot;Unexpected number of bytes read
            from Linux PRNG: &quot;</b>
        <i>655</i>&nbsp; + bytesRead);
        <i>656</i>&nbsp; }
        <b class="nc"><i>657</i>&nbsp; } catch (Exception e) {</b>
        <i>658</i>&nbsp; if (ALLOW_BROKEN_PRNG) {
        <i>659</i>&nbsp; Log.w(PrngFixes.class.getSimpleName(), &quot;Failed to seed OpenSSL PRNG&quot;,
        e);
        <i>660</i>&nbsp; } else {
        <b class="nc"><i>661</i>&nbsp; throw new SecurityException(&quot;Failed to seed OpenSSL PRNG&quot;,
            e);</b>
        <i>662</i>&nbsp; }
        <b class="nc"><i>663</i>&nbsp; }</b>
        <i>664</i>&nbsp; }
        <i>665</i>&nbsp;
        <i>666</i>&nbsp; /**
        <i>667</i>&nbsp; * Installs a Linux PRNG-backed {@code SecureRandom} implementation as
        <i>668</i>&nbsp; * the default. Does nothing if the implementation is already the
        <i>669</i>&nbsp; * default or if there is not need to install the implementation.
        <i>670</i>&nbsp; *
        <i>671</i>&nbsp; * @throws SecurityException if the fix is needed but could not be
        <i>672</i>&nbsp; * applied.
        <i>673</i>&nbsp; */
        <i>674</i>&nbsp; private static void installLinuxPRNGSecureRandom() throws SecurityException
        {
        <b class="nc"><i>675</i>&nbsp; if (Build.VERSION.SDK_INT &gt; VERSION_CODE_JELLY_BEAN_MR2) {</b>
        <i>676</i>&nbsp; // No need to apply the fix
        <i>677</i>&nbsp; return;
        <i>678</i>&nbsp; }
        <i>679</i>&nbsp;
        <i>680</i>&nbsp; // Install a Linux PRNG-based SecureRandom implementation as the
        <i>681</i>&nbsp; // default, if not yet installed.
        <b class="nc"><i>682</i>&nbsp; final Provider[] secureRandomProviders =
            Security.getProviders(&quot;SecureRandom.SHA1PRNG&quot;);</b>
        <i>683</i>&nbsp;
        <i>684</i>&nbsp; // Insert and check the provider atomically.
        <i>685</i>&nbsp; // The official Android Java libraries use synchronized methods for
        <i>686</i>&nbsp; // insertProviderAt, etc., so synchronizing on the class should
        <i>687</i>&nbsp; // make things more stable, and prevent race conditions with other
        <i>688</i>&nbsp; // versions of this code.
        <b class="nc"><i>689</i>&nbsp; synchronized (Security.class) {</b>
        <b class="nc"><i>690</i>&nbsp; if ((secureRandomProviders == null)</b>
        <i>691</i>&nbsp; || (secureRandomProviders.length &lt; 1)
        <b class="nc"><i>692</i>&nbsp; ||
            (!secureRandomProviders[0].getClass().getSimpleName().equals(&quot;LinuxPRNGSecureRandomProvider&quot;)))
            {</b>
        <b class="nc"><i>693</i>&nbsp; Security.insertProviderAt(new
            LinuxPRNGSecureRandomProvider(), 1);</b>
        <i>694</i>&nbsp; }
        <i>695</i>&nbsp;
        <i>696</i>&nbsp; // Assert that new SecureRandom() and
        <i>697</i>&nbsp; // SecureRandom.getInstance(&quot;SHA1PRNG&quot;) return a SecureRandom
        backed
        <i>698</i>&nbsp; // by the Linux PRNG-based SecureRandom implementation.
        <b class="nc"><i>699</i>&nbsp; final SecureRandom rng1 = new SecureRandom();</b>
        <b class="nc"><i>700</i>&nbsp; if (!rng1.getProvider().getClass().getSimpleName().equals(&quot;LinuxPRNGSecureRandomProvider&quot;))
            {</b>
        <i>701</i>&nbsp; if (ALLOW_BROKEN_PRNG) {
        <i>702</i>&nbsp; Log.w(PrngFixes.class.getSimpleName(),
        <i>703</i>&nbsp; &quot;new SecureRandom() backed by wrong Provider: &quot; +
        rng1.getProvider().getClass());
        <i>704</i>&nbsp; return;
        <i>705</i>&nbsp; } else {
        <b class="nc"><i>706</i>&nbsp; throw new SecurityException(&quot;new SecureRandom() backed
            by wrong Provider: &quot;</b>
        <b class="nc"><i>707</i>&nbsp; + rng1.getProvider().getClass());</b>
        <i>708</i>&nbsp; }
        <i>709</i>&nbsp; }
        <i>710</i>&nbsp;
        <b class="nc"><i>711</i>&nbsp; SecureRandom rng2 = null;</b>
        <i>712</i>&nbsp; try {
        <b class="nc"><i>713</i>&nbsp; rng2 = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</b>
        <b class="nc"><i>714</i>&nbsp; } catch (NoSuchAlgorithmException e) {</b>
        <i>715</i>&nbsp; if (ALLOW_BROKEN_PRNG) {
        <i>716</i>&nbsp; Log.w(PrngFixes.class.getSimpleName(), &quot;SHA1PRNG not available&quot;,
        e);
        <i>717</i>&nbsp; return;
        <i>718</i>&nbsp; } else {
        <b class="nc"><i>719</i>&nbsp; new SecurityException(&quot;SHA1PRNG not available&quot;, e);</b>
        <i>720</i>&nbsp; }
        <b class="nc"><i>721</i>&nbsp; }</b>
        <b class="nc"><i>722</i>&nbsp; if (!rng2.getProvider().getClass().getSimpleName().equals(&quot;LinuxPRNGSecureRandomProvider&quot;))
            {</b>
        <i>723</i>&nbsp; if (ALLOW_BROKEN_PRNG) {
        <i>724</i>&nbsp; Log.w(PrngFixes.class.getSimpleName(),
        <i>725</i>&nbsp; &quot;SecureRandom.getInstance(\&quot;SHA1PRNG\&quot;) backed by wrong&quot;
        + &quot; Provider: &quot;
        <i>726</i>&nbsp; + rng2.getProvider().getClass());
        <i>727</i>&nbsp; return;
        <i>728</i>&nbsp; } else {
        <b class="nc"><i>729</i>&nbsp; throw new SecurityException(</b>
        <i>730</i>&nbsp; &quot;SecureRandom.getInstance(\&quot;SHA1PRNG\&quot;) backed by wrong&quot;
        + &quot; Provider: &quot;
        <b class="nc"><i>731</i>&nbsp; + rng2.getProvider().getClass());</b>
        <i>732</i>&nbsp; }
        <i>733</i>&nbsp; }
        <b class="nc"><i>734</i>&nbsp; }</b>
        <i>735</i>&nbsp; }
        <i>736</i>&nbsp;
        <i>737</i>&nbsp; /**
        <i>738</i>&nbsp; * {@code Provider} of {@code SecureRandom} engines which pass through
        <i>739</i>&nbsp; * all requests to the Linux PRNG.
        <i>740</i>&nbsp; */
        <i>741</i>&nbsp; private static final class LinuxPRNGSecureRandomProvider extends Provider {
        <i>742</i>&nbsp;
        <i>743</i>&nbsp; public LinuxPRNGSecureRandomProvider() {
        <b class="nc"><i>744</i>&nbsp; super(&quot;LinuxPRNG&quot;, 1.0, &quot;A Linux-specific
            random number provider that uses&quot;</b>
        <i>745</i>&nbsp; + &quot; /dev/urandom&quot;);
        <i>746</i>&nbsp; // Although /dev/urandom is not a SHA-1 PRNG, some apps
        <i>747</i>&nbsp; // explicitly request a SHA1PRNG SecureRandom and we thus need
        <i>748</i>&nbsp; // to prevent them from getting the default implementation whose
        <i>749</i>&nbsp; // output may have low entropy.
        <b class="nc"><i>750</i>&nbsp; put(&quot;SecureRandom.SHA1PRNG&quot;,
            LinuxPRNGSecureRandom.class.getName());</b>
        <b class="nc"><i>751</i>&nbsp; put(&quot;SecureRandom.SHA1PRNG ImplementedIn&quot;, &quot;Software&quot;);</b>
        <i>752</i>&nbsp; }
        <i>753</i>&nbsp; }
        <i>754</i>&nbsp;
        <i>755</i>&nbsp; /**
        <i>756</i>&nbsp; * {@link SecureRandomSpi} which passes all requests to the Linux PRNG (
        <i>757</i>&nbsp; * {@code /dev/urandom}).
        <i>758</i>&nbsp; */
        <b class="nc"><i>759</i>&nbsp; public static final class LinuxPRNGSecureRandom extends
            SecureRandomSpi {</b>
        <i>760</i>&nbsp;
        <i>761</i>&nbsp; /*
        <i>762</i>&nbsp; * IMPLEMENTATION NOTE: Requests to generate bytes and to mix in a
        <i>763</i>&nbsp; * seed are passed through to the Linux PRNG (/dev/urandom).
        <i>764</i>&nbsp; * Instances of this class seed themselves by mixing in the current
        <i>765</i>&nbsp; * time, PID, UID, build fingerprint, and hardware serial number
        <i>766</i>&nbsp; * (where available) into Linux PRNG.
        <i>767</i>&nbsp; *
        <i>768</i>&nbsp; * Concurrency: ReadRequestEvent requests to the underlying Linux PRNG are
        <i>769</i>&nbsp; * serialized (on sLock) to ensure that multiple threads do not get
        <i>770</i>&nbsp; * duplicated PRNG output.
        <i>771</i>&nbsp; */
        <i>772</i>&nbsp;
        <b class="nc"><i>773</i>&nbsp; private static final File URANDOM_FILE = new File(&quot;/dev/urandom&quot;);</b>
        <i>774</i>&nbsp;
        <b class="nc"><i>775</i>&nbsp; private static final Object sLock = new Object();</b>
        <i>776</i>&nbsp;
        <i>777</i>&nbsp; /**
        <i>778</i>&nbsp; * Input stream for reading from Linux PRNG or {@code null} if not
        <i>779</i>&nbsp; * yet opened.
        <i>780</i>&nbsp; *
        <i>781</i>&nbsp; * @GuardedBy(&quot;sLock&quot;)
        <i>782</i>&nbsp; */
        <i>783</i>&nbsp; private static DataInputStream sUrandomIn;
        <i>784</i>&nbsp;
        <i>785</i>&nbsp; /**
        <i>786</i>&nbsp; * Output stream for writing to Linux PRNG or {@code null} if not
        <i>787</i>&nbsp; * yet opened.
        <i>788</i>&nbsp; *
        <i>789</i>&nbsp; * @GuardedBy(&quot;sLock&quot;)
        <i>790</i>&nbsp; */
        <i>791</i>&nbsp; private static OutputStream sUrandomOut;
        <i>792</i>&nbsp;
        <i>793</i>&nbsp; /**
        <i>794</i>&nbsp; * Whether this engine instance has been seeded. This is needed
        <i>795</i>&nbsp; * because each instance needs to seed itself if the client does not
        <i>796</i>&nbsp; * explicitly seed it.
        <i>797</i>&nbsp; */
        <i>798</i>&nbsp; private boolean mSeeded;
        <i>799</i>&nbsp;
        <i>800</i>&nbsp; @Override
        <i>801</i>&nbsp; protected void engineSetSeed(@NonNull byte[] bytes) {
        <i>802</i>&nbsp; try {
        <i>803</i>&nbsp; OutputStream out;
        <b class="nc"><i>804</i>&nbsp; synchronized (sLock) {</b>
        <b class="nc"><i>805</i>&nbsp; out = getUrandomOutputStream();</b>
        <b class="nc"><i>806</i>&nbsp; }</b>
        <b class="nc"><i>807</i>&nbsp; out.write(bytes);</b>
        <b class="nc"><i>808</i>&nbsp; out.flush();</b>
        <b class="nc"><i>809</i>&nbsp; } catch (@NonNull final IOException e) {</b>
        <i>810</i>&nbsp; // On a small fraction of devices /dev/urandom is not
        <i>811</i>&nbsp; // writable Log and ignore.
        <b class="nc"><i>812</i>&nbsp; Log.w(PrngFixes.class.getSimpleName(), &quot;Failed to mix
            seed into &quot;</b>
        <i>813</i>&nbsp; + URANDOM_FILE);
        <i>814</i>&nbsp; } finally {
        <b class="nc"><i>815</i>&nbsp; mSeeded = true;</b>
        <b class="nc"><i>816</i>&nbsp; }</b>
        <i>817</i>&nbsp; }
        <i>818</i>&nbsp;
        <i>819</i>&nbsp; @Override
        <i>820</i>&nbsp; protected void engineNextBytes(@NonNull byte[] bytes) {
        <b class="nc"><i>821</i>&nbsp; if (!mSeeded) {</b>
        <i>822</i>&nbsp; // Mix in the device- and invocation-specific seed.
        <b class="nc"><i>823</i>&nbsp; engineSetSeed(generateSeed());</b>
        <i>824</i>&nbsp; }
        <i>825</i>&nbsp;
        <i>826</i>&nbsp; try {
        <i>827</i>&nbsp; final DataInputStream in;
        <b class="nc"><i>828</i>&nbsp; synchronized (sLock) {</b>
        <b class="nc"><i>829</i>&nbsp; in = getUrandomInputStream();</b>
        <b class="nc"><i>830</i>&nbsp; }</b>
        <b class="nc"><i>831</i>&nbsp; synchronized (in) {</b>
        <b class="nc"><i>832</i>&nbsp; in.readFully(bytes);</b>
        <b class="nc"><i>833</i>&nbsp; }</b>
        <b class="nc"><i>834</i>&nbsp; } catch (@NonNull final IOException e) {</b>
        <b class="nc"><i>835</i>&nbsp; throw new SecurityException(&quot;Failed to read from &quot;
            + URANDOM_FILE, e);</b>
        <b class="nc"><i>836</i>&nbsp; }</b>
        <i>837</i>&nbsp; }
        <i>838</i>&nbsp;
        <i>839</i>&nbsp; @NonNull
        <i>840</i>&nbsp; @Override
        <i>841</i>&nbsp; protected final byte[] engineGenerateSeed(int size) {
        <b class="nc"><i>842</i>&nbsp; final byte[] seed = new byte[size];</b>
        <b class="nc"><i>843</i>&nbsp; engineNextBytes(seed);</b>
        <b class="nc"><i>844</i>&nbsp; return seed;</b>
        <i>845</i>&nbsp; }
        <i>846</i>&nbsp;
        <i>847</i>&nbsp; private DataInputStream getUrandomInputStream() {
        <b class="nc"><i>848</i>&nbsp; synchronized (sLock) {</b>
        <b class="nc"><i>849</i>&nbsp; if (sUrandomIn == null) {</b>
        <i>850</i>&nbsp; // NOTE: Consider inserting a BufferedInputStream
        <i>851</i>&nbsp; // between DataInputStream and FileInputStream if you need
        <i>852</i>&nbsp; // higher PRNG output performance and can live with future PRNG
        <i>853</i>&nbsp; // output being pulled into this process prematurely.
        <i>854</i>&nbsp; try {
        <b class="nc"><i>855</i>&nbsp; sUrandomIn = new DataInputStream(new
            FileInputStream(URANDOM_FILE));</b>
        <b class="nc"><i>856</i>&nbsp; } catch (@NonNull final IOException e) {</b>
        <b class="nc"><i>857</i>&nbsp; throw new SecurityException(&quot;Failed to open &quot; +
            URANDOM_FILE</b>
        <i>858</i>&nbsp; + &quot; for reading&quot;, e);
        <b class="nc"><i>859</i>&nbsp; }</b>
        <i>860</i>&nbsp; }
        <b class="nc"><i>861</i>&nbsp; return sUrandomIn;</b>
        <b class="nc"><i>862</i>&nbsp; }</b>
        <i>863</i>&nbsp; }
        <i>864</i>&nbsp;
        <i>865</i>&nbsp; private OutputStream getUrandomOutputStream() throws IOException {
        <b class="nc"><i>866</i>&nbsp; synchronized (sLock) {</b>
        <b class="nc"><i>867</i>&nbsp; if (sUrandomOut == null) {</b>
        <b class="nc"><i>868</i>&nbsp; sUrandomOut = new FileOutputStream(URANDOM_FILE);</b>
        <i>869</i>&nbsp; }
        <b class="nc"><i>870</i>&nbsp; return sUrandomOut;</b>
        <b class="nc"><i>871</i>&nbsp; }</b>
        <i>872</i>&nbsp; }
        <i>873</i>&nbsp; }
        <i>874</i>&nbsp;
        <i>875</i>&nbsp; /**
        <i>876</i>&nbsp; * Generates a device- and invocation-specific seed to be mixed into the
        <i>877</i>&nbsp; * Linux PRNG.
        <i>878</i>&nbsp; */
        <i>879</i>&nbsp; private static byte[] generateSeed() {
        <i>880</i>&nbsp; try {
        <b class="nc"><i>881</i>&nbsp; final ByteArrayOutputStream seedBuffer = new
            ByteArrayOutputStream();</b>
        <b class="nc"><i>882</i>&nbsp; final DataOutputStream seedBufferOut = new
            DataOutputStream(seedBuffer);</b>
        <b class="nc"><i>883</i>&nbsp; seedBufferOut.writeLong(System.currentTimeMillis());</b>
        <b class="nc"><i>884</i>&nbsp; seedBufferOut.writeLong(System.nanoTime());</b>
        <b class="nc"><i>885</i>&nbsp; seedBufferOut.writeInt(Process.myPid());</b>
        <b class="nc"><i>886</i>&nbsp; seedBufferOut.writeInt(Process.myUid());</b>
        <b class="nc"><i>887</i>&nbsp; seedBufferOut.write(BUILD_FINGERPRINT_AND_DEVICE_SERIAL);</b>
        <b class="nc"><i>888</i>&nbsp; seedBufferOut.close();</b>
        <b class="nc"><i>889</i>&nbsp; return seedBuffer.toByteArray();</b>
        <b class="nc"><i>890</i>&nbsp; } catch (@NonNull final IOException e) {</b>
        <b class="nc"><i>891</i>&nbsp; throw new SecurityException(&quot;Failed to generate seed&quot;,
            e);</b>
        <i>892</i>&nbsp; }
        <i>893</i>&nbsp; }
        <i>894</i>&nbsp;
        <i>895</i>&nbsp; /**
        <i>896</i>&nbsp; * Gets the hardware serial number of this device.
        <i>897</i>&nbsp; *
        <i>898</i>&nbsp; * @return serial number or {@code null} if not available.
        <i>899</i>&nbsp; */
        <i>900</i>&nbsp; private static String getDeviceSerialNumber() {
        <i>901</i>&nbsp; // We&#39;re using the Reflection API because Build.SERIAL is only
        <i>902</i>&nbsp; // available since API Level 9 (Gingerbread, Android 2.3).
        <i>903</i>&nbsp; try {
        <b class="nc"><i>904</i>&nbsp; return (String) Build.class.getField(&quot;SERIAL&quot;).get(null);</b>
        <b class="nc"><i>905</i>&nbsp; } catch (@NonNull final Exception ignored) {</b>
        <b class="nc"><i>906</i>&nbsp; return null;</b>
        <i>907</i>&nbsp; }
        <i>908</i>&nbsp; }
        <i>909</i>&nbsp;
        <i>910</i>&nbsp; private static byte[] getBuildFingerprintAndDeviceSerial() {
        <b class="nc"><i>911</i>&nbsp; final StringBuilder result = new StringBuilder();</b>
        <b class="nc"><i>912</i>&nbsp; final String fingerprint = Build.FINGERPRINT;</b>
        <b class="nc"><i>913</i>&nbsp; if (fingerprint != null) {</b>
        <b class="nc"><i>914</i>&nbsp; result.append(fingerprint);</b>
        <i>915</i>&nbsp; }
        <b class="nc"><i>916</i>&nbsp; final String serial = getDeviceSerialNumber();</b>
        <b class="nc"><i>917</i>&nbsp; if (serial != null) {</b>
        <b class="nc"><i>918</i>&nbsp; result.append(serial);</b>
        <i>919</i>&nbsp; }
        <i>920</i>&nbsp; try {
        <b class="nc"><i>921</i>&nbsp; return result.toString().getBytes(&quot;UTF-8&quot;);</b>
        <b class="nc"><i>922</i>&nbsp; } catch (UnsupportedEncodingException e) {</b>
        <b class="nc"><i>923</i>&nbsp; throw new RuntimeException(&quot;UTF-8 encoding not supported&quot;);</b>
        <i>924</i>&nbsp; }
        <i>925</i>&nbsp; }
        <i>926</i>&nbsp; }
        <i>927</i>&nbsp;}
    </div>
</div>

<div class="footer">

    <div style="float:right;">generated on 2020-06-10 10:26</div>
</div>
</body>
</html>
