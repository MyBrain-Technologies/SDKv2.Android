<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
    <title>Coverage Report :: MbtBluetoothLE</title>
    <style type="text/css">
    @import "../../.css/coverage.css";

    </style>
</head>

<body>
<div class="header"></div>

<div class="content">
    <div class="breadCrumbs">
        [ <a href="../../index.html">all classes</a> ]
        [ <a href="../index.html">core.bluetooth.lowenergy</a> ]
    </div>

    <h1>Coverage Summary for Class: MbtBluetoothLE (core.bluetooth.lowenergy)</h1>

    <table class="coverageStats">

        <tr>
            <th class="name">Class</th>
            <th class="coverageStat
">
                Method, %
            </th>
            <th class="coverageStat
">
                Line, %
            </th>
        </tr>
        <tr>
            <td class="name">MbtBluetoothLE</td>
            <td class="coverageStat">
  <span class="percent">
    60%
  </span>
                <span class="absValue">
    (27/ 45)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    51%
  </span>
                <span class="absValue">
    (127/ 249)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name">MbtBluetoothLE$Companion</td>
            <td class="coverageStat">
  <span class="percent">
    100%
  </span>
                <span class="absValue">
    (3/ 3)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    100%
  </span>
                <span class="absValue">
    (3/ 3)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name">MbtBluetoothLE$receiver$1</td>
            <td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
                <span class="absValue">
    (1/ 3)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    9,1%
  </span>
                <span class="absValue">
    (1/ 11)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name">MbtBluetoothLE$scanCallback$1</td>
            <td class="coverageStat">
  <span class="percent">
    33,3%
  </span>
                <span class="absValue">
    (1/ 3)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    7,7%
  </span>
                <span class="absValue">
    (1/ 13)
  </span>
            </td>
        </tr>
        <tr>
            <td class="name"><strong>total</strong></td>
            <td class="coverageStat">
  <span class="percent">
    59,3%
  </span>
                <span class="absValue">
    (32/ 54)
  </span>
            </td>
            <td class="coverageStat">
  <span class="percent">
    47,8%
  </span>
                <span class="absValue">
    (132/ 276)
  </span>
            </td>
        </tr>
    </table>

    <br/>
    <br/>


    <div class="sourceCode"><i>1</i>&nbsp;package core.bluetooth.lowenergy
        <i>2</i>&nbsp;
        <i>3</i>&nbsp;import android.Manifest
        <i>4</i>&nbsp;import android.bluetooth.*
        <i>5</i>&nbsp;import android.bluetooth.le.*
        <i>6</i>&nbsp;import android.content.Context
        <i>7</i>&nbsp;import android.content.Intent
        <i>8</i>&nbsp;import android.os.Build
        <i>9</i>&nbsp;import android.os.Handler
        <i>10</i>&nbsp;import android.os.ParcelUuid
        <i>11</i>&nbsp;import android.util.Log
        <i>12</i>&nbsp;import command.BluetoothCommands.Mtu
        <i>13</i>&nbsp;import command.CommandInterface.MbtCommand
        <i>14</i>&nbsp;import command.DeviceCommand
        <i>15</i>&nbsp;import command.DeviceCommandEvent
        <i>16</i>&nbsp;import command.DeviceCommandEvent.MBX_CONNECT_IN_A2DP
        <i>17</i>&nbsp;import
        command.DeviceCommandEvent.Companion.CMD_CODE_CONNECT_IN_A2DP_JACK_CONNECTED
        <i>18</i>&nbsp;import command.DeviceCommandEvent.Companion.CMD_CODE_CONNECT_IN_A2DP_SUCCESS
        <i>19</i>&nbsp;import command.OADCommands.TransferPacket
        <i>20</i>&nbsp;import config.MbtConfig
        <i>21</i>&nbsp;import core.bluetooth.BluetoothInterfaces.IDeviceInfoMonitor
        <i>22</i>&nbsp;import core.bluetooth.BluetoothProtocol
        <i>23</i>&nbsp;import core.bluetooth.BluetoothState
        <i>24</i>&nbsp;import core.bluetooth.MbtBluetoothManager
        <i>25</i>&nbsp;import core.bluetooth.MbtDataBluetooth.MainBluetooth
        <i>26</i>&nbsp;import core.bluetooth.StreamState
        <i>27</i>&nbsp;import core.device.DeviceEvents.RawDeviceMeasure
        <i>28</i>&nbsp;import core.device.model.DeviceInfo
        <i>29</i>&nbsp;import core.device.model.MelomindDevice
        <i>30</i>&nbsp;import core.device.model.MelomindsQRDataBase
        <i>31</i>&nbsp;import engine.clientevents.BaseError
        <i>32</i>&nbsp;import engine.clientevents.BluetoothError
        <i>33</i>&nbsp;import engine.clientevents.ConnectionStateReceiver
        <i>34</i>&nbsp;import eventbus.events.BluetoothResponseEvent
        <i>35</i>&nbsp;import features.MbtFeatures
        <i>36</i>&nbsp;import utils.*
        <i>37</i>&nbsp;import java.util.*
        <i>38</i>&nbsp;
        <i>39</i>&nbsp;/** This class contains all required methods to interact with a LE bluetooth
        peripheral, such as Melomind.
        <i>40</i>&nbsp; *
        <i>41</i>&nbsp; * In order to work [Manifest.permission.BLUETOOTH] and
        [Manifest.permission.BLUETOOTH_ADMIN] permissions are required
        <i>42</i>&nbsp; * Created by Etienne on 08/02/2018. */
        <b class="fc"><i>43</i>&nbsp;class MbtBluetoothLE(manager: MbtBluetoothManager) :
            MainBluetooth(BluetoothProtocol.LOW_ENERGY, manager), IDeviceInfoMonitor {</b>
        <i>44</i>&nbsp; /** An internal event used to notify MbtBluetoothLE that A2DP has
        disconnected. */
        <b class="fc"><i>45</i>&nbsp; private val mbtGattController: MbtGattController =
            MbtGattController(this)</b>
        <b class="nc"><i>46</i>&nbsp; lateinit var bluetoothLeScanner: BluetoothLeScanner</b>
        <b class="fc"><i>47</i>&nbsp; var gatt: BluetoothGatt? = null</b>
        <i>48</i>&nbsp;
        <b class="fc"><i>49</i>&nbsp; private val receiver: ConnectionStateReceiver = object :
            ConnectionStateReceiver() {</b>
        <b class="nc"><i>50</i>&nbsp; override fun onError(error: BaseError, additionalInfo: String)
            {}</b>
        <i>51</i>&nbsp; override fun onReceive(context: Context, intent: Intent) {
        <b class="nc"><i>52</i>&nbsp; val action = intent.action</b>
        <b class="nc"><i>53</i>&nbsp; if (action != null) {</b>
        <b class="nc"><i>54</i>&nbsp; val device = intent.getParcelableExtra&lt;BluetoothDevice&gt;(BluetoothDevice.EXTRA_DEVICE)</b>
        <b class="nc"><i>55</i>&nbsp; LogUtils.d(TAG, &quot;received intent &quot; + action + &quot;
            for device &quot; + device?.name)</b>
        <b class="nc"><i>56</i>&nbsp; if (action == BluetoothDevice.ACTION_BOND_STATE_CHANGED) {</b>
        <b class="nc"><i>57</i>&nbsp; if (intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, 0) ==
            BluetoothDevice.BOND_BONDED) {</b>
        <b class="nc"><i>58</i>&nbsp; Handler().postDelayed({</b>
        <i>59</i>&nbsp; if (currentState == BluetoothState.BONDING) updateConnectionState(true)
        //current state is set to BONDED &amp; and future is completed
        <b class="nc"><i>60</i>&nbsp; }, 1000)</b>
        <i>61</i>&nbsp; }
        <i>62</i>&nbsp; }
        <i>63</i>&nbsp; }
        <b class="nc"><i>64</i>&nbsp; }</b>
        <i>65</i>&nbsp; }
        <i>66</i>&nbsp;
        <b class="fc"><i>67</i>&nbsp; companion object {</b>
        <b class="fc"><i>68</i>&nbsp; private val TAG = MbtBluetoothLE::class.java.simpleName</b>
        <i>69</i>&nbsp; private const val START = true
        <i>70</i>&nbsp; private const val STOP = false
        <i>71</i>&nbsp; private const val CONNECT_GATT_METHOD = &quot;connectGatt&quot;
        <i>72</i>&nbsp; private const val REMOVE_BOND_METHOD = &quot;removeBond&quot;
        <b class="fc"><i>73</i>&nbsp; var instance: MbtBluetoothLE? = null</b>
        <i>74</i>&nbsp; fun initInstance(manager: MbtBluetoothManager): MainBluetooth {
        <b class="fc"><i>75</i>&nbsp; return MbtBluetoothLE(manager).also { instance = it }</b>
        <i>76</i>&nbsp; }
        <i>77</i>&nbsp; }
        <i>78</i>&nbsp;
        <i>79</i>&nbsp; /** Start bluetooth low energy scanner in order to find BLE device that
        matches the specific filters.
        <i>80</i>&nbsp; *
        <i>81</i>&nbsp; * **Note:** This method will consume your mobile/tablet battery. Please
        consider calling
        <i>82</i>&nbsp; * [.stopScan] when scanning is no longer needed.
        <i>83</i>&nbsp; * @return Each found device that matches the specified filters
        <i>84</i>&nbsp; */
        <i>85</i>&nbsp; override fun startScan(): Boolean {
        <b class="fc"><i>86</i>&nbsp; val filterOnDeviceService = true</b>
        <b class="fc"><i>87</i>&nbsp; LogUtils.i(TAG, &quot; start low energy scan on device &quot;
            + manager.context.deviceNameRequested)</b>
        <b class="fc"><i>88</i>&nbsp; val mFilters: MutableList&lt;ScanFilter&gt; = ArrayList()</b>
        <b class="fc"><i>89</i>&nbsp; if (super.bluetoothAdapter == null ||
            super.bluetoothAdapter?.bluetoothLeScanner == null) {</b>
        <b class="fc"><i>90</i>&nbsp; Log.e(TAG, &quot;Unable to get LE scanner&quot;)</b>
        <b class="fc"><i>91</i>&nbsp; notifyConnectionStateChanged(BluetoothState.SCAN_FAILURE)</b>
        <b class="fc"><i>92</i>&nbsp; return false</b>
        <b class="nc"><i>93</i>&nbsp; } else bluetoothLeScanner =
            super.bluetoothAdapter!!.bluetoothLeScanner</b>
        <b class="nc"><i>94</i>&nbsp; currentDevice = null</b>
        <b class="nc"><i>95</i>&nbsp; if (filterOnDeviceService) {</b>
        <b class="nc"><i>96</i>&nbsp; val filterService = ScanFilter.Builder()</b>
        <b class="nc"><i>97</i>&nbsp;
            .setServiceUuid(ParcelUuid(MelomindCharacteristics.SERVICE_MEASUREMENT))</b>
        <b class="nc"><i>98</i>&nbsp; if (manager.context.deviceNameRequested != null)
            filterService.setDeviceName(manager.context.deviceNameRequested)</b>
        <b class="nc"><i>99</i>&nbsp; mFilters.add(filterService.build())</b>
        <i>100</i>&nbsp; }
        <b class="nc"><i>101</i>&nbsp; val settings = ScanSettings.Builder()</b>
        <b class="nc"><i>102</i>&nbsp; .setReportDelay(0)</b>
        <b class="nc"><i>103</i>&nbsp; .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)</b>
        <b class="nc"><i>104</i>&nbsp; .build()</b>
        <b class="nc"><i>105</i>&nbsp; LogUtils.i(TAG, String.format(&quot;Starting Low Energy Scan
            with filtering on name &#39;%s&#39; and service UUID &#39;%s&#39;&quot;,
            manager.context.deviceNameRequested, MelomindCharacteristics.SERVICE_MEASUREMENT))</b>
        <b class="nc"><i>106</i>&nbsp; bluetoothLeScanner.startScan(mFilters, settings,
            scanCallback)</b>
        <b class="nc"><i>107</i>&nbsp; if (currentState ==
            BluetoothState.READY_FOR_BLUETOOTH_OPERATION)
            manager.connecter.updateConnectionState(false) //current state is set to
            SCAN_STARTED</b>
        <b class="nc"><i>108</i>&nbsp; return true //true : scan is started</b>
        <i>109</i>&nbsp; }
        <i>110</i>&nbsp;
        <i>111</i>&nbsp; /** callback used when scanning using bluetooth Low Energy scanner. */
        <b class="fc"><i>112</i>&nbsp; private val scanCallback: ScanCallback = object :
            ScanCallback() {</b>
        <i>113</i>&nbsp; override fun onScanResult(callbackType: Int, result: ScanResult) {
        //Callback when a BLE advertisement has been found.
        <b class="nc"><i>114</i>&nbsp; AsyncUtils.executeAsync(Runnable {</b>
        <i>115</i>&nbsp; if (currentState == BluetoothState.SCAN_STARTED) {
        <i>116</i>&nbsp; super.onScanResult(callbackType, result)
        <i>117</i>&nbsp; currentDevice = result.device
        <i>118</i>&nbsp; LogUtils.i(TAG, String.format(&quot;Stopping Low Energy Scan -&gt; device
        detected &quot; + &quot;with name &#39;%s&#39; and MAC address &#39;%s&#39; &quot;,
        currentDevice?.name, currentDevice?.address))
        <i>119</i>&nbsp; updateConnectionState(true) //current state is set to DEVICE_FOUND and
        future is completed
        <i>120</i>&nbsp; }
        <i>121</i>&nbsp; })
        <b class="nc"><i>122</i>&nbsp; }</b>
        <i>123</i>&nbsp;
        <i>124</i>&nbsp; override fun onScanFailed(errorCode: Int) { //Callback when scan could not
        be started.
        <b class="nc"><i>125</i>&nbsp; super.onScanFailed(errorCode)</b>
        <b class="nc"><i>126</i>&nbsp; var msg = &quot;Could not start scan. Reason -&gt; &quot;</b>
        <b class="nc"><i>127</i>&nbsp; if (errorCode == SCAN_FAILED_ALREADY_STARTED) {</b>
        <b class="nc"><i>128</i>&nbsp; msg += &quot;Scan already started!&quot;</b>
        <b class="nc"><i>129</i>&nbsp;
            notifyConnectionStateChanged(BluetoothState.SCAN_FAILED_ALREADY_STARTED)</b>
        <i>130</i>&nbsp; } else {
        <b class="nc"><i>131</i>&nbsp; msg += &quot;Scan failed. No more details.&quot;</b>
        <b class="nc"><i>132</i>&nbsp; notifyConnectionStateChanged(BluetoothState.SCAN_FAILURE)</b>
        <b class="nc"><i>133</i>&nbsp; }</b>
        <b class="nc"><i>134</i>&nbsp; LogUtils.e(TAG, msg)</b>
        <b class="nc"><i>135</i>&nbsp; }</b>
        <i>136</i>&nbsp; }
        <i>137</i>&nbsp;
        <i>138</i>&nbsp; /** Stops the currently bluetooth low energy scanner.
        <i>139</i>&nbsp; * If a lock is currently waiting, the lock is disabled. */
        <i>140</i>&nbsp; override fun stopScan() {
        <b class="fc"><i>141</i>&nbsp; LogUtils.i(TAG, &quot;Stopping Low Energy scan&quot;)</b>
        <b class="fc"><i>142</i>&nbsp; if (isAdapterReady</b>
        <b class="fc"><i>143</i>&nbsp; &amp;&amp; PermissionUtils.hasPermissions(context,
            Manifest.permission.ACCESS_COARSE_LOCATION,
            Manifest.permission.ACCESS_FINE_LOCATION))</b>
        <b class="nc"><i>144</i>&nbsp; bluetoothLeScanner.stopScan(scanCallback)</b>
        <b class="fc"><i>145</i>&nbsp; if (currentState != BluetoothState.DEVICE_FOUND &amp;&amp;
            currentState != BluetoothState.DATA_BT_CONNECTING) currentDevice = null</b>
        <b class="fc"><i>146</i>&nbsp; }</b>
        <i>147</i>&nbsp;
        <i>148</i>&nbsp; /** This method sends a request to the headset to **`START`**
        <i>149</i>&nbsp; * the EEG raw data acquisition process and
        <i>150</i>&nbsp; * enables Bluetooth Low Energy notification to receive the raw data.
        <i>151</i>&nbsp; *
        <i>152</i>&nbsp; * **Note:** calling this method will start the raw EEG data acquisition
        process
        <i>153</i>&nbsp; * on the headset which will **consume battery life**. Please consider
        calling
        <i>154</i>&nbsp; * [.stopStream] when EEG raw data are no longer needed.
        <i>155</i>&nbsp; * If there is already a streaming session in progress, nothing happens and
        true is returned.
        <i>156</i>&nbsp; * @return `true` if request has been sent correctly
        <i>157</i>&nbsp; * `false` on immediate error
        <i>158</i>&nbsp; */
        <i>159</i>&nbsp; @Synchronized
        <i>160</i>&nbsp; override fun startStream(): Boolean {
        <b class="fc"><i>161</i>&nbsp; return switchStream(START)</b>
        <i>162</i>&nbsp; }
        <i>163</i>&nbsp;
        <i>164</i>&nbsp; /** Enable notifications on HeadsetStatus characteristic in order to have
        the saturation and DC Offset values */
        <i>165</i>&nbsp; fun activateDeviceStatusMonitoring(): Boolean {
        <b class="fc"><i>166</i>&nbsp; return if
            (!checkServiceAndCharacteristicValidity(MelomindCharacteristics.SERVICE_MEASUREMENT,
            MelomindCharacteristics.CHARAC_HEADSET_STATUS)) false else
            enableOrDisableNotificationsOnCharacteristic(true,
            gatt!!.getService(MelomindCharacteristics.SERVICE_MEASUREMENT).getCharacteristic(MelomindCharacteristics.CHARAC_HEADSET_STATUS))</b>
        <i>167</i>&nbsp; }
        <i>168</i>&nbsp;
        <i>169</i>&nbsp; /** This method sends a request to the headset to **`STOP`**
        <i>170</i>&nbsp; * the EEG raw data acquisition process, therefore disabling the Bluetooth
        Low Energy notification
        <i>171</i>&nbsp; * and cleaning reference to previously registered listener.
        <i>172</i>&nbsp; *
        <i>173</i>&nbsp; * Calling this method will **preserve battery life** by halting the raw EEG
        <i>174</i>&nbsp; * data acquisition process on the headset.
        <i>175</i>&nbsp; * If there is no streaming session in progress, nothing happens and true is
        returned.
        <i>176</i>&nbsp; * @return true upon correct EEG disability request, false on immediate
        error
        <i>177</i>&nbsp; */
        <i>178</i>&nbsp; override fun stopStream(): Boolean {
        <b class="fc"><i>179</i>&nbsp; return switchStream(STOP)</b>
        <i>180</i>&nbsp; }
        <i>181</i>&nbsp;
        <i>182</i>&nbsp; /** This method sends a request to the headset to **`START`** or **`STOP`**
        <i>183</i>&nbsp; * the EEG raw data acquisition process and
        <i>184</i>&nbsp; * **`ENABLES`** or **`DISABLED`**
        <i>185</i>&nbsp; * Bluetooth Low Energy notification to receive the raw data.
        <i>186</i>&nbsp; * If there is already a streaming session started or stopped, nothing
        happens and true is returned.
        <i>187</i>&nbsp; * @return `true` if request has been sent correctly
        <i>188</i>&nbsp; * `false` on immediate error
        <i>189</i>&nbsp; */
        <i>190</i>&nbsp; private fun switchStream(isStart: Boolean): Boolean {
        <b class="fc"><i>191</i>&nbsp; if (isStreaming == isStart) return true</b>
        <b class="fc"><i>192</i>&nbsp; if
            (!checkServiceAndCharacteristicValidity(MelomindCharacteristics.SERVICE_MEASUREMENT,
            MelomindCharacteristics.CHARAC_MEASUREMENT_EEG)) return false</b>
        <b class="fc"><i>193</i>&nbsp; try {</b>
        <b class="fc"><i>194</i>&nbsp; Thread.sleep(50) //Adding small sleep to &quot;free&quot;
            bluetooth</b>
        <b class="nc"><i>195</i>&nbsp; } catch (e: InterruptedException) {</b>
        <b class="nc"><i>196</i>&nbsp; e.printStackTrace()</b>
        <b class="fc"><i>197</i>&nbsp; }</b>
        <b class="fc"><i>198</i>&nbsp; return enableOrDisableNotificationsOnCharacteristic(isStart,</b>
        <b class="fc"><i>199</i>&nbsp;
            gatt!!.getService(MelomindCharacteristics.SERVICE_MEASUREMENT)</b>
        <b class="fc"><i>200</i>&nbsp;
            .getCharacteristic(MelomindCharacteristics.CHARAC_MEASUREMENT_EEG))</b>
        <i>201</i>&nbsp; }
        <i>202</i>&nbsp;
        <i>203</i>&nbsp; /** Whenever there is a new headset status received, this method is called
        to notify the bluetooth manager about it.
        <i>204</i>&nbsp; * @param payload the new headset status as a raw byte array. This byte
        array has to be parsed afterward.
        <i>205</i>&nbsp; */
        <i>206</i>&nbsp; fun notifyNewHeadsetStatus(payload: ByteArray) {
        <b class="nc"><i>207</i>&nbsp; manager.notifyEvent(RawDeviceMeasure(payload))</b>
        <b class="nc"><i>208</i>&nbsp; }</b>
        <i>209</i>&nbsp;
        <i>210</i>&nbsp; /** Enable or disable notifications on specific characteristic provinding
        this characteristic is &quot;notification ready&quot;.
        <i>211</i>&nbsp; * @param enableNotification enabling if set to true, false otherwise
        <i>212</i>&nbsp; * @param characteristic the characteristic to enable or disable
        notification on.
        <i>213</i>&nbsp; *
        <i>214</i>&nbsp; * This operation is synchronous, meaning the thread running this method is
        blocked until the operation completes.
        <i>215</i>&nbsp; * @return `true` if the notification has been successfully established
        within the 2 seconds of allotted time,
        <i>216</i>&nbsp; * or `false` for any error
        <i>217</i>&nbsp; */
        <i>218</i>&nbsp; @Synchronized
        <i>219</i>&nbsp; fun enableOrDisableNotificationsOnCharacteristic(enableNotification:
        Boolean, characteristic: BluetoothGattCharacteristic): Boolean {
        <b class="fc"><i>220</i>&nbsp; if (!isConnected &amp;&amp; currentState !=
            BluetoothState.SENDIND_QR_CODE) return false</b>
        <b class="fc"><i>221</i>&nbsp; LogUtils.i(TAG, &quot;Now enabling local notification for
            characteristic: &quot; + characteristic.uuid)</b>
        <b class="fc"><i>222</i>&nbsp; if (!gatt!!.setCharacteristicNotification(characteristic,
            enableNotification)) {</b>
        <b class="fc"><i>223</i>&nbsp; LogUtils.e(TAG, &quot;Failed to enable local notification for
            characteristic: &quot; + characteristic.uuid)</b>
        <b class="fc"><i>224</i>&nbsp; return false</b>
        <i>225</i>&nbsp; }
        <b class="fc"><i>226</i>&nbsp; val notificationDescriptor =
            characteristic.getDescriptor(MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID)</b>
        <b class="fc"><i>227</i>&nbsp; if (notificationDescriptor == null) {</b>
        <b class="nc"><i>228</i>&nbsp; LogUtils.e(TAG, String.format(&quot;Error: characteristic
            with &quot; +</b>
        <i>229</i>&nbsp; &quot;UUID &lt;%s&gt; does not have a descriptor (UUID &lt;%s&gt;) to
        enable notification remotely!&quot;,
        <b class="nc"><i>230</i>&nbsp; characteristic.uuid.toString(),
            MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID.toString()))</b>
        <b class="nc"><i>231</i>&nbsp; return false</b>
        <i>232</i>&nbsp; }
        <b class="fc"><i>233</i>&nbsp; LogUtils.i(TAG, &quot;Now enabling remote notification for
            characteristic: &quot; + characteristic.uuid)</b>
        <b class="fc"><i>234</i>&nbsp; if (!notificationDescriptor.setValue(</b>
        <b class="fc"><i>235</i>&nbsp; if (enableNotification)
            BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE</b>
        <b class="fc"><i>236</i>&nbsp; else BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE))
            {</b>
        <b class="nc"><i>237</i>&nbsp; val sb = StringBuilder()</b>
        <b class="nc"><i>238</i>&nbsp; for (value in if (enableNotification)
            BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE else
            BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE) {</b>
        <b class="nc"><i>239</i>&nbsp; sb.append(value.toInt())</b>
        <b class="nc"><i>240</i>&nbsp; sb.append(&#39;;&#39;)</b>
        <i>241</i>&nbsp; }
        <b class="nc"><i>242</i>&nbsp; LogUtils.e(TAG, String.format(&quot;Error: characteristic&#39;s
            notification descriptor with &quot; +</b>
        <i>243</i>&nbsp; &quot;UUID &lt;%s&gt; could not store the ENABLE notification value &lt;%s&gt;.&quot;,
        <b class="nc"><i>244</i>&nbsp;
            MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID.toString(), sb.toString()))</b>
        <b class="nc"><i>245</i>&nbsp; return false</b>
        <i>246</i>&nbsp; }
        <b class="fc"><i>247</i>&nbsp; try {</b>
        <b class="fc"><i>248</i>&nbsp; Thread.sleep(1000)</b>
        <b class="nc"><i>249</i>&nbsp; } catch (e: InterruptedException) {</b>
        <b class="nc"><i>250</i>&nbsp; e.printStackTrace()</b>
        <b class="fc"><i>251</i>&nbsp; }</b>
        <b class="fc"><i>252</i>&nbsp; if (gatt?.writeDescriptor(notificationDescriptor) == false) {</b>
        <b class="nc"><i>253</i>&nbsp; LogUtils.e(TAG, &quot;Error: failed to initiate write
            descriptor operation in order to remotely &quot; +</b>
        <b class="nc"><i>254</i>&nbsp; &quot;enable notification for characteristic: &quot; +
            characteristic.uuid)</b>
        <b class="nc"><i>255</i>&nbsp; return false</b>
        <i>256</i>&nbsp; }
        <b class="fc"><i>257</i>&nbsp; LogUtils.i(TAG, &quot;Successfully initiated write descriptor
            operation in order to remotely &quot; +</b>
        <i>258</i>&nbsp; &quot;enable notification... now waiting for confirmation from headset.&quot;)
        <b class="fc"><i>259</i>&nbsp; val result =
            startWaitingOperation(MbtConfig.getBluetoothA2DpConnectionTimeout())</b>
        <b class="fc"><i>260</i>&nbsp; return (if (result == null || result !is Boolean) false else
            result)</b>
        <i>261</i>&nbsp; }
        <i>262</i>&nbsp;
        <i>263</i>&nbsp; /** This method removes bonding of the device. */
        <i>264</i>&nbsp; fun unpairDevice(device: BluetoothDevice) {
        <b class="nc"><i>265</i>&nbsp; try {</b>
        <b class="nc"><i>266</i>&nbsp; val m = device.javaClass</b>
        <b class="nc"><i>267</i>&nbsp; .getMethod(REMOVE_BOND_METHOD, *null as Array&lt;Class&lt;*&gt;?&gt;)</b>
        <i>268</i>&nbsp; m.invoke(device, null as Array&lt;Any?&gt;?)
        <b class="nc"><i>269</i>&nbsp; } catch (e: Exception) {</b>
        <b class="nc"><i>270</i>&nbsp; Log.e(TAG, e.message)</b>
        <b class="nc"><i>271</i>&nbsp; }</b>
        <b class="nc"><i>272</i>&nbsp; }</b>
        <i>273</i>&nbsp;
        <i>274</i>&nbsp; /** Starts the connect operation in order to connect the [bluetooth
        device][BluetoothDevice] (peripheral)
        <i>275</i>&nbsp; * to the terminal (central).
        <i>276</i>&nbsp; * If the operation starts successfully, a new [gatt][BluetoothGatt]
        instance will be stored.
        <i>277</i>&nbsp; * @param context the context which the connection event takes place in.
        <i>278</i>&nbsp; * @param device the bluetooth device to connect to.
        <i>279</i>&nbsp; * @return true if operation has correctly started, false otherwise.
        <i>280</i>&nbsp; */
        <i>281</i>&nbsp; override fun connect(context: Context, device: BluetoothDevice): Boolean {
        <b class="fc"><i>282</i>&nbsp; LogUtils.i(TAG, &quot; connect in Low Energy &quot; +
            device.name + &quot; address is &quot; + device.address)</b>
        <b class="fc"><i>283</i>&nbsp; BroadcastUtils.registerReceiverIntents(context, receiver,
            BluetoothDevice.ACTION_BOND_STATE_CHANGED)</b>
        <i>284</i>&nbsp;
        <i>285</i>&nbsp; //Using reflexion here because min API is 21 and transport layer is not
        available publicly until API 23
        <b class="fc"><i>286</i>&nbsp; try {</b>
        <b class="fc"><i>287</i>&nbsp; val connectGattMethod = device.javaClass</b>
        <b class="fc"><i>288</i>&nbsp; .getMethod(CONNECT_GATT_METHOD,</b>
        <b class="fc"><i>289</i>&nbsp; Context::class.java, Boolean::class.javaPrimitiveType,
            BluetoothGattCallback::class.java, Int::class.javaPrimitiveType)</b>
        <b class="fc"><i>290</i>&nbsp; val transport = device.javaClass.getDeclaredField(&quot;TRANSPORT_LE&quot;).getInt(null)</b>
        <b class="fc"><i>291</i>&nbsp; gatt = connectGattMethod.invoke(device, context, false,
            mbtGattController, transport) as BluetoothGatt?</b>
        <b class="fc"><i>292</i>&nbsp; return true</b>
        <b class="nc"><i>293</i>&nbsp; } catch (e: Exception) {</b>
        <b class="nc"><i>294</i>&nbsp; val errorMsg = &quot; -&gt; &quot; + e.message</b>
        <b class="nc"><i>295</i>&nbsp; LogUtils.e(TAG, &quot;Failed to find connectGatt method via
            reflexion$errorMsg&quot;)</b>
        <b class="nc"><i>296</i>&nbsp; }</b>
        <b class="nc"><i>297</i>&nbsp; return false</b>
        <i>298</i>&nbsp; }
        <i>299</i>&nbsp;
        <i>300</i>&nbsp; /** Disconnects from the currently connected [gatt instance][BluetoothGatt]
        and sets it to null */
        <i>301</i>&nbsp; override fun disconnect(): Boolean {
        <b class="fc"><i>302</i>&nbsp; LogUtils.i(TAG, &quot;Disconnect in low energy&quot;)</b>
        <b class="fc"><i>303</i>&nbsp; gatt?.disconnect()</b>
        <b class="fc"><i>304</i>&nbsp; gatt = null</b>
        <b class="fc"><i>305</i>&nbsp; return false</b>
        <i>306</i>&nbsp; }
        <i>307</i>&nbsp;
        <i>308</i>&nbsp; override fun isCurrentDeviceNameEqual(deviceName: String): Boolean {
        <b class="nc"><i>309</i>&nbsp; return gatt != null &amp;&amp; gatt!!.device != null &amp;&amp;
            gatt!!.device.name == deviceName</b>
        <i>310</i>&nbsp; }
        <i>311</i>&nbsp;
        <i>312</i>&nbsp; fun getBleDeviceNameFromA2dp(deviceName: String): String? {
        <b class="nc"><i>313</i>&nbsp; return (if
            (MelomindDevice.isDeviceNameValidForMelomind(deviceName))</b>
        <b class="nc"><i>314</i>&nbsp; deviceName.replace(MbtFeatures.A2DP_DEVICE_NAME_PREFIX,
            MbtFeatures.MELOMIND_DEVICE_NAME_PREFIX)</b>
        <i>315</i>&nbsp; else //audio_ prefix is replaced by a melo_ prefix
        <b class="nc"><i>316</i>&nbsp; MelomindsQRDataBase(context, true)[deviceName])</b>
        <i>317</i>&nbsp; }
        <i>318</i>&nbsp;
        <i>319</i>&nbsp; override val isConnected: Boolean
        <b class="fc"><i>320</i>&nbsp; get() = currentState == BluetoothState.CONNECTED_AND_READY ||
            currentState == BluetoothState.CONNECTED</b>
        <i>321</i>&nbsp;
        <i>322</i>&nbsp; /** Starts a read operation on a specific characteristic
        <i>323</i>&nbsp; * @param characteristic the characteristic to read
        <i>324</i>&nbsp; * @return immediatly false on error, true true if read operation has
        started correctly
        <i>325</i>&nbsp; */
        <i>326</i>&nbsp; fun startReadOperation(characteristic: UUID): Boolean {
        <b class="fc"><i>327</i>&nbsp; if (!isConnected &amp;&amp; currentState !=
            BluetoothState.DISCOVERING_SUCCESS &amp;&amp; !currentState.isReadingDeviceInfoState()
            &amp;&amp; currentState != BluetoothState.BONDING) {</b>
        <b class="fc"><i>328</i>&nbsp; notifyConnectionStateChanged(if (currentState ==
            BluetoothState.BONDING) BluetoothState.BONDING_FAILURE else
            BluetoothState.READING_FAILURE)</b>
        <b class="fc"><i>329</i>&nbsp; return false</b>
        <i>330</i>&nbsp; }
        <b class="nc"><i>331</i>&nbsp; val service = if (characteristic ==
            MelomindCharacteristics.CHARAC_INFO_FIRMWARE_VERSION || characteristic ==
            MelomindCharacteristics.CHARAC_INFO_HARDWARE_VERSION || characteristic ==
            MelomindCharacteristics.CHARAC_INFO_SERIAL_NUMBER || characteristic ==
            MelomindCharacteristics.CHARAC_INFO_MODEL_NUMBER)
            MelomindCharacteristics.SERVICE_DEVICE_INFOS else
            MelomindCharacteristics.SERVICE_MEASUREMENT</b>
        <b class="nc"><i>332</i>&nbsp; if (!checkServiceAndCharacteristicValidity(service,
            characteristic)) {</b>
        <b class="nc"><i>333</i>&nbsp; notifyConnectionStateChanged(if (currentState ==
            BluetoothState.BONDING) BluetoothState.BONDING_FAILURE else
            BluetoothState.READING_FAILURE)</b>
        <b class="nc"><i>334</i>&nbsp; return false</b>
        <i>335</i>&nbsp; }
        <b class="nc"><i>336</i>&nbsp; if
            (!gatt!!.readCharacteristic(gatt!!.getService(service).getCharacteristic(characteristic)))
            {</b>
        <b class="nc"><i>337</i>&nbsp; LogUtils.e(TAG, &quot;Error: failed to initiate read
            characteristic operation&quot;)</b>
        <b class="nc"><i>338</i>&nbsp; if (currentState == BluetoothState.BONDING ||
            currentState.isReadingDeviceInfoState()) notifyConnectionStateChanged(if (currentState
            == BluetoothState.BONDING) BluetoothState.BONDING_FAILURE else
            BluetoothState.READING_FAILURE)</b>
        <b class="nc"><i>339</i>&nbsp; return false</b>
        <i>340</i>&nbsp; }
        <i>341</i>&nbsp; //if(getCurrentState().isReadingDeviceInfoState())
        <b class="nc"><i>342</i>&nbsp; LogUtils.i(TAG, &quot;Successfully initiated read
            characteristic operation&quot;)</b>
        <b class="nc"><i>343</i>&nbsp; return true</b>
        <i>344</i>&nbsp; }
        <i>345</i>&nbsp;
        <i>346</i>&nbsp; /** Starts a write operation on a specific characteristic
        <i>347</i>&nbsp; * @param characteristic the characteristic to perform write operation on
        <i>348</i>&nbsp; * @param payload the payload to write to the characteristic
        <i>349</i>&nbsp; * @return immediatly false on error, true otherwise
        <i>350</i>&nbsp; */
        <i>351</i>&nbsp; @Synchronized
        <i>352</i>&nbsp; fun startWriteOperation(service: UUID, characteristic: UUID, payload:
        ByteArray?): Boolean {
        <b class="fc"><i>353</i>&nbsp; if (!checkServiceAndCharacteristicValidity(service,
            characteristic)) {</b>
        <b class="fc"><i>354</i>&nbsp; LogUtils.e(TAG, &quot;Error: failed to check service and
            characteristic validity$characteristic&quot;)</b>
        <b class="fc"><i>355</i>&nbsp; return false</b>
        <i>356</i>&nbsp; }
        <i>357</i>&nbsp;
        <i>358</i>&nbsp; //Send buffer
        <b class="fc"><i>359</i>&nbsp;
            gatt!!.getService(service).getCharacteristic(characteristic).value = payload</b>
        <i>360</i>&nbsp; //Log.d(TAG, &quot;write &quot;+
        Arrays.toString(gatt.getService(service).getCharacteristic(characteristic).getValue()));
        <b class="fc"><i>361</i>&nbsp; if
            (!gatt!!.writeCharacteristic(gatt!!.getService(service).getCharacteristic(characteristic)))
            { //the mbtgattcontroller onCharacteristicWrite callback is invoked, reporting the
            result of the operation.</b>
        <b class="fc"><i>362</i>&nbsp; LogUtils.e(TAG, &quot;Error: failed to write characteristic
            $characteristic&quot;)</b>
        <b class="fc"><i>363</i>&nbsp; return false</b>
        <i>364</i>&nbsp; }
        <b class="fc"><i>365</i>&nbsp; return true</b>
        <i>366</i>&nbsp; }
        <i>367</i>&nbsp;
        <i>368</i>&nbsp; /** Checks whether the service and characteristic about to be used to
        communicate with the remote device.
        <i>369</i>&nbsp; * @param service the service to check
        <i>370</i>&nbsp; * @param characteristic the characteristic to check
        <i>371</i>&nbsp; * @return false if something not valid, true otherwise
        <i>372</i>&nbsp; */
        <i>373</i>&nbsp; fun checkServiceAndCharacteristicValidity(service: UUID, characteristic:
        UUID): Boolean {
        <b class="fc"><i>374</i>&nbsp; return gatt != null &amp;&amp; gatt!!.getService(service) !=
            null &amp;&amp; gatt!!.getService(service).getCharacteristic(characteristic) != null</b>
        <i>375</i>&nbsp; }
        <i>376</i>&nbsp;
        <i>377</i>&nbsp; /** Checks if the charateristic has notifications already enabled or not.
        <i>378</i>&nbsp; * @param service the Service UUID that holds the characteristic
        <i>379</i>&nbsp; * @param characteristic the characteristic UUID.
        <i>380</i>&nbsp; * @return true is already enabled notifications, false otherwise.
        <i>381</i>&nbsp; */
        <i>382</i>&nbsp; fun isNotificationEnabledOnCharacteristic(service: UUID, characteristic:
        UUID): Boolean {
        <b class="fc"><i>383</i>&nbsp; if (!checkServiceAndCharacteristicValidity(service,
            characteristic)) return false</b>
        <b class="fc"><i>384</i>&nbsp; return if
            (gatt!!.getService(service).getCharacteristic(characteristic).getDescriptor(MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID)
            == null) false else
            Arrays.equals(gatt!!.getService(service).getCharacteristic(characteristic).getDescriptor(MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID).value,
            BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE)</b>
        <i>385</i>&nbsp; }
        <i>386</i>&nbsp;
        <i>387</i>&nbsp; /** Initiates a read battery operation on this correct Protocol */
        <i>388</i>&nbsp; override fun readBattery(): Boolean {
        <b class="fc"><i>389</i>&nbsp; LogUtils.i(TAG, &quot;read battery&quot;)</b>
        <b class="fc"><i>390</i>&nbsp; return
            startReadOperation(MelomindCharacteristics.CHARAC_MEASUREMENT_BATTERY_LEVEL)</b>
        <i>391</i>&nbsp; }
        <i>392</i>&nbsp;
        <i>393</i>&nbsp;
        <i>394</i>&nbsp;
        <i>395</i>&nbsp; /** Initiates a read firmware version operation on this correct Protocol */
        <i>396</i>&nbsp; override fun readFwVersion(): Boolean {
        <b class="fc"><i>397</i>&nbsp; LogUtils.i(TAG, &quot;read firmware version&quot;)</b>
        <b class="fc"><i>398</i>&nbsp; return
            startReadOperation(MelomindCharacteristics.CHARAC_INFO_FIRMWARE_VERSION)</b>
        <i>399</i>&nbsp; }
        <i>400</i>&nbsp;
        <i>401</i>&nbsp; /** Initiates a read hardware version operation on this correct Protocol */
        <i>402</i>&nbsp; override fun readHwVersion(): Boolean {
        <b class="fc"><i>403</i>&nbsp; LogUtils.i(TAG, &quot;read hardware version&quot;)</b>
        <b class="fc"><i>404</i>&nbsp; return
            startReadOperation(MelomindCharacteristics.CHARAC_INFO_HARDWARE_VERSION)</b>
        <i>405</i>&nbsp; }
        <i>406</i>&nbsp;
        <i>407</i>&nbsp; /** Initiates a read serial number operation on this correct Protocol */
        <i>408</i>&nbsp; override fun readSerialNumber(): Boolean {
        <b class="fc"><i>409</i>&nbsp; LogUtils.i(TAG, &quot;read serial number requested&quot;)</b>
        <b class="fc"><i>410</i>&nbsp; return
            startReadOperation(MelomindCharacteristics.CHARAC_INFO_SERIAL_NUMBER)</b>
        <i>411</i>&nbsp; }
        <i>412</i>&nbsp;
        <i>413</i>&nbsp; /** Initiates a read model number operation on this correct BtProtocol */
        <i>414</i>&nbsp; override fun readModelNumber(): Boolean {
        <b class="nc"><i>415</i>&nbsp; LogUtils.i(TAG, &quot;read product name&quot;)</b>
        <b class="nc"><i>416</i>&nbsp; return
            startReadOperation(MelomindCharacteristics.CHARAC_INFO_MODEL_NUMBER)</b>
        <i>417</i>&nbsp; }
        <i>418</i>&nbsp;
        <i>419</i>&nbsp; /** Callback called by the [gatt controller][MbtGattController] when the
        notification state has changed.
        <i>420</i>&nbsp; * @param isSuccess if the modification state is correctly changed
        <i>421</i>&nbsp; * @param characteristic the characteristic which had its notification state
        changed
        <i>422</i>&nbsp; * @param wasEnableRequest if the request was to enable (true) or disable
        (false) request.
        <i>423</i>&nbsp; */
        <i>424</i>&nbsp; fun onNotificationStateChanged(isSuccess: Boolean, characteristic:
        BluetoothGattCharacteristic, wasEnableRequest: Boolean) {
        <b class="fc"><i>425</i>&nbsp; if (MelomindCharacteristics.CHARAC_MEASUREMENT_EEG ==
            characteristic.uuid) {</b>
        <b class="nc"><i>426</i>&nbsp; if (wasEnableRequest &amp;&amp; isSuccess) {</b>
        <b class="nc"><i>427</i>&nbsp; notifyStreamStateChanged(StreamState.STARTED)</b>
        <b class="nc"><i>428</i>&nbsp; } else if (!wasEnableRequest &amp;&amp; isSuccess) {</b>
        <b class="nc"><i>429</i>&nbsp; notifyStreamStateChanged(StreamState.STOPPED)</b>
        <i>430</i>&nbsp; } else {
        <b class="nc"><i>431</i>&nbsp; notifyStreamStateChanged(StreamState.FAILED)</b>
        <b class="nc"><i>432</i>&nbsp; }</b>
        <b class="fc"><i>433</i>&nbsp; } else if (MelomindCharacteristics.CHARAC_MEASUREMENT_MAILBOX
            == characteristic.uuid) {</b>
        <i>434</i>&nbsp; //TODO see what&#39;s important here
        <b class="fc"><i>435</i>&nbsp; } else if (MelomindCharacteristics.CHARAC_HEADSET_STATUS ==
            characteristic.uuid) {</b>
        <i>436</i>&nbsp; //TODO see what&#39;s important here
        <b class="fc"><i>437</i>&nbsp; }</b>
        <b class="fc"><i>438</i>&nbsp; }</b>
        <i>439</i>&nbsp;
        <i>440</i>&nbsp; /** Close gatt if the current state is connected &amp; ready or upgrading
        <i>441</i>&nbsp; * @param gatt
        <i>442</i>&nbsp; */
        <i>443</i>&nbsp; fun onStateDisconnected(gatt: BluetoothGatt) {
        <b class="nc"><i>444</i>&nbsp; if (gatt != null &amp;&amp; currentState.ordinal &gt;=
            BluetoothState.CONNECTED_AND_READY.ordinal) gatt.close()</b>
        <b class="nc"><i>445</i>&nbsp;
            notifyConnectionStateChanged(BluetoothState.DATA_BT_DISCONNECTED)</b>
        <b class="nc"><i>446</i>&nbsp; }</b>
        <i>447</i>&nbsp;
        <i>448</i>&nbsp; fun onStateDisconnecting() {
        <b class="nc"><i>449</i>&nbsp;
            notifyConnectionStateChanged(BluetoothState.DISCONNECTING)</b>
        <b class="nc"><i>450</i>&nbsp; }</b>
        <i>451</i>&nbsp;
        <i>452</i>&nbsp; fun onStateConnecting() {
        <b class="nc"><i>453</i>&nbsp; if (currentState == BluetoothState.DEVICE_FOUND)
            this.updateConnectionState(false) //current state is set to DATA_BT_CONNECTING</b>
        <b class="nc"><i>454</i>&nbsp; }</b>
        <i>455</i>&nbsp;
        <i>456</i>&nbsp; fun onStateConnected() {
        <b class="nc"><i>457</i>&nbsp; if (currentState == BluetoothState.DATA_BT_CONNECTING ||
            currentState == BluetoothState.SCAN_STARTED) updateConnectionState(true) //current state
            is set to DATA_BT_CONNECTION_SUCCESS and future is completed</b>
        <b class="nc"><i>458</i>&nbsp; else if (currentState == BluetoothState.IDLE || currentState
            == BluetoothState.UPGRADING)
            this.notifyConnectionStateChanged(BluetoothState.CONNECTED_AND_READY)</b>
        <b class="nc"><i>459</i>&nbsp; }</b>
        <i>460</i>&nbsp;
        <i>461</i>&nbsp; /** Callback triggered by the [MbtGattController] callback when the
        connection state has changed.
        <i>462</i>&nbsp; * @param newState the new [state][BluetoothState]
        <i>463</i>&nbsp; */
        <i>464</i>&nbsp; override fun notifyConnectionStateChanged(newState: BluetoothState) {
        <b class="fc"><i>465</i>&nbsp; super.notifyConnectionStateChanged(newState)</b>
        <b class="fc"><i>466</i>&nbsp; if (newState == BluetoothState.DATA_BT_DISCONNECTED) {</b>
        <b class="fc"><i>467</i>&nbsp; if (isStreaming)
            notifyStreamStateChanged(StreamState.DISCONNECTED)</b>
        <b class="fc"><i>468</i>&nbsp; BroadcastUtils.unregisterReceiver(context, receiver)</b>
        <i>469</i>&nbsp; }
        <b class="fc"><i>470</i>&nbsp; }</b>
        <i>471</i>&nbsp;
        <i>472</i>&nbsp; /** Callback triggered by the [MbtGattController] callback
        <i>473</i>&nbsp; * when an event -not related to a mailbox request sent by the SDK- occurs
        <i>474</i>&nbsp; * @param mailboxEvent the event that occurs
        <i>475</i>&nbsp; * @param eventData the data associated to the mailbox event detected
        <i>476</i>&nbsp; */
        <i>477</i>&nbsp; fun notifyEventReceived(mailboxEvent: DeviceCommandEvent?, eventData:
        ByteArray?) {
        <b class="nc"><i>478</i>&nbsp; manager.notifyEvent(BluetoothResponseEvent(mailboxEvent,
            eventData))</b>
        <b class="nc"><i>479</i>&nbsp; }</b>
        <i>480</i>&nbsp;
        <i>481</i>&nbsp; fun notifyConnectionResponseReceived(mailboxEvent: DeviceCommandEvent,
        mailboxResponse: Byte) {
        <b class="nc"><i>482</i>&nbsp; if
            (!mbtGattController.isConnectionMailboxEvent(mailboxEvent)) {</b>
        <b class="nc"><i>483</i>&nbsp; LogUtils.e(TAG, &quot;Error : received response is not
            related to Bluetooth connection&quot;)</b>
        <b class="nc"><i>484</i>&nbsp; return</b>
        <i>485</i>&nbsp; }
        <b class="nc"><i>486</i>&nbsp; LogUtils.i(TAG, &quot;Received response for &quot; + (if
            (mailboxEvent == MBX_CONNECT_IN_A2DP) &quot;connection&quot; else &quot;disconnection&quot;)
            + &quot; : &quot; + mailboxResponse)</b>
        <b class="nc"><i>487</i>&nbsp; if (mailboxEvent == MBX_CONNECT_IN_A2DP) {</b>
        <b class="nc"><i>488</i>&nbsp; val jackConnectedResponseCode =
            MBX_CONNECT_IN_A2DP.getResponseCodeForKey(CMD_CODE_CONNECT_IN_A2DP_JACK_CONNECTED)</b>
        <b class="nc"><i>489</i>&nbsp; val successResponseCode =
            MBX_CONNECT_IN_A2DP.getResponseCodeForKey(CMD_CODE_CONNECT_IN_A2DP_SUCCESS)</b>
        <b class="nc"><i>490</i>&nbsp; if (jackConnectedResponseCode?.let {
            BitUtils.areByteEquals(it, mailboxResponse) } == true)</b>
        <b class="nc"><i>491</i>&nbsp;
            updateConnectionState(BluetoothState.JACK_CABLE_CONNECTED)</b>
        <b class="nc"><i>492</i>&nbsp; else if (successResponseCode?.let {
            BitUtils.areByteEquals(it, mailboxResponse) } == true)</b>
        <b class="nc"><i>493</i>&nbsp;
            updateConnectionState(BluetoothState.AUDIO_BT_CONNECTION_SUCCESS)</b>
        <b class="nc"><i>494</i>&nbsp; } else
            updateConnectionState(BluetoothState.AUDIO_BT_DISCONNECTED)</b>
        <b class="nc"><i>495</i>&nbsp; }</b>
        <i>496</i>&nbsp;
        <i>497</i>&nbsp; fun updateConnectionState(isCompleted: Boolean) {
        <b class="nc"><i>498</i>&nbsp; manager.connecter.updateConnectionState(isCompleted) //do
            nothing if the current state is CONNECTED_AND_READY</b>
        <b class="nc"><i>499</i>&nbsp; }</b>
        <i>500</i>&nbsp;
        <i>501</i>&nbsp; fun updateConnectionState(newState: BluetoothState?) {
        <b class="nc"><i>502</i>&nbsp; manager.connecter.updateConnectionState(newState) //do
            nothing if the current state is CONNECTED_AND_READY</b>
        <b class="nc"><i>503</i>&nbsp; }</b>
        <i>504</i>&nbsp;
        <i>505</i>&nbsp; /** This method handle a single command in order to
        <i>506</i>&nbsp; * reconfigure some headset or bluetooth streaming parameters
        <i>507</i>&nbsp; * or get values stored by the headset
        <i>508</i>&nbsp; * or ask the headset to perform an action.
        <i>509</i>&nbsp; * The command&#39;s parameters are bundled in a
        [instance][command.CommandInterface.MbtCommand]
        <i>510</i>&nbsp; * that can provide a nullable response callback.
        <i>511</i>&nbsp; * All method inside are blocking.
        <i>512</i>&nbsp; * @param command is the [command.CommandInterface.MbtCommand] object that
        defines the type of command to send
        <i>513</i>&nbsp; * and the associated command parameters.
        <i>514</i>&nbsp; * One of this parameter is an optional callback that returns the response
        <i>515</i>&nbsp; * sent by the headset to the SDK once the command is received.
        <i>516</i>&nbsp; */
        <i>517</i>&nbsp; override fun sendCommand(command: MbtCommand&lt;BaseError&gt;) {
        <b class="fc"><i>518</i>&nbsp; var response: Any? = null</b>
        <b class="fc"><i>519</i>&nbsp; if (!isConnectedDeviceReadyForCommand) { //error returned if
            no headset is connected</b>
        <b class="fc"><i>520</i>&nbsp; LogUtils.e(TAG, &quot;Command not sent : $command&quot;)</b>
        <b class="fc"><i>521</i>&nbsp; command.onError(BluetoothError.ERROR_NOT_CONNECTED, null)</b>
        <i>522</i>&nbsp; } else { //any command is not sent if no device is connected
        <b class="fc"><i>523</i>&nbsp; if (command.isValid) { //any invalid command is not sent :
            validity criteria are defined in each Bluetooth implemented class , the onError callback
            is triggered in the constructor of the command object</b>
        <b class="fc"><i>524</i>&nbsp; LogUtils.d(TAG, &quot;Valid command : $command&quot;)</b>
        <b class="fc"><i>525</i>&nbsp; val requestSent = sendRequestData(command)</b>
        <b class="fc"><i>526</i>&nbsp; if (!requestSent) {</b>
        <b class="fc"><i>527</i>&nbsp; LogUtils.e(TAG, &quot;Command sending failed&quot;)</b>
        <b class="fc"><i>528</i>&nbsp; command.onError(BluetoothError.ERROR_REQUEST_OPERATION, null)</b>
        <i>529</i>&nbsp; } else {
        <b class="fc"><i>530</i>&nbsp; command.onRequestSent()</b>
        <b class="fc"><i>531</i>&nbsp; if (command.isResponseExpected) {</b>
        <b class="fc"><i>532</i>&nbsp; response = startWaitingOperation(11000)</b>
        <b class="fc"><i>533</i>&nbsp; command.onResponseReceived(response)</b>
        <i>534</i>&nbsp; }
        <b class="fc"><i>535</i>&nbsp; }</b>
        <b class="fc"><i>536</i>&nbsp; } else LogUtils.w(TAG, &quot;Command not sent : $command&quot;)</b>
        <b class="fc"><i>537</i>&nbsp; }</b>
        <b class="fc"><i>538</i>&nbsp; manager.reader.notifyResponseReceived(response, command)
            //return null response to the client if request has not been sent</b>
        <b class="fc"><i>539</i>&nbsp; }</b>
        <i>540</i>&nbsp;
        <i>541</i>&nbsp; fun sendRequestData(command: MbtCommand&lt;*&gt;): Boolean {
        <b class="fc"><i>542</i>&nbsp; if (command is Mtu)</b>
        <b class="fc"><i>543</i>&nbsp; return changeMTU(command.serialize())</b>
        <i>544</i>&nbsp;
        <b class="fc"><i>545</i>&nbsp; if (command is DeviceCommand&lt;*, *&gt;)</b>
        <b class="fc"><i>546</i>&nbsp; return writeCharacteristic((command.serialize() as
            ByteArray),</b>
        <b class="fc"><i>547</i>&nbsp; MelomindCharacteristics.SERVICE_MEASUREMENT,</b>
        <b class="fc"><i>548</i>&nbsp; if (command is TransferPacket)
            MelomindCharacteristics.CHARAC_MEASUREMENT_OAD_PACKETS_TRANSFER</b>
        <b class="fc"><i>549</i>&nbsp; else MelomindCharacteristics.CHARAC_MEASUREMENT_MAILBOX,</b>
        <b class="fc"><i>550</i>&nbsp; command !is TransferPacket)</b>
        <b class="fc"><i>551</i>&nbsp; return false</b>
        <i>552</i>&nbsp; }
        <i>553</i>&nbsp;
        <i>554</i>&nbsp; /** Initiates a change MTU request in order to have bigger (or smaller)
        bluetooth notifications.
        <i>555</i>&nbsp; * The default size is also the minimum size : 23
        <i>556</i>&nbsp; * The maximum size is set to 121.
        <i>557</i>&nbsp; * This method is synchronous and blocks the calling thread until operation
        is complete.
        <i>558</i>&nbsp; * See [BluetoothGatt.requestMtu] for more info.
        <i>559</i>&nbsp; * @param newMTU the new MTU value.
        <i>560</i>&nbsp; * @return false if request dod not start as planned, true otherwise.
        <i>561</i>&nbsp; */
        <i>562</i>&nbsp; fun changeMTU(newMTU: Int): Boolean {
        <b class="fc"><i>563</i>&nbsp; LogUtils.i(TAG, &quot;change mtu $newMTU&quot;)</b>
        <b class="fc"><i>564</i>&nbsp; return if (gatt == null) false else gatt!!.requestMtu(newMTU)</b>
        <i>565</i>&nbsp; }
        <i>566</i>&nbsp;
        <i>567</i>&nbsp; fun writeCharacteristic(buffer: ByteArray, service: UUID, characteristic:
        UUID, enableNotification: Boolean): Boolean {
        <i>568</i>&nbsp; //Log.d(TAG, &quot;write characteristic &quot;+characteristic+ &quot; for
        service &quot;+service);
        <b class="fc"><i>569</i>&nbsp; if (buffer.isEmpty()) return false</b>
        <b class="fc"><i>570</i>&nbsp; if (!isNotificationEnabledOnCharacteristic(service,
            characteristic) &amp;&amp; enableNotification) {</b>
        <b class="nc"><i>571</i>&nbsp; enableOrDisableNotificationsOnCharacteristic(true,
            gatt!!.getService(service).getCharacteristic(characteristic))</b>
        <i>572</i>&nbsp; }
        <b class="fc"><i>573</i>&nbsp; if (!startWriteOperation(service, characteristic, buffer)) {</b>
        <b class="nc"><i>574</i>&nbsp; LogUtils.e(TAG, &quot;Failed to send the command the the
            headset&quot;)</b>
        <b class="nc"><i>575</i>&nbsp; return false</b>
        <i>576</i>&nbsp; }
        <b class="fc"><i>577</i>&nbsp; return true</b>
        <i>578</i>&nbsp; }
        <i>579</i>&nbsp;
        <i>580</i>&nbsp; /** Once a device is connected in Bluetooth Low Energy / SPP for data
        streaming, we consider that the Bluetooth connection process is not fully completed.
        <i>581</i>&nbsp; * The services offered by a remote device as well as their characteristics
        and descriptors are discovered to ensure that Data Streaming can be performed.
        <i>582</i>&nbsp; * It means that the Bluetooth Manager retrieve all the services, which can
        be seen as categories of data that the headset is transmitting
        <i>583</i>&nbsp; * This is an asynchronous operation.
        <i>584</i>&nbsp; * Once service discovery is completed, the
        BluetoothGattCallback.onServicesDiscovered callback is triggered.
        <i>585</i>&nbsp; * If the discovery was successful, the remote services can be retrieved
        using the getServices function */
        <i>586</i>&nbsp; fun discoverServices() {
        <b class="nc"><i>587</i>&nbsp; LogUtils.i(TAG, &quot;start discover services&quot;)</b>
        <b class="nc"><i>588</i>&nbsp; updateConnectionState(false) //current state is set to
            DISCOVERING_SERVICES</b>
        <b class="nc"><i>589</i>&nbsp; if (!gatt!!.discoverServices()) {</b>
        <b class="nc"><i>590</i>&nbsp;
            notifyConnectionStateChanged(BluetoothState.DISCOVERING_FAILURE)</b>
        <b class="nc"><i>591</i>&nbsp; LogUtils.i(TAG, &quot; discover services failed&quot;)</b>
        <i>592</i>&nbsp; }
        <b class="nc"><i>593</i>&nbsp; }</b>
        <i>594</i>&nbsp;
        <i>595</i>&nbsp; /** Starts a read operation of the Battery charge level to trigger an
        automatic bonding.
        <i>596</i>&nbsp; * If the headset is already bonded, it will return the value of the battery
        level.
        <i>597</i>&nbsp; * If the headset is not already bonded, it will bond and return an
        authentication failed status code (0x89 GATT_AUTH_FAIL)
        <i>598</i>&nbsp; * in the [MbtGattController.onCharacteristicRead]onCharacteristicRead
        callback */
        <i>599</i>&nbsp; fun bond() {
        <b class="nc"><i>600</i>&nbsp; LogUtils.i(TAG, &quot;start bonding&quot;)</b>
        <b class="nc"><i>601</i>&nbsp; val isBondRetry = currentState == BluetoothState.BONDING</b>
        <b class="nc"><i>602</i>&nbsp; if (isBondRetry &amp;&amp; Build.VERSION.SDK_INT &gt;=
            Build.VERSION_CODES.O) {</b>
        <b class="nc"><i>603</i>&nbsp; LogUtils.d(TAG, &quot;Retry not necessary : Android will
            retry the read operation itself after bonding has completed&quot;) //However, on Android
            6 &amp; 7 you will have to retry the operation yourself</b>
        <b class="nc"><i>604</i>&nbsp; return</b>
        <i>605</i>&nbsp; }
        <b class="nc"><i>606</i>&nbsp; if (currentState == BluetoothState.READING_SUCCESS)
            updateConnectionState(false) //current state is set to BONDING</b>
        <b class="nc"><i>607</i>&nbsp; manager.reader.startReadOperation(DeviceInfo.BATTERY)
            //trigger bonding indirectly</b>
        <b class="nc"><i>608</i>&nbsp; }</b>
        <i>609</i>&nbsp;
        <i>610</i>&nbsp; override fun notifyDeviceInfoReceived(deviceInfo: DeviceInfo, deviceValue:
        String) { // This method will be called when a DeviceInfoReceived is posted (fw or hw or
        serial number) by MbtBluetoothLE or MbtBluetoothSPP
        <b class="nc"><i>611</i>&nbsp; super.notifyDeviceInfoReceived(deviceInfo, deviceValue)</b>
        <b class="nc"><i>612</i>&nbsp; if (currentState.isReadingDeviceInfoState())
            updateConnectionState(true) //current state is set to READING_FIRMWARE_VERSION_SUCCESS
            or READING_HARDWARE_VERSION_SUCCESS or READING_SERIAL_NUMBER_SUCCESS or READING_SUCCESS
            if reading device info and future is completed</b>
        <b class="nc"><i>613</i>&nbsp; }</b>
        <i>614</i>&nbsp;
        <i>615</i>&nbsp; public override fun notifyBatteryReceived(value: Int) {
        <b class="nc"><i>616</i>&nbsp; if (currentState == BluetoothState.BONDING)
            updateConnectionState(true) //current state is set to BONDED</b>
        <b class="nc"><i>617</i>&nbsp; if (value != -1) super.notifyBatteryReceived(value)</b>
        <b class="nc"><i>618</i>&nbsp; }</b>
        <i>619</i>&nbsp;
        <i>620</i>&nbsp;}
    </div>
</div>

<div class="footer">

    <div style="float:right;">generated on 2020-06-10 10:26</div>
</div>
</body>
</html>
