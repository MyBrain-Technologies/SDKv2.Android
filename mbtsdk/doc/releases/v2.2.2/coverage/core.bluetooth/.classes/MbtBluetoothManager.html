


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: MbtBluetoothManager</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">core.bluetooth</a> ]
</div>

<h1>Coverage Summary for Class: MbtBluetoothManager (core.bluetooth)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MbtBluetoothManager</td>
<td class="coverageStat">
  <span class="percent">
    47.6%
  </span>
  <span class="absValue">
    (30/ 63)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    29.2%
  </span>
  <span class="absValue">
    (118/ 404)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MbtBluetoothManager$1</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$10$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$11</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$12</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$14</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$15</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$16</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$8$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$9$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothManager$RequestThread</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25.9%
  </span>
  <span class="absValue">
    (21/ 81)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    36.4%
  </span>
  <span class="absValue">
    (39/ 107)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26%
  </span>
  <span class="absValue">
    (150/ 578)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;package core.bluetooth;
<i>2</i>&nbsp;
<i>3</i>&nbsp;import android.Manifest;
<i>4</i>&nbsp;import android.bluetooth.BluetoothAdapter;
<i>5</i>&nbsp;import android.bluetooth.BluetoothDevice;
<i>6</i>&nbsp;import android.content.Context;
<i>7</i>&nbsp;import android.content.Intent;
<i>8</i>&nbsp;import android.content.pm.PackageManager;
<i>9</i>&nbsp;import android.location.LocationManager;
<i>10</i>&nbsp;import android.os.Build;
<i>11</i>&nbsp;import android.os.Handler;
<i>12</i>&nbsp;import android.os.HandlerThread;
<i>13</i>&nbsp;import android.support.annotation.NonNull;
<i>14</i>&nbsp;import android.support.annotation.VisibleForTesting;
<i>15</i>&nbsp;import android.support.v4.content.ContextCompat;
<i>16</i>&nbsp;import android.util.Log;
<i>17</i>&nbsp;
<i>18</i>&nbsp;import org.apache.commons.lang.ArrayUtils;
<i>19</i>&nbsp;import org.greenrobot.eventbus.Subscribe;
<i>20</i>&nbsp;import org.greenrobot.eventbus.ThreadMode;
<i>21</i>&nbsp;
<i>22</i>&nbsp;
<i>23</i>&nbsp;import java.util.LinkedList;
<i>24</i>&nbsp;import java.util.Queue;
<i>25</i>&nbsp;import java.util.concurrent.CancellationException;
<i>26</i>&nbsp;import java.util.concurrent.ExecutionException;
<i>27</i>&nbsp;import java.util.concurrent.TimeoutException;
<i>28</i>&nbsp;
<i>29</i>&nbsp;import command.BluetoothCommand;
<i>30</i>&nbsp;import command.BluetoothCommands;
<i>31</i>&nbsp;import command.CommandInterface;
<i>32</i>&nbsp;import command.DeviceCommand;
<i>33</i>&nbsp;
<i>34</i>&nbsp;
<i>35</i>&nbsp;import command.DeviceCommandEvent;
<i>36</i>&nbsp;import command.OADCommands;
<i>37</i>&nbsp;import config.MbtConfig;
<i>38</i>&nbsp;import core.BaseModuleManager;
<i>39</i>&nbsp;import command.DeviceCommands;
<i>40</i>&nbsp;import command.DeviceStreamingCommands;
<i>41</i>&nbsp;import core.bluetooth.lowenergy.MbtBluetoothLE;
<i>42</i>&nbsp;import core.bluetooth.requests.BluetoothRequests;
<i>43</i>&nbsp;import eventbus.events.BluetoothResponseEvent;
<i>44</i>&nbsp;import core.bluetooth.requests.CommandRequestEvent;
<i>45</i>&nbsp;import core.bluetooth.requests.DisconnectRequestEvent;
<i>46</i>&nbsp;import core.bluetooth.requests.ReadRequestEvent;
<i>47</i>&nbsp;import core.bluetooth.requests.StartOrContinueConnectionRequestEvent;
<i>48</i>&nbsp;import core.bluetooth.requests.StreamRequestEvent;
<i>49</i>&nbsp;import core.bluetooth.spp.MbtBluetoothSPP;
<i>50</i>&nbsp;import core.device.DeviceEvents;
<i>51</i>&nbsp;import core.device.model.DeviceInfo;
<i>52</i>&nbsp;import core.device.model.MbtDevice;
<i>53</i>&nbsp;import core.device.model.MelomindsQRDataBase;
<i>54</i>&nbsp;import engine.SimpleRequestCallback;
<i>55</i>&nbsp;import engine.clientevents.BaseError;
<i>56</i>&nbsp;import engine.clientevents.ConnectionStateReceiver;
<i>57</i>&nbsp;import eventbus.MbtEventBus;
<i>58</i>&nbsp;import eventbus.events.BluetoothEEGEvent;
<i>59</i>&nbsp;import eventbus.events.EEGConfigEvent;
<i>60</i>&nbsp;import eventbus.events.ConnectionStateEvent;
<i>61</i>&nbsp;import eventbus.events.DeviceInfoEvent;
<i>62</i>&nbsp;import eventbus.events.ResetBluetoothEvent;
<i>63</i>&nbsp;import features.MbtDeviceType;
<i>64</i>&nbsp;import features.MbtFeatures;
<i>65</i>&nbsp;import utils.AsyncUtils;
<i>66</i>&nbsp;import utils.BroadcastUtils;
<i>67</i>&nbsp;import utils.VersionHelper;
<i>68</i>&nbsp;import utils.LogUtils;
<i>69</i>&nbsp;import utils.MbtAsyncWaitOperation;
<i>70</i>&nbsp;
<i>71</i>&nbsp;import static core.bluetooth.BtProtocol.BLUETOOTH_A2DP;
<i>72</i>&nbsp;import static core.bluetooth.spp.MbtBluetoothSPP.SERIAL_NUMBER_NB_BYTES;
<i>73</i>&nbsp;import static core.bluetooth.spp.MbtBluetoothSPP.VERSION_NB_BYTES;
<i>74</i>&nbsp;import static utils.MbtAsyncWaitOperation.CANCEL;
<i>75</i>&nbsp;
<i>76</i>&nbsp;/**
<i>77</i>&nbsp; * Created by Etienne on 08/02/2018.
<i>78</i>&nbsp; *
<i>79</i>&nbsp; * This class contains all necessary methods to manage the Bluetooth communication with the myBrain peripheral devices.
<i>80</i>&nbsp; *- 3 Bluetooth layers are used :
<i>81</i>&nbsp; *  - Bluetooth Low Energy protocol is used with Melomind Headset for communication.
<i>82</i>&nbsp; *  - Bluetooth SPP protocol which is used for the VPro headset communication.
<i>83</i>&nbsp; *  - Bluetooth A2DP is used for Audio stream.
<i>84</i>&nbsp; *
<i>85</i>&nbsp; * We scan first with the Low Energy Scanner as it is more efficient than the classical Bluetooth discovery scanner.
<i>86</i>&nbsp; */
<i>87</i>&nbsp;
<b class="fc"><i>88</i>&nbsp;public final class MbtBluetoothManager extends BaseModuleManager{</b>
<b class="fc"><i>89</i>&nbsp;    private final static String TAG = MbtBluetoothManager.class.getSimpleName();</b>
<i>90</i>&nbsp;
<i>91</i>&nbsp;    private MbtDataBluetooth bluetoothForDataStreaming;
<i>92</i>&nbsp;    private MbtAudioBluetooth bluetoothForAudioStreaming;
<i>93</i>&nbsp;
<i>94</i>&nbsp;    @NonNull
<i>95</i>&nbsp;    private final Queue&lt;BluetoothRequests&gt; pendingRequests; //TODO see if still necessary
<b class="fc"><i>96</i>&nbsp;    private boolean requestBeingProcessed = false;</b>
<i>97</i>&nbsp;
<i>98</i>&nbsp;    private RequestThread requestThread;
<i>99</i>&nbsp;    /**
<i>100</i>&nbsp;     * Handler object enqueues an action to be performed on a different thread than the main thread
<i>101</i>&nbsp;     */
<i>102</i>&nbsp;    private Handler requestHandler;
<i>103</i>&nbsp;
<b class="fc"><i>104</i>&nbsp;    private boolean isConnectionInterrupted = false;</b>
<b class="fc"><i>105</i>&nbsp;    private boolean isRequestCompleted = false;</b>
<i>106</i>&nbsp;
<b class="fc"><i>107</i>&nbsp;    private MbtAsyncWaitOperation asyncOperation = new MbtAsyncWaitOperation&lt;Boolean&gt;();</b>
<b class="fc"><i>108</i>&nbsp;    private MbtAsyncWaitOperation asyncSwitchOperation = new MbtAsyncWaitOperation&lt;Boolean&gt;();</b>
<i>109</i>&nbsp;
<i>110</i>&nbsp;    private boolean connectAudioIfDeviceCompatible;
<i>111</i>&nbsp;    private int mtu;
<i>112</i>&nbsp;    private String deviceNameRequested;
<i>113</i>&nbsp;    private String deviceQrCodeRequested;
<b class="fc"><i>114</i>&nbsp;    private MbtDeviceType deviceTypeRequested = MbtDeviceType.MELOMIND;</b>
<i>115</i>&nbsp;
<i>116</i>&nbsp;    //private MbtDeviceAcquisition deviceAcquisition;
<i>117</i>&nbsp;
<b class="fc"><i>118</i>&nbsp;    private int connectionRetryCounter = 0;</b>
<b class="fc"><i>119</i>&nbsp;    private final int MAX_CONNECTION_RETRY = 2;</b>
<i>120</i>&nbsp;
<b class="fc"><i>121</i>&nbsp;    private ConnectionStateReceiver receiver = new ConnectionStateReceiver() {</b>
<i>122</i>&nbsp;        @Override
<i>123</i>&nbsp;        public void onError(BaseError error, String additionalInfo) {
<b class="nc"><i>124</i>&nbsp;        }</b>
<i>125</i>&nbsp;
<i>126</i>&nbsp;        @Override
<i>127</i>&nbsp;        public void onReceive(Context context, Intent intent) {
<b class="nc"><i>128</i>&nbsp;            String action = intent.getAction();</b>
<b class="nc"><i>129</i>&nbsp;            if(action != null){</b>
<b class="nc"><i>130</i>&nbsp;                final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</b>
<b class="nc"><i>131</i>&nbsp;                Log.d(TAG, &quot; received intent &quot; + action + &quot; for device &quot; + (device != null ? device.getName() : null));</b>
<b class="nc"><i>132</i>&nbsp;                if(connectAudioIfDeviceCompatible &amp;&amp; action.equals(BluetoothAdapter.ACTION_STATE_CHANGED))</b>
<b class="nc"><i>133</i>&nbsp;                    ((MbtBluetoothA2DP)bluetoothForAudioStreaming).resetA2dpProxy(intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1));</b>
<i>134</i>&nbsp;            }
<b class="nc"><i>135</i>&nbsp;        }</b>
<i>136</i>&nbsp;    };
<i>137</i>&nbsp;
<i>138</i>&nbsp;    /**
<i>139</i>&nbsp;     * Constructor of the manager.
<i>140</i>&nbsp;     * @param context the application context
<i>141</i>&nbsp;     */
<i>142</i>&nbsp;    public MbtBluetoothManager(@NonNull Context context){
<b class="fc"><i>143</i>&nbsp;        super(context);</b>
<i>144</i>&nbsp;        //save client side objects in variables
<i>145</i>&nbsp;
<b class="fc"><i>146</i>&nbsp;        this.pendingRequests = new LinkedList&lt;&gt;();</b>
<i>147</i>&nbsp;
<i>148</i>&nbsp;        //Init thread that will handle messages synchronously. Using HandlerThread looks like it is the best way for CPU consomption as infinite loop in async thread was too heavy for cpu
<b class="fc"><i>149</i>&nbsp;        requestThread = new RequestThread(&quot;requestThread&quot;, Thread.MAX_PRIORITY);</b>
<b class="fc"><i>150</i>&nbsp;        requestThread.start();</b>
<b class="fc"><i>151</i>&nbsp;        requestHandler = new Handler(requestThread.getLooper());</b>
<i>152</i>&nbsp;
<b class="fc"><i>153</i>&nbsp;        BroadcastUtils.registerReceiverIntents(context, receiver, BluetoothAdapter.ACTION_STATE_CHANGED);</b>
<b class="fc"><i>154</i>&nbsp;    }</b>
<i>155</i>&nbsp;
<i>156</i>&nbsp;    /**
<i>157</i>&nbsp;     * Notify the DeviceManager and the EEGManager that the headset returned its stored configuration
<i>158</i>&nbsp;     */
<i>159</i>&nbsp;    private void notifyDeviceConfigReceived(Byte[] returnedConfig) {
<i>160</i>&nbsp;
<b class="nc"><i>161</i>&nbsp;        requestCurrentConnectedDevice(new SimpleRequestCallback&lt;MbtDevice&gt;() {</b>
<i>162</i>&nbsp;            @Override
<i>163</i>&nbsp;            public void onRequestComplete(MbtDevice device) {
<b class="nc"><i>164</i>&nbsp;                MbtEventBus.postEvent(new EEGConfigEvent(device, returnedConfig));</b>
<i>165</i>&nbsp;            }
<i>166</i>&nbsp;        });
<i>167</i>&nbsp;
<b class="nc"><i>168</i>&nbsp;    }</b>
<i>169</i>&nbsp;
<i>170</i>&nbsp;    /**
<i>171</i>&nbsp;     * Notify a command response has been received from the headset
<i>172</i>&nbsp;     * @param command is the corresponding type of command
<i>173</i>&nbsp;     */
<i>174</i>&nbsp;    public void notifyResponseReceived(Object response, CommandInterface.MbtCommand command) {
<b class="fc"><i>175</i>&nbsp;        LogUtils.d(TAG, &quot;Received response from device : &quot;+ response);</b>
<i>176</i>&nbsp;
<b class="fc"><i>177</i>&nbsp;        if(command instanceof DeviceCommand)</b>
<b class="fc"><i>178</i>&nbsp;            notifyDeviceResponseReceived(response, (DeviceCommand) command);</b>
<i>179</i>&nbsp;
<b class="fc"><i>180</i>&nbsp;        else if (command instanceof BluetoothCommand)</b>
<b class="fc"><i>181</i>&nbsp;            onBluetoothResponseReceived(response, (BluetoothCommand) command);</b>
<i>182</i>&nbsp;
<b class="fc"><i>183</i>&nbsp;        setRequestAsProcessed();</b>
<b class="fc"><i>184</i>&nbsp;    }</b>
<i>185</i>&nbsp;
<i>186</i>&nbsp;    private void notifyDeviceResponseReceived(Object response, DeviceCommand command) {
<b class="fc"><i>187</i>&nbsp;        if(response != null){</b>
<b class="fc"><i>188</i>&nbsp;            if(command instanceof DeviceStreamingCommands.EegConfig){</b>
<b class="nc"><i>189</i>&nbsp;                notifyDeviceConfigReceived(ArrayUtils.toObject((byte[])response));</b>
<i>190</i>&nbsp;
<b class="fc"><i>191</i>&nbsp;            }else if(command instanceof DeviceCommands.UpdateSerialNumber) {</b>
<b class="nc"><i>192</i>&nbsp;                notifyDeviceInfoReceived(DeviceInfo.SERIAL_NUMBER, new String((byte[]) response));</b>
<i>193</i>&nbsp;
<b class="fc"><i>194</i>&nbsp;            }else if(command instanceof DeviceCommands.GetDeviceInfo) {</b>
<b class="nc"><i>195</i>&nbsp;                notifyDeviceInfoReceived(DeviceInfo.FW_VERSION, new String(ArrayUtils.subarray((byte[])response, 0, VERSION_NB_BYTES)));</b>
<b class="nc"><i>196</i>&nbsp;                notifyDeviceInfoReceived(DeviceInfo.HW_VERSION, new String(ArrayUtils.subarray((byte[])response, VERSION_NB_BYTES, VERSION_NB_BYTES+VERSION_NB_BYTES)));</b>
<b class="nc"><i>197</i>&nbsp;                notifyDeviceInfoReceived(DeviceInfo.SERIAL_NUMBER, new String(ArrayUtils.subarray((byte[])response, VERSION_NB_BYTES+VERSION_NB_BYTES, VERSION_NB_BYTES+VERSION_NB_BYTES+SERIAL_NUMBER_NB_BYTES)));</b>
<i>198</i>&nbsp;
<b class="fc"><i>199</i>&nbsp;            }else if(command instanceof DeviceCommands.UpdateExternalName) {</b>
<b class="nc"><i>200</i>&nbsp;                notifyDeviceInfoReceived(DeviceInfo.MODEL_NUMBER, new String((byte[]) response));</b>
<i>201</i>&nbsp;
<b class="fc"><i>202</i>&nbsp;            }else if(command instanceof DeviceCommands.GetBattery) {</b>
<b class="nc"><i>203</i>&nbsp;                notifyDeviceInfoReceived(DeviceInfo.BATTERY, Integer.toString((Integer) response));</b>
<i>204</i>&nbsp;
<b class="fc"><i>205</i>&nbsp;            }else if(command instanceof OADCommands) {</b>
<b class="nc"><i>206</i>&nbsp;                updateConnectionState(BtState.UPGRADING);</b>
<b class="nc"><i>207</i>&nbsp;                if(bluetoothForAudioStreaming != null)</b>
<b class="nc"><i>208</i>&nbsp;                    bluetoothForAudioStreaming.setCurrentState(BtState.UPGRADING);</b>
<b class="nc"><i>209</i>&nbsp;                notifyEventReceived(command.getIdentifier(), response);</b>
<i>210</i>&nbsp;            }
<i>211</i>&nbsp;        }
<b class="fc"><i>212</i>&nbsp;    }</b>
<i>213</i>&nbsp;
<i>214</i>&nbsp;    /**
<i>215</i>&nbsp;     * Notify the Connection process handler if the MTU has been well changed
<i>216</i>&nbsp;     * @param command is the corresponding type of bluetooth command
<i>217</i>&nbsp;     */
<i>218</i>&nbsp;    private void onBluetoothResponseReceived(Object response, BluetoothCommand command) {
<b class="fc"><i>219</i>&nbsp;        if(command instanceof BluetoothCommands.Mtu)</b>
<b class="fc"><i>220</i>&nbsp;            onMtuChanged(response == command.getData());</b>
<b class="fc"><i>221</i>&nbsp;    }</b>
<i>222</i>&nbsp;
<i>223</i>&nbsp;    /**
<i>224</i>&nbsp;     * This class is a specific thread that will handle all bluetooth operations. Bluetooth operations
<i>225</i>&nbsp;     * are synchronous, meaning two or more operations can&#39;t be run simultaneously. This {@link HandlerThread}
<i>226</i>&nbsp;     * extended class is able to hold pending operations.
<i>227</i>&nbsp;     */
<i>228</i>&nbsp;    class RequestThread extends HandlerThread {
<i>229</i>&nbsp;
<b class="nc"><i>230</i>&nbsp;        RequestThread(String name) {</b>
<b class="nc"><i>231</i>&nbsp;            super(name);</b>
<b class="nc"><i>232</i>&nbsp;        }</b>
<i>233</i>&nbsp;
<b class="fc"><i>234</i>&nbsp;        RequestThread(String name, int priority) {</b>
<b class="fc"><i>235</i>&nbsp;            super(name, priority);</b>
<b class="fc"><i>236</i>&nbsp;        }</b>
<i>237</i>&nbsp;
<i>238</i>&nbsp;        @Override
<i>239</i>&nbsp;        protected void onLooperPrepared() {
<b class="nc"><i>240</i>&nbsp;            super.onLooperPrepared();</b>
<b class="nc"><i>241</i>&nbsp;        }</b>
<i>242</i>&nbsp;
<i>243</i>&nbsp;        /**
<i>244</i>&nbsp;         * Checks the subclass type of {@link BluetoothRequests} and handles the correct method/action to perform.
<i>245</i>&nbsp;         *
<i>246</i>&nbsp;         * @param request the {@link BluetoothRequests} request to execute.
<i>247</i>&nbsp;         */
<i>248</i>&nbsp;        void parseRequest(BluetoothRequests request) {
<i>249</i>&nbsp;
<i>250</i>&nbsp;            //BluetoothRequests request = pendingRequests.remove();
<i>251</i>&nbsp;            //disconnect request doesn&#39;t need to be in &quot;queue&quot; as it is top priority
<b class="fc"><i>252</i>&nbsp;            Log.d(TAG, &quot;Parse request &quot;+request.toString());</b>
<i>253</i>&nbsp;
<b class="fc"><i>254</i>&nbsp;            while (requestBeingProcessed);</b>
<b class="fc"><i>255</i>&nbsp;            setRequestAsProcessing();</b>
<b class="fc"><i>256</i>&nbsp;            if (request instanceof StartOrContinueConnectionRequestEvent) {</b>
<i>257</i>&nbsp;
<b class="nc"><i>258</i>&nbsp;                initBluetoothParameters((StartOrContinueConnectionRequestEvent)request);</b>
<b class="nc"><i>259</i>&nbsp;                startOrContinueConnectionOperation(((StartOrContinueConnectionRequestEvent) request).isClientUserRequest());</b>
<i>260</i>&nbsp;
<b class="fc"><i>261</i>&nbsp;            } else if (request instanceof ReadRequestEvent) {</b>
<b class="fc"><i>262</i>&nbsp;                startReadOperation(((ReadRequestEvent) request).getDeviceInfo());</b>
<i>263</i>&nbsp;
<b class="fc"><i>264</i>&nbsp;            } else if (request instanceof DisconnectRequestEvent) {</b>
<b class="fc"><i>265</i>&nbsp;                if (((DisconnectRequestEvent) request).isInterrupted())</b>
<b class="fc"><i>266</i>&nbsp;                    cancelPendingConnection(((DisconnectRequestEvent) request).isInterrupted());</b>
<i>267</i>&nbsp;                else
<b class="fc"><i>268</i>&nbsp;                    disconnectAllBluetooth(true);</b>
<i>269</i>&nbsp;
<b class="fc"><i>270</i>&nbsp;            } else if (request instanceof StreamRequestEvent) {</b>
<b class="fc"><i>271</i>&nbsp;                if (((StreamRequestEvent) request).isStart()) {</b>
<b class="fc"><i>272</i>&nbsp;                    startStreamOperation(((StreamRequestEvent) request).monitorDeviceStatus());</b>
<b class="fc"><i>273</i>&nbsp;                }else if(((StreamRequestEvent) request).stopStream())</b>
<b class="nc"><i>274</i>&nbsp;                    stopStreamOperation();</b>
<i>275</i>&nbsp;                else
<b class="fc"><i>276</i>&nbsp;                    setRequestAsProcessed();</b>
<i>277</i>&nbsp;
<b class="fc"><i>278</i>&nbsp;            } else if (request instanceof CommandRequestEvent) {</b>
<b class="fc"><i>279</i>&nbsp;                sendCommand(((CommandRequestEvent) request).getCommand());</b>
<i>280</i>&nbsp;            }
<b class="fc"><i>281</i>&nbsp;        }</b>
<i>282</i>&nbsp;
<i>283</i>&nbsp;        private void initBluetoothParameters(StartOrContinueConnectionRequestEvent event) {
<b class="nc"><i>284</i>&nbsp;            connectAudioIfDeviceCompatible = event.connectAudioIfDeviceCompatible();</b>
<b class="nc"><i>285</i>&nbsp;            deviceTypeRequested = event.getTypeOfDeviceRequested();</b>
<b class="nc"><i>286</i>&nbsp;            deviceQrCodeRequested = event.getQrCodeOfDeviceRequested();</b>
<b class="nc"><i>287</i>&nbsp;            deviceNameRequested = event.getNameOfDeviceRequested();</b>
<b class="nc"><i>288</i>&nbsp;            mtu = event.getMtu();</b>
<i>289</i>&nbsp;
<b class="nc"><i>290</i>&nbsp;            if (event.isClientUserRequest()) {</b>
<b class="nc"><i>291</i>&nbsp;                if (deviceTypeRequested.equals(MbtDeviceType.MELOMIND)) {</b>
<b class="nc"><i>292</i>&nbsp;                    bluetoothForDataStreaming = new MbtBluetoothLE(mContext, MbtBluetoothManager.this);</b>
<b class="nc"><i>293</i>&nbsp;                    if (connectAudioIfDeviceCompatible)</b>
<b class="nc"><i>294</i>&nbsp;                        bluetoothForAudioStreaming = new MbtBluetoothA2DP(mContext, MbtBluetoothManager.this);</b>
<i>295</i>&nbsp;
<b class="nc"><i>296</i>&nbsp;                } else if (deviceTypeRequested.equals(MbtDeviceType.VPRO))</b>
<b class="nc"><i>297</i>&nbsp;                    bluetoothForDataStreaming = new MbtBluetoothSPP(mContext, MbtBluetoothManager.this);</b>
<i>298</i>&nbsp;            }
<i>299</i>&nbsp;
<b class="nc"><i>300</i>&nbsp;            if (deviceQrCodeRequested != null) {</b>
<i>301</i>&nbsp;                //if a QR code has been specified but no device name
<b class="nc"><i>302</i>&nbsp;                if (deviceNameRequested == null)</b>
<i>303</i>&nbsp;                    //retrieve the BLE name from the QR code database
<b class="nc"><i>304</i>&nbsp;                    deviceNameRequested = new MelomindsQRDataBase(mContext, true).get(deviceQrCodeRequested);</b>
<i>305</i>&nbsp;                //if QR code contains only 9 digits
<b class="nc"><i>306</i>&nbsp;                if (deviceQrCodeRequested.startsWith(MelomindsQRDataBase.QR_PREFIX) &amp;&amp; deviceQrCodeRequested.length() == MelomindsQRDataBase.QR_LENGTH - 1)</b>
<b class="nc"><i>307</i>&nbsp;                    deviceQrCodeRequested = deviceQrCodeRequested.concat(MelomindsQRDataBase.QR_SUFFIX); //homogenization with the 10 digits QR code by adding a dot at the end</b>
<i>308</i>&nbsp;                //if a device name has been specified but no QR code
<b class="nc"><i>309</i>&nbsp;            } else if (deviceNameRequested != null &amp;&amp; deviceTypeRequested.equals(MbtDeviceType.MELOMIND))</b>
<b class="nc"><i>310</i>&nbsp;                deviceQrCodeRequested = new MelomindsQRDataBase(mContext, false).get(deviceNameRequested);  //retrieve the QR code from BLE name using QR code database</b>
<i>311</i>&nbsp;
<b class="nc"><i>312</i>&nbsp;        }</b>
<i>313</i>&nbsp;
<i>314</i>&nbsp;        /**
<i>315</i>&nbsp;         * This method do the following operations:
<i>316</i>&nbsp;         * - 1) Check the prerequisites to ensure that the connection can be performed
<i>317</i>&nbsp;         * - 2) Scan for {@link BluetoothDevice } filtering on deviceName. The scan is performed by LE scanner if the device is LE compatible. Otherwise, the discovery scan is performed instead.
<i>318</i>&nbsp;         * - 3) Perform the BLE/SPP connection operation if scan resulted in a found device
<i>319</i>&nbsp;         * - 4) Discovering services once the headset is connected.
<i>320</i>&nbsp;         * - 5) Reading the device info (firmware version, hardware version, serial number, model number) once the services has been discovered
<i>321</i>&nbsp;         * - 6) Bond the headset if the firmware version supports it (version &gt; 1.6.7)
<i>322</i>&nbsp;         * - 7) Send the QR code number to the headset if it doesn&#39;t know its own value and if the firmware version supports it (version &gt; 1.7.1)
<i>323</i>&nbsp;         * - 8) Connect audio in A2dp is the user requested it
<i>324</i>&nbsp;         */
<i>325</i>&nbsp;        private void startOrContinueConnectionOperation(boolean isClientUserRequest){
<b class="nc"><i>326</i>&nbsp;            if(isClientUserRequest)</b>
<b class="nc"><i>327</i>&nbsp;                isConnectionInterrupted = false;</b>
<i>328</i>&nbsp;
<b class="nc"><i>329</i>&nbsp;            if(!isConnectionInterrupted){</b>
<b class="nc"><i>330</i>&nbsp;                LogUtils.d(TAG, &quot;State is &quot;+getCurrentState());</b>
<b class="pc"><i>331</i>&nbsp;                switch (getCurrentState()){</b>
<i>332</i>&nbsp;                    case IDLE:
<i>333</i>&nbsp;                    case DATA_BT_DISCONNECTED:
<b class="nc"><i>334</i>&nbsp;                        getReadyForBluetoothOperation();</b>
<b class="nc"><i>335</i>&nbsp;                        break;</b>
<i>336</i>&nbsp;                    case READY_FOR_BLUETOOTH_OPERATION:
<b class="nc"><i>337</i>&nbsp;                        startScan();</b>
<b class="nc"><i>338</i>&nbsp;                        break;</b>
<i>339</i>&nbsp;                    case DEVICE_FOUND:
<i>340</i>&nbsp;                    case DATA_BT_CONNECTING:
<b class="nc"><i>341</i>&nbsp;                        startConnectionForDataStreaming();</b>
<b class="nc"><i>342</i>&nbsp;                        break;</b>
<i>343</i>&nbsp;                    case DATA_BT_CONNECTION_SUCCESS:
<b class="nc"><i>344</i>&nbsp;                        startDiscoveringServices();</b>
<b class="nc"><i>345</i>&nbsp;                        break;</b>
<i>346</i>&nbsp;                    case DISCOVERING_SUCCESS:
<b class="nc"><i>347</i>&nbsp;                        startReadingDeviceInfo(DeviceInfo.FW_VERSION); // read all device info (except battery) : first device info to read is firmware version</b>
<b class="nc"><i>348</i>&nbsp;                        break;</b>
<i>349</i>&nbsp;                    case READING_FIRMWARE_VERSION_SUCCESS:
<b class="nc"><i>350</i>&nbsp;                        startReadingDeviceInfo(DeviceInfo.HW_VERSION); // read next device info : second device info to read is hardware version</b>
<b class="nc"><i>351</i>&nbsp;                        break;</b>
<i>352</i>&nbsp;                    case READING_HARDWARE_VERSION_SUCCESS:
<b class="nc"><i>353</i>&nbsp;                        startReadingDeviceInfo(DeviceInfo.SERIAL_NUMBER); // read next device info : third device info to read is serial number (device ID)</b>
<b class="nc"><i>354</i>&nbsp;                        break;</b>
<i>355</i>&nbsp;                    case READING_SERIAL_NUMBER_SUCCESS:
<b class="nc"><i>356</i>&nbsp;                        startReadingDeviceInfo(DeviceInfo.MODEL_NUMBER); // read next device info : fourth device info to read is model number</b>
<b class="nc"><i>357</i>&nbsp;                        break;</b>
<i>358</i>&nbsp;                    case READING_SUCCESS: //equivalent to READING_MODEL_NUMBER_SUCCESS
<b class="nc"><i>359</i>&nbsp;                        startBonding();</b>
<b class="nc"><i>360</i>&nbsp;                        break;</b>
<i>361</i>&nbsp;                    case BONDED:
<b class="nc"><i>362</i>&nbsp;                        changeMTU();</b>
<b class="nc"><i>363</i>&nbsp;                        break;</b>
<i>364</i>&nbsp;                    case BT_PARAMETERS_CHANGED:
<b class="nc"><i>365</i>&nbsp;                        startSendingExternalName();</b>
<b class="nc"><i>366</i>&nbsp;                        break;</b>
<i>367</i>&nbsp;                    case CONNECTED:
<b class="nc"><i>368</i>&nbsp;                        startConnectionForAudioStreaming();</b>
<b class="nc"><i>369</i>&nbsp;                        break;</b>
<i>370</i>&nbsp;                    default:
<b class="nc"><i>371</i>&nbsp;                        setRequestAsProcessed();</b>
<i>372</i>&nbsp;                }
<i>373</i>&nbsp;            }else
<b class="nc"><i>374</i>&nbsp;                setRequestAsProcessed();</b>
<b class="nc"><i>375</i>&nbsp;        }</b>
<i>376</i>&nbsp;    }
<i>377</i>&nbsp;
<i>378</i>&nbsp;    @VisibleForTesting
<i>379</i>&nbsp;    void setRequestThread(RequestThread requestThread) {
<b class="fc"><i>380</i>&nbsp;        this.requestThread = requestThread;</b>
<b class="fc"><i>381</i>&nbsp;    }</b>
<i>382</i>&nbsp;
<i>383</i>&nbsp;    @VisibleForTesting
<i>384</i>&nbsp;    void setRequestHandler(Handler requestHandler) {
<b class="fc"><i>385</i>&nbsp;        this.requestHandler = requestHandler;</b>
<b class="fc"><i>386</i>&nbsp;    }</b>
<i>387</i>&nbsp;
<i>388</i>&nbsp;    @VisibleForTesting
<i>389</i>&nbsp;    void setBluetoothForDataStreaming(MbtBluetoothLE bluetoothForDataStreaming) {
<b class="fc"><i>390</i>&nbsp;        this.bluetoothForDataStreaming = bluetoothForDataStreaming;</b>
<b class="fc"><i>391</i>&nbsp;    }</b>
<i>392</i>&nbsp;
<i>393</i>&nbsp;    @VisibleForTesting
<i>394</i>&nbsp;    public RequestThread getRequestThread() {
<b class="fc"><i>395</i>&nbsp;        return requestThread;</b>
<i>396</i>&nbsp;    }
<i>397</i>&nbsp;
<i>398</i>&nbsp;    private void switchToNextConnectionStep(){
<b class="fc"><i>399</i>&nbsp;        setRequestAsProcessed();</b>
<b class="fc"><i>400</i>&nbsp;        if(!getCurrentState().isAFailureState() &amp;&amp; !isConnectionInterrupted &amp;&amp; !getCurrentState().equals(BtState.IDLE))  //if nothing went wrong during the current step of the connection process, we continue the process</b>
<b class="fc"><i>401</i>&nbsp;            onNewBluetoothRequest(new StartOrContinueConnectionRequestEvent(false, deviceNameRequested, deviceQrCodeRequested, deviceTypeRequested, mtu, connectAudioIfDeviceCompatible));</b>
<i>402</i>&nbsp;
<b class="fc"><i>403</i>&nbsp;    }</b>
<i>404</i>&nbsp;
<i>405</i>&nbsp;    /**
<i>406</i>&nbsp;     * As headset transmits its sensed data to the SDK using Bluetooth,
<i>407</i>&nbsp;     * the mobile device Bluetooth must be currently enabled and ready for use.
<i>408</i>&nbsp;     * The Bluetooth Manager must always check this prerequisite before starting any connection operation by calling the isBluetoothDisabled() method.
<i>409</i>&nbsp;     * @return false is Bluetooth is ON /enabled,
<i>410</i>&nbsp;     * or true is Bluetooth is OFF / disabled.
<i>411</i>&nbsp;     **/
<i>412</i>&nbsp;    private boolean isBluetoothDisabled(){
<b class="nc"><i>413</i>&nbsp;        boolean isBluetoothDisabled = false;</b>
<b class="nc"><i>414</i>&nbsp;        if(!BluetoothAdapter.getDefaultAdapter().isEnabled()){</b>
<b class="nc"><i>415</i>&nbsp;            updateConnectionState(BtState.BLUETOOTH_DISABLED);</b>
<b class="nc"><i>416</i>&nbsp;            isBluetoothDisabled = true;</b>
<i>417</i>&nbsp;        }
<b class="nc"><i>418</i>&nbsp;        return isBluetoothDisabled;</b>
<i>419</i>&nbsp;    }
<i>420</i>&nbsp;
<i>421</i>&nbsp;    /**
<i>422</i>&nbsp;     * As the Bluetooth scan requires access to the mobile device Location,
<i>423</i>&nbsp;     * the Bluetooth Manager must always check this prerequisite before starting any connection operation by calling the isLocationDisabledOrNotGranted() method.
<i>424</i>&nbsp;     * @return false is Location is ON /enabled and Location permission is granted,
<i>425</i>&nbsp;     * or true is Location is OFF / disabled, and/or Location permission is not granted.
<i>426</i>&nbsp;     **/
<i>427</i>&nbsp;    private boolean isLocationDisabledOrNotGranted(){
<b class="nc"><i>428</i>&nbsp;        boolean isLocationDisabledOrNotGranted = false;</b>
<i>429</i>&nbsp;        //Checking location permission
<b class="nc"><i>430</i>&nbsp;        if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M &amp;&amp; ContextCompat.checkSelfPermission(mContext,</b>
<i>431</i>&nbsp;                Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_DENIED
<b class="nc"><i>432</i>&nbsp;                &amp;&amp; ContextCompat.checkSelfPermission(mContext,</b>
<i>433</i>&nbsp;                Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_DENIED
<b class="nc"><i>434</i>&nbsp;                &amp;&amp; deviceTypeRequested.useLowEnergyProtocol()){</b>
<i>435</i>&nbsp;
<b class="nc"><i>436</i>&nbsp;            updateConnectionState(BtState.LOCATION_PERMISSION_NOT_GRANTED);</b>
<b class="nc"><i>437</i>&nbsp;            isLocationDisabledOrNotGranted = true;</b>
<i>438</i>&nbsp;        }
<i>439</i>&nbsp;
<i>440</i>&nbsp;        //Checking location activation
<b class="nc"><i>441</i>&nbsp;        LocationManager manager = (LocationManager) mContext.getSystemService(Context.LOCATION_SERVICE);</b>
<b class="nc"><i>442</i>&nbsp;        if(deviceTypeRequested.useLowEnergyProtocol() &amp;&amp; manager != null &amp;&amp; !manager.isProviderEnabled(LocationManager.GPS_PROVIDER) &amp;&amp; mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION_GPS)){</b>
<b class="nc"><i>443</i>&nbsp;            updateConnectionState(BtState.LOCATION_DISABLED);</b>
<b class="nc"><i>444</i>&nbsp;            isLocationDisabledOrNotGranted = true;</b>
<i>445</i>&nbsp;        }
<b class="nc"><i>446</i>&nbsp;        return isLocationDisabledOrNotGranted;</b>
<i>447</i>&nbsp;    }
<i>448</i>&nbsp;
<i>449</i>&nbsp;    /**
<i>450</i>&nbsp;     * As the Bluetooth scan requires access to the mobile device Location,
<i>451</i>&nbsp;     * the Bluetooth Manager must always check this prerequisite before starting any connection operation by calling the isLocationDisabledOrNotGranted() method.
<i>452</i>&nbsp;     * @return true if a headset is already connected in BLE and Audio (if Audio has been enabled)
<i>453</i>&nbsp;     * or if no headset is connected.
<i>454</i>&nbsp;     **/
<i>455</i>&nbsp;    private boolean isAlreadyConnected(MbtDevice currentConnectedDevice){
<b class="nc"><i>456</i>&nbsp;        boolean isAlreadyConnected = false;</b>
<b class="nc"><i>457</i>&nbsp;        if(isConnected()){</b>
<b class="nc"><i>458</i>&nbsp;            if(!isAlreadyConnectedToRequestedDevice(deviceNameRequested, currentConnectedDevice)) {</b>
<b class="nc"><i>459</i>&nbsp;                updateConnectionState(BtState.ANOTHER_DEVICE_CONNECTED);</b>
<i>460</i>&nbsp;            }else
<b class="nc"><i>461</i>&nbsp;                updateConnectionState(BtState.CONNECTED_AND_READY);</b>
<b class="nc"><i>462</i>&nbsp;            isAlreadyConnected = true;</b>
<i>463</i>&nbsp;        }
<b class="nc"><i>464</i>&nbsp;        return isAlreadyConnected;</b>
<i>465</i>&nbsp;    }
<i>466</i>&nbsp;    /**
<i>467</i>&nbsp;     * Check the bluetooth prerequisites before starting any bluetooth operation.
<i>468</i>&nbsp;     * The started Bluetooth connection process is stopped if the prerequisites are not valid.
<i>469</i>&nbsp;     */
<i>470</i>&nbsp;    private void getReadyForBluetoothOperation(){
<b class="nc"><i>471</i>&nbsp;        connectionRetryCounter = 0;</b>
<i>472</i>&nbsp;        //Request sent to the BUS in order to get device from the device manager : the BUS should return a null object if it&#39;s the first connection, or return a non null object if the user requests connection whereas a headset is already connected
<b class="nc"><i>473</i>&nbsp;        LogUtils.i(TAG, &quot;Checking Bluetooth Prerequisites and initialize&quot;);</b>
<b class="nc"><i>474</i>&nbsp;        requestCurrentConnectedDevice(new SimpleRequestCallback&lt;MbtDevice&gt;() {</b>
<i>475</i>&nbsp;            @Override
<i>476</i>&nbsp;            public void onRequestComplete(MbtDevice device) { //when the BUS has returned the device object
<b class="nc"><i>477</i>&nbsp;                if (device != null &amp;&amp; isAlreadyConnected(device)) // assert that headset is not already connected</b>
<i>478</i>&nbsp;                    return;
<i>479</i>&nbsp;
<b class="nc"><i>480</i>&nbsp;                if (isBluetoothDisabled()) //assert that Bluetooth is on</b>
<i>481</i>&nbsp;                    return;
<i>482</i>&nbsp;
<b class="nc"><i>483</i>&nbsp;                if (isLocationDisabledOrNotGranted()) //assert that Location is on and Location permissions are granted</b>
<i>484</i>&nbsp;                    return;
<i>485</i>&nbsp;
<b class="nc"><i>486</i>&nbsp;                if(bluetoothForAudioStreaming != null &amp;&amp; bluetoothForAudioStreaming instanceof MbtBluetoothA2DP)</b>
<b class="nc"><i>487</i>&nbsp;                    ((MbtBluetoothA2DP)bluetoothForAudioStreaming).initA2dpProxy(); //initialization to check if a Melomind is already connected in A2DP : as the next step is the scanning, the SDK is able to filter on the name of this device</b>
<i>488</i>&nbsp;
<b class="nc"><i>489</i>&nbsp;                if (getCurrentState().equals(BtState.IDLE))</b>
<b class="nc"><i>490</i>&nbsp;                    updateConnectionState(false); //current state is set to READY_FOR_BLUETOOTH_OPERATION</b>
<b class="nc"><i>491</i>&nbsp;                switchToNextConnectionStep();</b>
<i>492</i>&nbsp;            }
<i>493</i>&nbsp;        });
<b class="nc"><i>494</i>&nbsp;    }</b>
<i>495</i>&nbsp;
<i>496</i>&nbsp;    /**
<i>497</i>&nbsp;     * This method starts a bluetooth scan operation, loooking for a single device by filtering on its name.
<i>498</i>&nbsp;     * This method is asynchronous.
<i>499</i>&nbsp;     * If the device to scan is a Melomind, the bluetooth LE scanner is invoked.
<i>500</i>&nbsp;     * Otherwise, the classic discovery scan is invoked.
<i>501</i>&nbsp;     * &lt;p&gt;Requires {@link Manifest.permission#ACCESS_FINE_LOCATION} or {@link Manifest.permission#ACCESS_COARSE_LOCATION} permission if a GPS sensor is available.
<i>502</i>&nbsp;     * If permissions are not given and/or bluetooth device is not Le compatible, discovery scan is started.
<i>503</i>&nbsp;     * The started Bluetooth connection process is stopped if the prerequisites are not valid.
<i>504</i>&nbsp;     */
<i>505</i>&nbsp;    private void startScan(){
<b class="nc"><i>506</i>&nbsp;        BtState newState = BtState.SCAN_FAILURE;</b>
<i>507</i>&nbsp;        try {
<b class="nc"><i>508</i>&nbsp;            AsyncUtils.executeAsync(new Runnable() {</b>
<i>509</i>&nbsp;                @Override
<i>510</i>&nbsp;                public void run() {
<b class="nc"><i>511</i>&nbsp;                    bluetoothForDataStreaming.startScan();</b>
<i>512</i>&nbsp;                }
<i>513</i>&nbsp;            });
<b class="nc"><i>514</i>&nbsp;            asyncOperation.waitOperationResult(MbtConfig.getBluetoothScanTimeout());</b>
<b class="nc"><i>515</i>&nbsp;        } catch (CancellationException | InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc"><i>516</i>&nbsp;            if(e instanceof TimeoutException )</b>
<b class="nc"><i>517</i>&nbsp;                newState = BtState.SCAN_TIMEOUT ; //stop the current Bluetooth connection process</b>
<b class="nc"><i>518</i>&nbsp;            else if(e instanceof CancellationException )</b>
<b class="nc"><i>519</i>&nbsp;                asyncOperation.resetWaitingOperation();</b>
<b class="nc"><i>520</i>&nbsp;            LogUtils.w(TAG, &quot;Exception raised during scanning : \n &quot; + e.toString());</b>
<i>521</i>&nbsp;        } finally {
<b class="nc"><i>522</i>&nbsp;            stopScan();</b>
<b class="nc"><i>523</i>&nbsp;        }</b>
<b class="nc"><i>524</i>&nbsp;        if(getCurrentState().equals(BtState.SCAN_STARTED)) ////at this point : current state should be DEVICE_FOUND if scan succeeded</b>
<b class="nc"><i>525</i>&nbsp;            updateConnectionState(newState); //scan failure or timeout</b>
<b class="nc"><i>526</i>&nbsp;        switchToNextConnectionStep();</b>
<b class="nc"><i>527</i>&nbsp;    }</b>
<i>528</i>&nbsp;
<i>529</i>&nbsp;    /**
<i>530</i>&nbsp;     * This method stops the currently running bluetooth scan, either Le scan or discovery scan
<i>531</i>&nbsp;     */
<i>532</i>&nbsp;    private void stopScan(){
<b class="nc"><i>533</i>&nbsp;        asyncOperation.stopWaitingOperation(CANCEL);</b>
<b class="nc"><i>534</i>&nbsp;        if (ContextCompat.checkSelfPermission(mContext,</b>
<b class="nc"><i>535</i>&nbsp;                Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED || ContextCompat.checkSelfPermission(mContext,</b>
<i>536</i>&nbsp;                Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED)
<b class="nc"><i>537</i>&nbsp;            bluetoothForDataStreaming.stopScan();</b>
<b class="nc"><i>538</i>&nbsp;    }</b>
<i>539</i>&nbsp;
<i>540</i>&nbsp;    /**
<i>541</i>&nbsp;     * This connection step is the BLE (Melomind) /SPP (Vpro) connection to the found device
<i>542</i>&nbsp;     * It allows communication between the headset device and the SDK for data streaming (EEG, battery level, etc.)
<i>543</i>&nbsp;     **/
<i>544</i>&nbsp;    private void startConnectionForDataStreaming(){
<b class="nc"><i>545</i>&nbsp;        LogUtils.i(TAG, &quot;start connection data streaming&quot;);</b>
<i>546</i>&nbsp;        try {
<b class="nc"><i>547</i>&nbsp;            AsyncUtils.executeAsync(new Runnable() {</b>
<i>548</i>&nbsp;                @Override
<i>549</i>&nbsp;                public void run() {
<b class="nc"><i>550</i>&nbsp;                    connect(deviceTypeRequested.getProtocol());</b>
<i>551</i>&nbsp;                }
<i>552</i>&nbsp;            });
<b class="nc"><i>553</i>&nbsp;            asyncOperation.waitOperationResult(MbtConfig.getBluetoothConnectionTimeout()); // blocked until the futureOperation.complete() is called or until timeout</b>
<b class="nc"><i>554</i>&nbsp;        } catch (CancellationException | InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc"><i>555</i>&nbsp;            LogUtils.w(TAG, &quot;Exception raised during connection : \n &quot; + e.toString());</b>
<b class="nc"><i>556</i>&nbsp;            if(e instanceof CancellationException )</b>
<b class="nc"><i>557</i>&nbsp;                asyncOperation.resetWaitingOperation();</b>
<i>558</i>&nbsp;        }finally {
<b class="nc"><i>559</i>&nbsp;            asyncOperation.stopWaitingOperation(CANCEL);</b>
<b class="nc"><i>560</i>&nbsp;        }</b>
<b class="nc"><i>561</i>&nbsp;        if(!getCurrentState().equals(BtState.CONNECTED_AND_READY) &amp;&amp; !getCurrentState().equals(BtState.DATA_BT_CONNECTION_SUCCESS) &amp;&amp; !getCurrentState().equals(BtState.IDLE))</b>
<b class="nc"><i>562</i>&nbsp;            updateConnectionState(BtState.CONNECTION_FAILURE);</b>
<b class="nc"><i>563</i>&nbsp;        switchToNextConnectionStep();</b>
<b class="nc"><i>564</i>&nbsp;    }</b>
<i>565</i>&nbsp;
<i>566</i>&nbsp;    private void connect(BtProtocol protocol){
<b class="nc"><i>567</i>&nbsp;        boolean isConnectionSuccessful = false;</b>
<b class="nc"><i>568</i>&nbsp;        this.isConnectionInterrupted = false; // resetting the flag when starting a new connection</b>
<b class="pc"><i>569</i>&nbsp;        switch (protocol){</b>
<i>570</i>&nbsp;            case BLUETOOTH_LE:
<i>571</i>&nbsp;            case BLUETOOTH_SPP:
<b class="nc"><i>572</i>&nbsp;                isConnectionSuccessful = bluetoothForDataStreaming.connect(mContext, getCurrentDevice());</b>
<b class="nc"><i>573</i>&nbsp;                break;</b>
<i>574</i>&nbsp;            case BLUETOOTH_A2DP:
<b class="nc"><i>575</i>&nbsp;                if(bluetoothForAudioStreaming != null)</b>
<b class="nc"><i>576</i>&nbsp;                    isConnectionSuccessful = bluetoothForAudioStreaming.connect(mContext, getCurrentDevice());</b>
<i>577</i>&nbsp;                break;
<i>578</i>&nbsp;        }
<b class="nc"><i>579</i>&nbsp;        if(isConnectionSuccessful) {</b>
<b class="nc"><i>580</i>&nbsp;            if(protocol.equals(BLUETOOTH_A2DP)) {</b>
<b class="nc"><i>581</i>&nbsp;                if (isAudioBluetoothConnected())</b>
<b class="nc"><i>582</i>&nbsp;                    asyncOperation.stopWaitingOperation(false);</b>
<i>583</i>&nbsp;            }else
<b class="nc"><i>584</i>&nbsp;                updateConnectionState(isDataBluetoothConnected());</b>
<i>585</i>&nbsp;        }
<b class="nc"><i>586</i>&nbsp;    }</b>
<i>587</i>&nbsp;
<i>588</i>&nbsp;    /**
<i>589</i>&nbsp;     * Once a device is connected in Bluetooth Low Energy / SPP for data streaming, we consider that the Bluetooth connection process is not fully completed.
<i>590</i>&nbsp;     * The services offered by a remote device as well as their characteristics and descriptors are discovered to ensure that Data Streaming can be performed.
<i>591</i>&nbsp;     * It means that the Bluetooth Manager retrieve all the services, which can be seen as categories of data that the headset is transmitting
<i>592</i>&nbsp;     * This is an asynchro
<i>593</i>&nbsp;     * nous operation.
<i>594</i>&nbsp;     * Once service discovery is completed, the BluetoothGattCallback.onServicesDiscovered callback is triggered.
<i>595</i>&nbsp;     * If the discovery was successful, the remote services can be retrieved using the getServices function
<i>596</i>&nbsp;     */
<i>597</i>&nbsp;    private void startDiscoveringServices(){
<b class="nc"><i>598</i>&nbsp;        if(bluetoothForDataStreaming instanceof MbtBluetoothLE) {</b>
<b class="nc"><i>599</i>&nbsp;            LogUtils.i(TAG, &quot;start discovering services &quot;);</b>
<b class="nc"><i>600</i>&nbsp;            if (getCurrentState().ordinal() &gt;= BtState.DATA_BT_CONNECTION_SUCCESS.ordinal()) { //if connection is in progress and BLE is at least connected, we can discover services</b>
<i>601</i>&nbsp;                try {
<b class="nc"><i>602</i>&nbsp;                    AsyncUtils.executeAsync(new Runnable() {</b>
<i>603</i>&nbsp;                        @Override
<i>604</i>&nbsp;                        public void run() {
<b class="nc"><i>605</i>&nbsp;                            ((MbtBluetoothLE)bluetoothForDataStreaming).discoverServices();</b>
<i>606</i>&nbsp;                        }
<i>607</i>&nbsp;                    });
<b class="nc"><i>608</i>&nbsp;                    asyncOperation.waitOperationResult(MbtConfig.getBluetoothDiscoverTimeout());</b>
<b class="nc"><i>609</i>&nbsp;                } catch (CancellationException | InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc"><i>610</i>&nbsp;                    if (e instanceof CancellationException)</b>
<b class="nc"><i>611</i>&nbsp;                        asyncOperation.resetWaitingOperation();</b>
<b class="nc"><i>612</i>&nbsp;                    LogUtils.i(TAG, &quot;Exception raised discovery connection : \n &quot; + e.toString());</b>
<i>613</i>&nbsp;                } finally {
<b class="nc"><i>614</i>&nbsp;                    asyncOperation.stopWaitingOperation(CANCEL);</b>
<b class="nc"><i>615</i>&nbsp;                }</b>
<i>616</i>&nbsp;
<b class="nc"><i>617</i>&nbsp;                if (!getCurrentState().equals(BtState.DISCOVERING_SUCCESS)) {////at this point : current state should be DISCOVERING_SUCCESS if discovery succeeded</b>
<b class="nc"><i>618</i>&nbsp;                    updateConnectionState(BtState.DISCOVERING_FAILURE);</b>
<i>619</i>&nbsp;                }
<b class="nc"><i>620</i>&nbsp;                switchToNextConnectionStep();</b>
<i>621</i>&nbsp;            }
<i>622</i>&nbsp;        }
<b class="nc"><i>623</i>&nbsp;    }</b>
<i>624</i>&nbsp;
<i>625</i>&nbsp;    private void startReadingDeviceInfo(DeviceInfo deviceInfo){
<b class="nc"><i>626</i>&nbsp;        updateConnectionState(false); //current state is set to READING_FIRMWARE_VERSION or READING_HARDWARE_VERSION or READING_SERIAL_NUMBER or READING_MODEL_NUMBER</b>
<i>627</i>&nbsp;        try {
<b class="nc"><i>628</i>&nbsp;            AsyncUtils.executeAsync(new Runnable() {</b>
<i>629</i>&nbsp;                @Override
<i>630</i>&nbsp;                public void run() {
<b class="nc"><i>631</i>&nbsp;                    startReadOperation(deviceInfo);</b>
<i>632</i>&nbsp;                }
<i>633</i>&nbsp;            });
<b class="nc"><i>634</i>&nbsp;            asyncOperation.waitOperationResult(MbtConfig.getBluetoothReadingTimeout());</b>
<b class="nc"><i>635</i>&nbsp;        } catch (CancellationException | InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc"><i>636</i>&nbsp;            LogUtils.w(TAG, &quot;Exception raised during reading device info : \n &quot; + e.toString());</b>
<b class="nc"><i>637</i>&nbsp;            if(e instanceof CancellationException )</b>
<b class="nc"><i>638</i>&nbsp;                asyncOperation.resetWaitingOperation();</b>
<i>639</i>&nbsp;        } finally {
<b class="nc"><i>640</i>&nbsp;            asyncOperation.stopWaitingOperation(CANCEL);</b>
<b class="nc"><i>641</i>&nbsp;        }</b>
<i>642</i>&nbsp;
<b class="pc"><i>643</i>&nbsp;        switch(deviceInfo){</b>
<i>644</i>&nbsp;            case FW_VERSION:
<b class="nc"><i>645</i>&nbsp;                if(!getCurrentState().equals(BtState.READING_FIRMWARE_VERSION_SUCCESS)) //at this point : current state should be READING...SUCCESS if reading succeeded</b>
<b class="nc"><i>646</i>&nbsp;                    updateConnectionState(BtState.READING_FAILURE);</b>
<i>647</i>&nbsp;                break;
<i>648</i>&nbsp;            case HW_VERSION:
<b class="nc"><i>649</i>&nbsp;                if(!getCurrentState().equals(BtState.READING_HARDWARE_VERSION_SUCCESS))//at this point : current state should be READING...SUCCESS if reading succeeded</b>
<b class="nc"><i>650</i>&nbsp;                    updateConnectionState(BtState.READING_FAILURE);</b>
<i>651</i>&nbsp;                break;
<i>652</i>&nbsp;            case SERIAL_NUMBER:
<b class="nc"><i>653</i>&nbsp;                if(!getCurrentState().equals(BtState.READING_SERIAL_NUMBER_SUCCESS))//at this point : current state should be READING...SUCCESS if reading succeeded</b>
<b class="nc"><i>654</i>&nbsp;                    updateConnectionState(BtState.READING_FAILURE);</b>
<i>655</i>&nbsp;                break;
<i>656</i>&nbsp;            case MODEL_NUMBER:
<b class="nc"><i>657</i>&nbsp;                if(!getCurrentState().equals(BtState.READING_SUCCESS))//at this point : current state should be READING...SUCCESS if reading succeeded</b>
<b class="nc"><i>658</i>&nbsp;                    updateConnectionState(BtState.READING_FAILURE);</b>
<i>659</i>&nbsp;                break;
<i>660</i>&nbsp;        }
<b class="nc"><i>661</i>&nbsp;        switchToNextConnectionStep();</b>
<b class="nc"><i>662</i>&nbsp;    }</b>
<i>663</i>&nbsp;
<i>664</i>&nbsp;    /**
<i>665</i>&nbsp;     * If the {@link BluetoothRequests request} is a {@link ReadRequestEvent} event, this method
<i>666</i>&nbsp;     * is called to parse which read operation is to be executed according to the {@link DeviceInfo}.
<i>667</i>&nbsp;     * @param deviceInfo the {@link DeviceInfo} info that determine which read to operation to execute.
<i>668</i>&nbsp;     */
<i>669</i>&nbsp;    public void startReadOperation(DeviceInfo deviceInfo) {
<b class="fc"><i>670</i>&nbsp;        switch(deviceInfo){</b>
<i>671</i>&nbsp;            case BATTERY:
<b class="fc"><i>672</i>&nbsp;                readBattery();</b>
<b class="fc"><i>673</i>&nbsp;                break;</b>
<i>674</i>&nbsp;            case FW_VERSION:
<b class="nc"><i>675</i>&nbsp;                readFwVersion();</b>
<b class="nc"><i>676</i>&nbsp;                break;</b>
<i>677</i>&nbsp;            case HW_VERSION:
<b class="nc"><i>678</i>&nbsp;                readHwVersion();</b>
<b class="nc"><i>679</i>&nbsp;                break;</b>
<i>680</i>&nbsp;            case SERIAL_NUMBER:
<b class="nc"><i>681</i>&nbsp;                readSerialNumber();</b>
<b class="nc"><i>682</i>&nbsp;                break;</b>
<i>683</i>&nbsp;            case MODEL_NUMBER:
<b class="nc"><i>684</i>&nbsp;                readModelNumber();</b>
<b class="nc"><i>685</i>&nbsp;                break;</b>
<i>686</i>&nbsp;            default:
<i>687</i>&nbsp;                break;
<i>688</i>&nbsp;        }
<b class="fc"><i>689</i>&nbsp;    }</b>
<i>690</i>&nbsp;
<i>691</i>&nbsp;    /**
<i>692</i>&nbsp;     * Initiates a read battery operation on this correct BtProtocol.
<i>693</i>&nbsp;     * In case of failure during read process, an event with error is posted to the main manager.
<i>694</i>&nbsp;     */
<i>695</i>&nbsp;    private void readBattery() {
<b class="fc"><i>696</i>&nbsp;        if(!bluetoothForDataStreaming.readBattery()){</b>
<b class="fc"><i>697</i>&nbsp;            setRequestAsProcessed();</b>
<b class="fc"><i>698</i>&nbsp;            MbtEventBus.postEvent(new DeviceInfoEvent&lt;&gt;(DeviceInfo.BATTERY, null));</b>
<i>699</i>&nbsp;        }
<b class="fc"><i>700</i>&nbsp;    }</b>
<i>701</i>&nbsp;
<i>702</i>&nbsp;    /**
<i>703</i>&nbsp;     * Initiates a read firmware version operation on this correct BtProtocol
<i>704</i>&nbsp;     * In case of failure during read process, an event with error is posted to the main manager.
<i>705</i>&nbsp;     */
<i>706</i>&nbsp;    private void readFwVersion(){
<b class="nc"><i>707</i>&nbsp;        if(bluetoothForDataStreaming instanceof BluetoothInterfaces.IDeviceInfoMonitor</b>
<b class="nc"><i>708</i>&nbsp;                &amp;&amp; !((BluetoothInterfaces.IDeviceInfoMonitor)bluetoothForDataStreaming).readFwVersion()){</b>
<b class="nc"><i>709</i>&nbsp;            setRequestAsProcessed();</b>
<b class="nc"><i>710</i>&nbsp;            MbtEventBus.postEvent(new DeviceInfoEvent&lt;&gt;(DeviceInfo.FW_VERSION, null));</b>
<i>711</i>&nbsp;        }
<b class="nc"><i>712</i>&nbsp;    }</b>
<i>713</i>&nbsp;
<i>714</i>&nbsp;    /**
<i>715</i>&nbsp;     * Initiates a read hardware version operation on this correct BtProtocol
<i>716</i>&nbsp;     * In case of failure during read process, an event with error is posted to the main manager.
<i>717</i>&nbsp;     */
<i>718</i>&nbsp;    private void readHwVersion(){
<b class="nc"><i>719</i>&nbsp;        if(bluetoothForDataStreaming instanceof BluetoothInterfaces.IDeviceInfoMonitor</b>
<b class="nc"><i>720</i>&nbsp;                &amp;&amp; !((BluetoothInterfaces.IDeviceInfoMonitor)bluetoothForDataStreaming).readHwVersion()){</b>
<b class="nc"><i>721</i>&nbsp;            setRequestAsProcessed();</b>
<b class="nc"><i>722</i>&nbsp;            MbtEventBus.postEvent(new DeviceInfoEvent&lt;&gt;(DeviceInfo.HW_VERSION, null));</b>
<i>723</i>&nbsp;        }
<b class="nc"><i>724</i>&nbsp;    }</b>
<i>725</i>&nbsp;
<i>726</i>&nbsp;    /**
<i>727</i>&nbsp;     * Initiates a read serial number operation on this correct BtProtocol
<i>728</i>&nbsp;     * In case of failure during read process, an event with error is posted to the main manager.
<i>729</i>&nbsp;     */
<i>730</i>&nbsp;    private void readSerialNumber(){
<b class="nc"><i>731</i>&nbsp;        if(bluetoothForDataStreaming instanceof BluetoothInterfaces.IDeviceInfoMonitor</b>
<b class="nc"><i>732</i>&nbsp;                &amp;&amp; !((BluetoothInterfaces.IDeviceInfoMonitor)bluetoothForDataStreaming).readSerialNumber()){</b>
<b class="nc"><i>733</i>&nbsp;            setRequestAsProcessed();</b>
<b class="nc"><i>734</i>&nbsp;            MbtEventBus.postEvent(new DeviceInfoEvent&lt;&gt;(DeviceInfo.SERIAL_NUMBER, null));</b>
<i>735</i>&nbsp;
<i>736</i>&nbsp;        }
<b class="nc"><i>737</i>&nbsp;    }</b>
<i>738</i>&nbsp;
<i>739</i>&nbsp;    /**
<i>740</i>&nbsp;     * Initiates a read model number operation on this correct BtProtocol
<i>741</i>&nbsp;     * In case of failure during read process, an event with error is posted to the main manager.
<i>742</i>&nbsp;     */
<i>743</i>&nbsp;    private void readModelNumber(){
<b class="nc"><i>744</i>&nbsp;        if(bluetoothForDataStreaming instanceof BluetoothInterfaces.IDeviceInfoMonitor</b>
<b class="nc"><i>745</i>&nbsp;                &amp;&amp; !((BluetoothInterfaces.IDeviceInfoMonitor)bluetoothForDataStreaming).readModelNumber()){</b>
<b class="nc"><i>746</i>&nbsp;            setRequestAsProcessed();</b>
<b class="nc"><i>747</i>&nbsp;            MbtEventBus.postEvent(new DeviceInfoEvent&lt;&gt;(DeviceInfo.MODEL_NUMBER, null));</b>
<i>748</i>&nbsp;
<i>749</i>&nbsp;        }
<b class="nc"><i>750</i>&nbsp;    }</b>
<i>751</i>&nbsp;
<i>752</i>&nbsp;    private void startBonding() {
<b class="nc"><i>753</i>&nbsp;        if(bluetoothForDataStreaming instanceof MbtBluetoothLE){</b>
<b class="nc"><i>754</i>&nbsp;            LogUtils.i(TAG, &quot;start bonding if supported&quot;);</b>
<b class="nc"><i>755</i>&nbsp;            requestCurrentConnectedDevice(new SimpleRequestCallback&lt;MbtDevice&gt;() {</b>
<i>756</i>&nbsp;                @Override
<i>757</i>&nbsp;                public void onRequestComplete(MbtDevice device) { //Firmware version has been read during the previous step so we retrieve its value, as it has been stored in the Device Manager
<b class="nc"><i>758</i>&nbsp;                    boolean isBondingSupported = new VersionHelper(device.getFirmwareVersionAsString()).isValidForFeature(VersionHelper.Feature.BLE_BONDING);</b>
<b class="nc"><i>759</i>&nbsp;                    if (isBondingSupported) { //if firmware version bonding is higher than 1.6.7, the bonding is launched</b>
<i>760</i>&nbsp;                        try {
<b class="nc"><i>761</i>&nbsp;                            AsyncUtils.executeAsync(new Runnable() {</b>
<i>762</i>&nbsp;                                @Override
<i>763</i>&nbsp;                                public void run() {
<b class="nc"><i>764</i>&nbsp;                                    if(getCurrentState() == BtState.BONDING) //avoid double bond if several requestCurrentConnectedDevice are called at the same moment</b>
<i>765</i>&nbsp;                                        return;
<i>766</i>&nbsp;
<b class="nc"><i>767</i>&nbsp;                                    ((MbtBluetoothLE)bluetoothForDataStreaming).bond();</b>
<i>768</i>&nbsp;                                }
<i>769</i>&nbsp;                            });
<b class="nc"><i>770</i>&nbsp;                            asyncOperation.waitOperationResult(MbtConfig.getBluetoothBondingTimeout());</b>
<b class="nc"><i>771</i>&nbsp;                        } catch (CancellationException | InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc"><i>772</i>&nbsp;                            LogUtils.w(TAG, &quot;Exception raised during bonding : \n &quot; + e.toString());</b>
<b class="nc"><i>773</i>&nbsp;                            if (e instanceof CancellationException)</b>
<b class="nc"><i>774</i>&nbsp;                                asyncOperation.resetWaitingOperation();</b>
<i>775</i>&nbsp;                        } finally {
<b class="nc"><i>776</i>&nbsp;                            asyncOperation.stopWaitingOperation(CANCEL);</b>
<b class="nc"><i>777</i>&nbsp;                        }</b>
<i>778</i>&nbsp;
<i>779</i>&nbsp;                    } else  //if firmware version bonding is older than 1.6.7, the connection process is considered completed
<b class="nc"><i>780</i>&nbsp;                        updateConnectionState(BtState.CONNECTED);</b>
<i>781</i>&nbsp;                }
<i>782</i>&nbsp;            });
<b class="nc"><i>783</i>&nbsp;            if(getCurrentState().equals(BtState.BONDING)) { //at this point : current state should be BONDED if bonding succeeded</b>
<b class="nc"><i>784</i>&nbsp;                if (getCurrentDevice().getBondState() == BluetoothDevice.BOND_BONDED)</b>
<b class="nc"><i>785</i>&nbsp;                    updateConnectionState(false); //current state is set to BONDED</b>
<i>786</i>&nbsp;                else
<b class="nc"><i>787</i>&nbsp;                    updateConnectionState(BtState.BONDING_FAILURE);</b>
<i>788</i>&nbsp;            }
<i>789</i>&nbsp;
<i>790</i>&nbsp;            try {
<b class="nc"><i>791</i>&nbsp;                Thread.sleep(500);</b>
<b class="nc"><i>792</i>&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc"><i>793</i>&nbsp;                e.printStackTrace();</b>
<b class="nc"><i>794</i>&nbsp;            }</b>
<i>795</i>&nbsp;
<i>796</i>&nbsp;            try {
<b class="nc"><i>797</i>&nbsp;                Thread.sleep(1000);</b>
<b class="nc"><i>798</i>&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc"><i>799</i>&nbsp;                e.printStackTrace();</b>
<b class="nc"><i>800</i>&nbsp;            }</b>
<i>801</i>&nbsp;
<b class="nc"><i>802</i>&nbsp;            switchToNextConnectionStep();</b>
<i>803</i>&nbsp;        }
<i>804</i>&nbsp;
<b class="nc"><i>805</i>&nbsp;    }</b>
<i>806</i>&nbsp;
<i>807</i>&nbsp;    private void startSendingExternalName() {
<b class="nc"><i>808</i>&nbsp;        LogUtils.i(TAG, &quot;start sending QR code if supported&quot;);</b>
<b class="nc"><i>809</i>&nbsp;        requestCurrentConnectedDevice(new SimpleRequestCallback&lt;MbtDevice&gt;() {</b>
<i>810</i>&nbsp;            @Override
<i>811</i>&nbsp;            public void onRequestComplete(MbtDevice device) {
<b class="nc"><i>812</i>&nbsp;                LogUtils.d(TAG, &quot;device &quot;+device);</b>
<b class="nc"><i>813</i>&nbsp;                updateConnectionState(true);//current state is set to QR_CODE_SENDING</b>
<b class="nc"><i>814</i>&nbsp;                if (device.getSerialNumber() != null &amp;&amp; device.getExternalName() != null &amp;&amp; (device.getExternalName().equals(MbtFeatures.MELOMIND_DEVICE_NAME) || device.getExternalName().length() == MbtFeatures.DEVICE_QR_CODE_LENGTH-1) //send the QR code found in the database if the headset do not know its own QR code</b>
<b class="nc"><i>815</i>&nbsp;                        &amp;&amp; new VersionHelper(device.getFirmwareVersion().getFirmwareVersionAsString()).isValidForFeature(VersionHelper.Feature.REGISTER_EXTERNAL_NAME)) {</b>
<b class="nc"><i>816</i>&nbsp;                    AsyncUtils.executeAsync(new Runnable() {</b>
<i>817</i>&nbsp;                        @Override
<i>818</i>&nbsp;                        public void run() {
<b class="nc"><i>819</i>&nbsp;                            String externalName = new MelomindsQRDataBase(mContext, false).get(device.getSerialNumber());</b>
<b class="nc"><i>820</i>&nbsp;                            sendCommand(new DeviceCommands.UpdateExternalName(externalName));</b>
<i>821</i>&nbsp;                        }
<i>822</i>&nbsp;                    });
<i>823</i>&nbsp;                }
<b class="nc"><i>824</i>&nbsp;                updateConnectionState(true);//current state is set to CONNECTED in any case (success or failure) the connection process is completed and the SDK consider that everything is ready for any operation (for example ready to acquire EEG data)</b>
<i>825</i>&nbsp;            }
<i>826</i>&nbsp;        });
<b class="nc"><i>827</i>&nbsp;        switchToNextConnectionStep();</b>
<b class="nc"><i>828</i>&nbsp;    }</b>
<i>829</i>&nbsp;
<i>830</i>&nbsp;    private void startConnectionForAudioStreaming(){
<b class="nc"><i>831</i>&nbsp;        if(connectAudioIfDeviceCompatible &amp;&amp; !isAudioBluetoothConnected()) {</b>
<b class="nc"><i>832</i>&nbsp;            LogUtils.i(TAG, &quot;start connection audio streaming&quot;);</b>
<b class="nc"><i>833</i>&nbsp;            isRequestCompleted = false;</b>
<b class="nc"><i>834</i>&nbsp;            requestCurrentConnectedDevice(new SimpleRequestCallback&lt;MbtDevice&gt;() {</b>
<i>835</i>&nbsp;                @Override
<i>836</i>&nbsp;                public void onRequestComplete(MbtDevice device) {
<b class="nc"><i>837</i>&nbsp;                    if(device == null)</b>
<i>838</i>&nbsp;                        return;
<b class="nc"><i>839</i>&nbsp;                    if(!isRequestCompleted){</b>
<b class="nc"><i>840</i>&nbsp;                        isRequestCompleted = true;</b>
<b class="nc"><i>841</i>&nbsp;                        boolean connectionFromBleAvailable = new VersionHelper(device.getFirmwareVersionAsString()).isValidForFeature(VersionHelper.Feature.A2DP_FROM_HEADSET);</b>
<i>842</i>&nbsp;                        try {
<b class="nc"><i>843</i>&nbsp;                            AsyncUtils.executeAsync(new Runnable() {</b>
<i>844</i>&nbsp;                                @Override
<i>845</i>&nbsp;                                public void run() {
<b class="nc"><i>846</i>&nbsp;                                    if (connectionFromBleAvailable)   //A2DP cannot be connected from BLE if BLE connection state is not CONNECTED_AND_READY or CONNECTED</b>
<b class="nc"><i>847</i>&nbsp;                                        sendCommand(new DeviceCommands.ConnectAudio());</b>
<i>848</i>&nbsp;                                    else {// if connectA2DPFromBLE failed or is not supported by the headset firmware version
<b class="nc"><i>849</i>&nbsp;                                        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.P || (((MbtBluetoothA2DP)bluetoothForAudioStreaming).isPairedDevice(getCurrentDevice())))</b>
<b class="nc"><i>850</i>&nbsp;                                            connect(BLUETOOTH_A2DP);</b>
<i>851</i>&nbsp;                                        else
<b class="nc"><i>852</i>&nbsp;                                            notifyConnectionStateChanged(BtState.AUDIO_CONNECTION_UNSUPPORTED);</b>
<i>853</i>&nbsp;                                    }
<i>854</i>&nbsp;                                }
<i>855</i>&nbsp;                            });
<b class="nc"><i>856</i>&nbsp;                            asyncOperation.waitOperationResult(MbtConfig.getBluetoothA2DpConnectionTimeout());</b>
<b class="nc"><i>857</i>&nbsp;                        } catch (CancellationException | InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc"><i>858</i>&nbsp;                            LogUtils.w(TAG, &quot;Exception raised during audio connection : \n &quot; + e.toString());</b>
<b class="nc"><i>859</i>&nbsp;                            if(e instanceof CancellationException )</b>
<b class="nc"><i>860</i>&nbsp;                                asyncOperation.resetWaitingOperation();</b>
<i>861</i>&nbsp;                        } finally {
<b class="nc"><i>862</i>&nbsp;                            asyncOperation.stopWaitingOperation(CANCEL);</b>
<b class="nc"><i>863</i>&nbsp;                        }</b>
<i>864</i>&nbsp;                    }
<i>865</i>&nbsp;                }
<i>866</i>&nbsp;            });
<i>867</i>&nbsp;
<b class="nc"><i>868</i>&nbsp;            if(!bluetoothForAudioStreaming.isConnected()) {</b>
<b class="nc"><i>869</i>&nbsp;                if (connectionRetryCounter &lt; MAX_CONNECTION_RETRY) {</b>
<b class="nc"><i>870</i>&nbsp;                    connectionRetryCounter++;</b>
<i>871</i>&nbsp;                    try {
<b class="nc"><i>872</i>&nbsp;                        Thread.sleep(200);</b>
<b class="nc"><i>873</i>&nbsp;                    } catch (InterruptedException e) {</b>
<b class="nc"><i>874</i>&nbsp;                        e.printStackTrace();</b>
<b class="nc"><i>875</i>&nbsp;                    }</b>
<b class="nc"><i>876</i>&nbsp;                    startConnectionForAudioStreaming();</b>
<i>877</i>&nbsp;                } else {
<b class="nc"><i>878</i>&nbsp;                    connectionRetryCounter = 0;</b>
<b class="nc"><i>879</i>&nbsp;                    bluetoothForAudioStreaming.notifyConnectionStateChanged(BtState.CONNECTION_FAILURE); //at this point : current state should be AUDIO_CONNECTED if audio connection succeeded</b>
<b class="nc"><i>880</i>&nbsp;                    bluetoothForDataStreaming.notifyConnectionStateChanged(BtState.CONNECTION_FAILURE);</b>
<i>881</i>&nbsp;                }
<i>882</i>&nbsp;            }
<i>883</i>&nbsp;
<i>884</i>&nbsp;        }
<b class="nc"><i>885</i>&nbsp;        if(isConnected())</b>
<b class="nc"><i>886</i>&nbsp;            updateConnectionState(true); //BLE and audio (if SDK user requested it) are connected so the client is notified that the device is fully connected</b>
<i>887</i>&nbsp;
<b class="nc"><i>888</i>&nbsp;        setRequestAsProcessed();</b>
<i>889</i>&nbsp;
<b class="nc"><i>890</i>&nbsp;        LogUtils.i(TAG, &quot;connection completed&quot;);</b>
<b class="nc"><i>891</i>&nbsp;    }</b>
<i>892</i>&nbsp;
<i>893</i>&nbsp;    /**
<i>894</i>&nbsp;     * Command sent from the SDK to the connected headset
<i>895</i>&nbsp;     * in order to change its Maximum Transmission Unit
<i>896</i>&nbsp;     * (maximum size of the data sent by the headset to the SDK).
<i>897</i>&nbsp;     */
<i>898</i>&nbsp;    private void changeMTU(){
<b class="nc"><i>899</i>&nbsp;        updateConnectionState(true); //current state is set to CHANGING_BT_PARAMETERS</b>
<b class="nc"><i>900</i>&nbsp;        sendCommand(new BluetoothCommands.Mtu(mtu));</b>
<b class="nc"><i>901</i>&nbsp;    }</b>
<i>902</i>&nbsp;
<i>903</i>&nbsp;    private void onMtuChanged(boolean isSuccess){
<b class="fc"><i>904</i>&nbsp;        updateConnectionState(true); //current state is set to BT_PARAMETERS_CHANGED</b>
<b class="fc"><i>905</i>&nbsp;        switchToNextConnectionStep();</b>
<b class="fc"><i>906</i>&nbsp;    }</b>
<i>907</i>&nbsp;
<i>908</i>&nbsp;    /**
<i>909</i>&nbsp;     * Add the new {@link BluetoothRequests} to the handler thread that will execute tasks one after another
<i>910</i>&nbsp;     * This method must return quickly in order not to block the thread.
<i>911</i>&nbsp;     * @param request the new {@link BluetoothRequests } to execute
<i>912</i>&nbsp;     */
<i>913</i>&nbsp;    @Subscribe(threadMode = ThreadMode.ASYNC)
<i>914</i>&nbsp;    public void onNewBluetoothRequest(final BluetoothRequests request){
<i>915</i>&nbsp;        //Specific case: disconnection has main priority so we don&#39;t add it to queue
<b class="fc"><i>916</i>&nbsp;        if(request instanceof DisconnectRequestEvent &amp;&amp; ((DisconnectRequestEvent) request).isInterrupted())</b>
<b class="fc"><i>917</i>&nbsp;            cancelPendingConnection(((DisconnectRequestEvent) request).isInterrupted());</b>
<i>918</i>&nbsp;        else
<b class="fc"><i>919</i>&nbsp;            requestHandler.post(new Runnable() { // enqueue a Runnable object to be called by the Handler message queue when they are received</b>
<i>920</i>&nbsp;                @Override
<i>921</i>&nbsp;                public void run() {
<b class="nc"><i>922</i>&nbsp;                    requestThread.parseRequest(request);//When posting or sending to a Handler, the item is processed as soon as the message queue is ready to do so</b>
<b class="nc"><i>923</i>&nbsp;                }</b>
<i>924</i>&nbsp;            });
<b class="fc"><i>925</i>&nbsp;    }</b>
<i>926</i>&nbsp;
<i>927</i>&nbsp;
<i>928</i>&nbsp;    /**
<i>929</i>&nbsp;     * This method handle a single command in order to
<i>930</i>&nbsp;     * reconfigure some headset&#39;s parameters
<i>931</i>&nbsp;     * or get values stored by the headset
<i>932</i>&nbsp;     * or ask the headset to perform an action.
<i>933</i>&nbsp;     * The command&#39;s parameters are bundled in a {@link DeviceCommand instance}
<i>934</i>&nbsp;     * that can provide a nullable response callback.
<i>935</i>&nbsp;     * All method inside are blocking.
<i>936</i>&nbsp;     * @param command is the {@link DeviceCommand} object that defines the type of command to send
<i>937</i>&nbsp;     * and the asociated command parameters.
<i>938</i>&nbsp;     */
<i>939</i>&nbsp;
<i>940</i>&nbsp;    private void sendCommand(@NonNull CommandInterface.MbtCommand command) {
<b class="fc"><i>941</i>&nbsp;        bluetoothForDataStreaming.sendCommand(command);</b>
<b class="fc"><i>942</i>&nbsp;    }</b>
<i>943</i>&nbsp;
<i>944</i>&nbsp;    /**
<i>945</i>&nbsp;     * Initiates the acquisition of EEG data. This method chooses between the correct BtProtocol.
<i>946</i>&nbsp;     * If there is already a streaming session in progress, nothing happens and the method returns silently.
<i>947</i>&nbsp;     */
<i>948</i>&nbsp;    private void startStreamOperation(boolean enableDeviceStatusMonitoring) {
<b class="fc"><i>949</i>&nbsp;        Log.d(TAG, &quot;Bluetooth Manager starts streaming&quot;);</b>
<i>950</i>&nbsp;
<b class="fc"><i>951</i>&nbsp;        if (!bluetoothForDataStreaming.isConnected()) {</b>
<b class="nc"><i>952</i>&nbsp;            notifyStreamStateChanged(StreamState.DISCONNECTED);</b>
<b class="nc"><i>953</i>&nbsp;            setRequestAsProcessed();</b>
<b class="nc"><i>954</i>&nbsp;            return;</b>
<i>955</i>&nbsp;        }
<i>956</i>&nbsp;
<b class="fc"><i>957</i>&nbsp;        if (bluetoothForDataStreaming.isStreaming()) {</b>
<b class="nc"><i>958</i>&nbsp;            setRequestAsProcessed();</b>
<b class="nc"><i>959</i>&nbsp;            return;</b>
<i>960</i>&nbsp;        }
<i>961</i>&nbsp;
<b class="fc"><i>962</i>&nbsp;        if (enableDeviceStatusMonitoring &amp;&amp; bluetoothForDataStreaming instanceof MbtBluetoothLE)</b>
<b class="nc"><i>963</i>&nbsp;            ((MbtBluetoothLE) bluetoothForDataStreaming).activateDeviceStatusMonitoring();</b>
<i>964</i>&nbsp;
<i>965</i>&nbsp;        try {
<b class="fc"><i>966</i>&nbsp;            AsyncUtils.executeAsync(new Runnable() {</b>
<i>967</i>&nbsp;                @Override
<i>968</i>&nbsp;                public void run() {
<b class="fc"><i>969</i>&nbsp;                    if (!bluetoothForDataStreaming.startStream()) {</b>
<b class="fc"><i>970</i>&nbsp;                        MbtEventBus.postEvent(StreamState.FAILED);</b>
<i>971</i>&nbsp;                    }
<b class="fc"><i>972</i>&nbsp;                }</b>
<i>973</i>&nbsp;            });
<b class="fc"><i>974</i>&nbsp;            Boolean startSucceeded = (Boolean)asyncOperation.waitOperationResult(6000);</b>
<b class="fc"><i>975</i>&nbsp;            if(startSucceeded != null &amp;&amp; !startSucceeded)</b>
<b class="nc"><i>976</i>&nbsp;                MbtEventBus.postEvent(StreamState.FAILED);</b>
<i>977</i>&nbsp;
<b class="fc"><i>978</i>&nbsp;            setRequestAsProcessed();</b>
<i>979</i>&nbsp;
<b class="nc"><i>980</i>&nbsp;        } catch (InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc"><i>981</i>&nbsp;            e.printStackTrace();</b>
<b class="fc"><i>982</i>&nbsp;        }</b>
<b class="fc"><i>983</i>&nbsp;    }</b>
<i>984</i>&nbsp;
<i>985</i>&nbsp;
<i>986</i>&nbsp;    /**
<i>987</i>&nbsp;     * Initiates the acquisition of EEG data from the correct BtProtocol
<i>988</i>&nbsp;     * If there is no streaming session in progress, nothing happens and the method returns silently.
<i>989</i>&nbsp;     */
<i>990</i>&nbsp;    private void stopStreamOperation(){
<b class="nc"><i>991</i>&nbsp;        Log.d(TAG, &quot;Bluetooth Manager stops streaming&quot;);</b>
<b class="nc"><i>992</i>&nbsp;        if (!bluetoothForDataStreaming.isStreaming()) {</b>
<b class="nc"><i>993</i>&nbsp;            setRequestAsProcessed();</b>
<b class="nc"><i>994</i>&nbsp;            return;</b>
<i>995</i>&nbsp;        }
<i>996</i>&nbsp;
<i>997</i>&nbsp;        try {
<b class="nc"><i>998</i>&nbsp;            AsyncUtils.executeAsync(new Runnable() {</b>
<i>999</i>&nbsp;                @Override
<i>1000</i>&nbsp;                public void run() {
<b class="nc"><i>1001</i>&nbsp;                    if (!bluetoothForDataStreaming.stopStream()){</b>
<b class="nc"><i>1002</i>&nbsp;                        asyncOperation.stopWaitingOperation(false);</b>
<b class="nc"><i>1003</i>&nbsp;                        bluetoothForDataStreaming.notifyStreamStateChanged(StreamState.FAILED);</b>
<i>1004</i>&nbsp;                    }
<i>1005</i>&nbsp;                }
<i>1006</i>&nbsp;            });
<b class="nc"><i>1007</i>&nbsp;            Boolean stopSucceeded = (Boolean)asyncOperation.waitOperationResult(6000);</b>
<b class="nc"><i>1008</i>&nbsp;            if(stopSucceeded != null &amp;&amp; !stopSucceeded)</b>
<b class="nc"><i>1009</i>&nbsp;                bluetoothForDataStreaming.notifyStreamStateChanged(StreamState.FAILED);</b>
<i>1010</i>&nbsp;
<b class="nc"><i>1011</i>&nbsp;        } catch (InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc"><i>1012</i>&nbsp;            e.printStackTrace();</b>
<b class="nc"><i>1013</i>&nbsp;            bluetoothForDataStreaming.notifyStreamStateChanged(StreamState.FAILED);</b>
<i>1014</i>&nbsp;        } finally {
<b class="nc"><i>1015</i>&nbsp;            setRequestAsProcessed();</b>
<b class="nc"><i>1016</i>&nbsp;        }</b>
<i>1017</i>&nbsp;
<b class="nc"><i>1018</i>&nbsp;    }</b>
<i>1019</i>&nbsp;
<i>1020</i>&nbsp;    /**
<i>1021</i>&nbsp;     * Start the disconnect operation on the currently connected bluetooth device according to the {@link BtProtocol} currently used.
<i>1022</i>&nbsp;     */
<i>1023</i>&nbsp;    private void disconnect(BtProtocol protocol) {
<b class="fc"><i>1024</i>&nbsp;        if(isAudioBluetoothConnected() || isDataBluetoothConnected() || getCurrentState().isConnectionInProgress()){</b>
<b class="fc"><i>1025</i>&nbsp;            switch(protocol){</b>
<i>1026</i>&nbsp;                case BLUETOOTH_LE:
<i>1027</i>&nbsp;                case BLUETOOTH_SPP:
<b class="fc"><i>1028</i>&nbsp;                    bluetoothForDataStreaming.disconnect();</b>
<b class="fc"><i>1029</i>&nbsp;                    break;</b>
<i>1030</i>&nbsp;                case BLUETOOTH_A2DP:
<b class="nc"><i>1031</i>&nbsp;                    if(bluetoothForAudioStreaming != null)</b>
<b class="nc"><i>1032</i>&nbsp;                        bluetoothForAudioStreaming.disconnect();</b>
<i>1033</i>&nbsp;                    break;
<i>1034</i>&nbsp;            }
<i>1035</i>&nbsp;        }
<b class="fc"><i>1036</i>&nbsp;    }</b>
<i>1037</i>&nbsp;
<i>1038</i>&nbsp;    void disconnectAllBluetooth(boolean disconnectAudioIfConnected){
<b class="fc"><i>1039</i>&nbsp;        LogUtils.i(TAG, &quot;Disconnect all bluetooth&quot;);</b>
<b class="fc"><i>1040</i>&nbsp;        if(isAudioBluetoothConnected() &amp;&amp; disconnectAudioIfConnected)</b>
<b class="nc"><i>1041</i>&nbsp;            disconnect(BLUETOOTH_A2DP);</b>
<b class="fc"><i>1042</i>&nbsp;        disconnect(deviceTypeRequested.getProtocol());</b>
<b class="fc"><i>1043</i>&nbsp;    }</b>
<i>1044</i>&nbsp;
<i>1045</i>&nbsp;    /**
<i>1046</i>&nbsp;     * Stops current pending connection according to its current {@link BtState state}.
<i>1047</i>&nbsp;     * It can be either stop scan or connection process interruption
<i>1048</i>&nbsp;     */
<i>1049</i>&nbsp;    private void cancelPendingConnection(boolean isClientUserAbortion) {
<b class="fc"><i>1050</i>&nbsp;        LogUtils.i(TAG, &quot;cancelling pending connection&quot;);</b>
<b class="fc"><i>1051</i>&nbsp;        setRequestAsProcessed();</b>
<b class="fc"><i>1052</i>&nbsp;        disconnectAllBluetooth(!asyncSwitchOperation.isWaiting());</b>
<i>1053</i>&nbsp;
<b class="fc"><i>1054</i>&nbsp;        if(isClientUserAbortion){</b>
<b class="fc"><i>1055</i>&nbsp;            isConnectionInterrupted = true;</b>
<b class="fc"><i>1056</i>&nbsp;            updateConnectionState(BtState.CONNECTION_INTERRUPTED);</b>
<i>1057</i>&nbsp;        }
<b class="fc"><i>1058</i>&nbsp;        asyncOperation.stopWaitingOperation(CANCEL);</b>
<b class="fc"><i>1059</i>&nbsp;    }</b>
<i>1060</i>&nbsp;
<i>1061</i>&nbsp;    /**
<i>1062</i>&nbsp;     * Posts a BluetoothEEGEvent event to the bus so that MbtEEGManager can handle raw EEG data received
<i>1063</i>&nbsp;     * @param data the raw EEG data array acquired by the headset and transmitted by Bluetooth to the application
<i>1064</i>&nbsp;     */
<i>1065</i>&nbsp;    public void handleDataAcquired(@NonNull final byte[] data){
<b class="nc"><i>1066</i>&nbsp;        MbtEventBus.postEvent(new BluetoothEEGEvent(data)); //MbtEEGManager will convert data from raw packets to eeg values</b>
<b class="nc"><i>1067</i>&nbsp;        setRequestAsProcessed(false);</b>
<b class="nc"><i>1068</i>&nbsp;    }</b>
<i>1069</i>&nbsp;
<i>1070</i>&nbsp;    /**
<i>1071</i>&nbsp;     * Unregister the MbtBluetoothManager class from the bus to avoid memory leak
<i>1072</i>&nbsp;     */
<i>1073</i>&nbsp;    void deinit(){
<b class="nc"><i>1074</i>&nbsp;        MbtEventBus.registerOrUnregister(false,this);</b>
<b class="nc"><i>1075</i>&nbsp;    }</b>
<i>1076</i>&nbsp;
<i>1077</i>&nbsp;    /**
<i>1078</i>&nbsp;     * This method is called from Bluetooth classes and is meant to post an event to the main manager
<i>1079</i>&nbsp;     * that contains the new {@link BtState}
<i>1080</i>&nbsp;     * @param newState the new {@link BtState}
<i>1081</i>&nbsp;     */
<i>1082</i>&nbsp;    public void notifyConnectionStateChanged(@NonNull BtState newState) {
<b class="fc"><i>1083</i>&nbsp;        setRequestAsProcessed();</b>
<i>1084</i>&nbsp;
<b class="fc"><i>1085</i>&nbsp;        switch (newState) { //This event is sent to device module if registered</b>
<i>1086</i>&nbsp;            case DATA_BT_DISCONNECTED:
<b class="nc"><i>1087</i>&nbsp;                if (asyncSwitchOperation.isWaiting())</b>
<b class="nc"><i>1088</i>&nbsp;                    asyncSwitchOperation.stopWaitingOperation(false); //a new a2dp connection was detected while an other headset was connected : here the last device has been well disconnected so we can connect BLE from A2DP</b>
<i>1089</i>&nbsp;                else
<b class="nc"><i>1090</i>&nbsp;                    cancelPendingConnection(false); //a disconnection occurred</b>
<b class="nc"><i>1091</i>&nbsp;                break;</b>
<i>1092</i>&nbsp;
<i>1093</i>&nbsp;            case AUDIO_BT_DISCONNECTED:
<b class="nc"><i>1094</i>&nbsp;                if (bluetoothForAudioStreaming != null)</b>
<b class="nc"><i>1095</i>&nbsp;                    bluetoothForAudioStreaming.notifyConnectionStateChanged(newState, false);</b>
<b class="nc"><i>1096</i>&nbsp;                MbtEventBus.postEvent(new DeviceEvents.AudioDisconnectedDeviceEvent());</b>
<i>1097</i>&nbsp;
<b class="nc"><i>1098</i>&nbsp;                break;</b>
<i>1099</i>&nbsp;
<i>1100</i>&nbsp;            case AUDIO_BT_CONNECTION_SUCCESS:
<b class="nc"><i>1101</i>&nbsp;                if (bluetoothForAudioStreaming != null){</b>
<b class="nc"><i>1102</i>&nbsp;                    bluetoothForAudioStreaming.notifyConnectionStateChanged(newState, false);</b>
<b class="nc"><i>1103</i>&nbsp;                    asyncOperation.stopWaitingOperation(false);</b>
<b class="nc"><i>1104</i>&nbsp;                    if (bluetoothForAudioStreaming.getCurrentDevice() != null &amp;&amp; bluetoothForDataStreaming instanceof MbtBluetoothLE) {</b>
<b class="nc"><i>1105</i>&nbsp;                        String bleDeviceName = ((MbtBluetoothLE) bluetoothForDataStreaming).getBleDeviceNameFromA2dp(bluetoothForAudioStreaming.getCurrentDevice().getName(), mContext);</b>
<b class="nc"><i>1106</i>&nbsp;                        if (!isDataBluetoothConnected() || !((MbtBluetoothLE) bluetoothForDataStreaming).isCurrentDeviceNameEqual(bleDeviceName))</b>
<b class="nc"><i>1107</i>&nbsp;                            connectBLEFromA2DP(bleDeviceName);</b>
<i>1108</i>&nbsp;
<b class="nc"><i>1109</i>&nbsp;                        MbtEventBus.postEvent(new DeviceEvents.AudioConnectedDeviceEvent(bluetoothForAudioStreaming.getCurrentDevice()));</b>
<i>1110</i>&nbsp;
<b class="nc"><i>1111</i>&nbsp;                    }</b>
<i>1112</i>&nbsp;                }
<i>1113</i>&nbsp;                break;
<i>1114</i>&nbsp;
<i>1115</i>&nbsp;            case JACK_CABLE_CONNECTED:
<b class="nc"><i>1116</i>&nbsp;                if(asyncOperation.isWaiting())</b>
<b class="nc"><i>1117</i>&nbsp;                    asyncOperation.stopWaitingOperation(false);</b>
<i>1118</i>&nbsp;                break;
<i>1119</i>&nbsp;
<i>1120</i>&nbsp;            case DEVICE_FOUND:
<b class="nc"><i>1121</i>&nbsp;                MbtEventBus.postEvent(new ConnectionStateEvent(newState, getCurrentDevice(), deviceTypeRequested));</b>
<b class="nc"><i>1122</i>&nbsp;                if(connectAudioIfDeviceCompatible &amp;&amp; bluetoothForAudioStreaming.currentDevice != null)</b>
<b class="nc"><i>1123</i>&nbsp;                    MbtEventBus.postEvent(new DeviceEvents.AudioConnectedDeviceEvent(bluetoothForAudioStreaming.currentDevice));</b>
<i>1124</i>&nbsp;                break;
<i>1125</i>&nbsp;        }
<i>1126</i>&nbsp;
<b class="fc"><i>1127</i>&nbsp;        requestCurrentConnectedDevice(new SimpleRequestCallback&lt;MbtDevice&gt;() {</b>
<i>1128</i>&nbsp;            @Override
<i>1129</i>&nbsp;            public void onRequestComplete(MbtDevice device) {
<b class="nc"><i>1130</i>&nbsp;                MbtEventBus.postEvent(new ConnectionStateEvent(newState, device)); //This event is sent to MbtManager for user notifications and to MbtDeviceManager</b>
<b class="nc"><i>1131</i>&nbsp;            }</b>
<i>1132</i>&nbsp;        });
<i>1133</i>&nbsp;
<b class="fc"><i>1134</i>&nbsp;    }</b>
<i>1135</i>&nbsp;
<i>1136</i>&nbsp;    /**
<i>1137</i>&nbsp;     * This method is called from Bluetooth classes and is meant to post an event to the main manager
<i>1138</i>&nbsp;     * that contains the {@link DeviceInfo} with the associated value
<i>1139</i>&nbsp;     * @param deviceInfo the {@link DeviceInfo}
<i>1140</i>&nbsp;     * @param deviceValue the new value as String
<i>1141</i>&nbsp;     */
<i>1142</i>&nbsp;    void notifyDeviceInfoReceived(DeviceInfo deviceInfo, String deviceValue){
<b class="nc"><i>1143</i>&nbsp;        Log.d(TAG,&quot; Device info returned by the headset &quot;+deviceInfo+ &quot; : &quot;+deviceValue);</b>
<b class="nc"><i>1144</i>&nbsp;        setRequestAsProcessed();</b>
<b class="nc"><i>1145</i>&nbsp;        MbtEventBus.postEvent(new DeviceInfoEvent&lt;&gt;(deviceInfo, deviceValue));</b>
<b class="nc"><i>1146</i>&nbsp;    }</b>
<i>1147</i>&nbsp;
<i>1148</i>&nbsp;    /**
<i>1149</i>&nbsp;     * This method is called from Bluetooth classes and is meant to post an event to the main manager
<i>1150</i>&nbsp;     * that contains the {@link StreamState} new state
<i>1151</i>&nbsp;     * @param newStreamState the {@link StreamState} new state
<i>1152</i>&nbsp;     */
<i>1153</i>&nbsp;    public void notifyStreamStateChanged(StreamState newStreamState) {
<b class="nc"><i>1154</i>&nbsp;        if(newStreamState.equals(StreamState.STOPPED) || newStreamState.equals(StreamState.STARTED))</b>
<b class="nc"><i>1155</i>&nbsp;            asyncOperation.stopWaitingOperation(true);</b>
<i>1156</i>&nbsp;
<b class="nc"><i>1157</i>&nbsp;        setRequestAsProcessed();</b>
<b class="nc"><i>1158</i>&nbsp;        MbtEventBus.postEvent(newStreamState);</b>
<b class="nc"><i>1159</i>&nbsp;    }</b>
<i>1160</i>&nbsp;
<i>1161</i>&nbsp;    public void notifyNewHeadsetStatus(@NonNull byte[] payload) {
<b class="nc"><i>1162</i>&nbsp;        MbtEventBus.postEvent(new DeviceEvents.RawDeviceMeasure(payload));</b>
<b class="nc"><i>1163</i>&nbsp;    }</b>
<i>1164</i>&nbsp;
<i>1165</i>&nbsp;    public void requestCurrentConnectedDevice(final SimpleRequestCallback&lt;MbtDevice&gt; callback) {
<b class="fc"><i>1166</i>&nbsp;        MbtEventBus.postEvent(new DeviceEvents.GetDeviceEvent(), new MbtEventBus.Callback&lt;DeviceEvents.PostDeviceEvent&gt;(){</b>
<i>1167</i>&nbsp;            @Override
<i>1168</i>&nbsp;            @Subscribe
<i>1169</i>&nbsp;            public Void onEventCallback(DeviceEvents.PostDeviceEvent device) {
<b class="nc"><i>1170</i>&nbsp;                MbtEventBus.registerOrUnregister(false,this);</b>
<b class="nc"><i>1171</i>&nbsp;                callback.onRequestComplete(device.getDevice());</b>
<b class="nc"><i>1172</i>&nbsp;                return null;</b>
<i>1173</i>&nbsp;            }
<i>1174</i>&nbsp;        });
<b class="fc"><i>1175</i>&nbsp;    }</b>
<i>1176</i>&nbsp;
<i>1177</i>&nbsp;    /**
<i>1178</i>&nbsp;     * Set the current bluetooth connection state to the value given in parameter
<i>1179</i>&nbsp;     * and notify the bluetooth manager of this change.
<i>1180</i>&nbsp;     * This method should be called :
<i>1181</i>&nbsp;     * - if something went wrong during the connection process
<i>1182</i>&nbsp;     * - or if the new state does not correspond to the state that follow the current state in chronological order ({@link BtState} enum order)
<i>1183</i>&nbsp;     * The updateConnectionState(boolean) method with no parameter should be call if nothing went wrong and user wants to continue the connection process
<i>1184</i>&nbsp;     */
<i>1185</i>&nbsp;    private void updateConnectionState(BtState state){
<b class="fc"><i>1186</i>&nbsp;        if(state != null &amp;&amp; !state.isAudioState() &amp;&amp; deviceTypeRequested != null &amp;&amp; (!isConnectionInterrupted || state.equals(BtState.CONNECTION_INTERRUPTED))){</b>
<b class="fc"><i>1187</i>&nbsp;            bluetoothForDataStreaming.notifyConnectionStateChanged(state);</b>
<i>1188</i>&nbsp;        }
<b class="fc"><i>1189</i>&nbsp;    }</b>
<i>1190</i>&nbsp;
<i>1191</i>&nbsp;    /**
<i>1192</i>&nbsp;     * Set the current bluetooth connection state to the value of the next step in chronological order (according to enum order)
<i>1193</i>&nbsp;     * and notify the bluetooth manager of this change.
<i>1194</i>&nbsp;     * This method should be called if no error occured.
<i>1195</i>&nbsp;     */
<i>1196</i>&nbsp;    public void updateConnectionState(boolean isCompleted){
<b class="fc"><i>1197</i>&nbsp;        BtState nextStep = getCurrentState().getNextConnectionStep();</b>
<b class="fc"><i>1198</i>&nbsp;        if(!isConnectionInterrupted)</b>
<b class="fc"><i>1199</i>&nbsp;            updateConnectionState(nextStep != BtState.IDLE ? nextStep : null);</b>
<i>1200</i>&nbsp;
<b class="fc"><i>1201</i>&nbsp;        if(isCompleted)</b>
<b class="fc"><i>1202</i>&nbsp;            asyncOperation.stopWaitingOperation(false);</b>
<b class="fc"><i>1203</i>&nbsp;    }</b>
<i>1204</i>&nbsp;
<i>1205</i>&nbsp;    /**
<i>1206</i>&nbsp;     * Return true if the user has requested connection with an already connected device, false otherwise
<i>1207</i>&nbsp;     */
<i>1208</i>&nbsp;    private boolean isAlreadyConnectedToRequestedDevice(String nameDeviceToConnect, MbtDevice deviceConnected){
<b class="nc"><i>1209</i>&nbsp;        return (nameDeviceToConnect != null &amp;&amp; deviceConnected != null &amp;&amp; deviceConnected.getExternalName().equals(nameDeviceToConnect));</b>
<i>1210</i>&nbsp;    }
<i>1211</i>&nbsp;
<i>1212</i>&nbsp;    /**
<i>1213</i>&nbsp;     * Tells whether or not the end-user device is currently connected to the headset in Low Energy.
<i>1214</i>&nbsp;     *
<i>1215</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if connected, &lt;code&gt;false&lt;/code&gt; otherwise
<i>1216</i>&nbsp;     */
<i>1217</i>&nbsp;    private boolean isDataBluetoothConnected() {
<b class="fc"><i>1218</i>&nbsp;        return bluetoothForDataStreaming.isConnected();</b>
<i>1219</i>&nbsp;    }
<i>1220</i>&nbsp;
<i>1221</i>&nbsp;    /**
<i>1222</i>&nbsp;     * Tells whether or not the end-user device is currently connected to the headset in A2DP.
<i>1223</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if connected, &lt;code&gt;false&lt;/code&gt; otherwise
<i>1224</i>&nbsp;     */
<i>1225</i>&nbsp;    private boolean isAudioBluetoothConnected() {
<b class="fc"><i>1226</i>&nbsp;        return bluetoothForAudioStreaming != null &amp;&amp; bluetoothForAudioStreaming.isConnected();</b>
<i>1227</i>&nbsp;    }
<i>1228</i>&nbsp;
<i>1229</i>&nbsp;    /**
<i>1230</i>&nbsp;     * Tells whether or not the end-user device is currently connected to the headset both in Low Energy and A2DP.
<i>1231</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if connected, &lt;code&gt;false&lt;/code&gt; otherwise
<i>1232</i>&nbsp;     */
<i>1233</i>&nbsp;    public final boolean isConnected() {
<b class="nc"><i>1234</i>&nbsp;        return (connectAudioIfDeviceCompatible ? (isDataBluetoothConnected() &amp;&amp; isAudioBluetoothConnected()) : isDataBluetoothConnected());</b>
<i>1235</i>&nbsp;    }
<i>1236</i>&nbsp;
<i>1237</i>&nbsp;    /**
<i>1238</i>&nbsp;     * Gets current state according to bluetooth protocol value
<i>1239</i>&nbsp;     */
<i>1240</i>&nbsp;    private BtState getCurrentState(){
<b class="fc"><i>1241</i>&nbsp;        return bluetoothForDataStreaming.getCurrentState();</b>
<i>1242</i>&nbsp;    }
<i>1243</i>&nbsp;
<i>1244</i>&nbsp;    public String getDeviceNameRequested() {
<b class="nc"><i>1245</i>&nbsp;        return deviceNameRequested;</b>
<i>1246</i>&nbsp;    }
<i>1247</i>&nbsp;
<i>1248</i>&nbsp;    private BluetoothDevice getCurrentDevice() {
<b class="nc"><i>1249</i>&nbsp;        return bluetoothForDataStreaming.currentDevice;</b>
<i>1250</i>&nbsp;
<i>1251</i>&nbsp;    }
<i>1252</i>&nbsp;
<i>1253</i>&nbsp;    void disconnectA2DPFromBLE() {
<b class="nc"><i>1254</i>&nbsp;        LogUtils.i(TAG, &quot; disconnect A2dp from ble&quot;);</b>
<b class="nc"><i>1255</i>&nbsp;        if(isDataBluetoothConnected() &amp;&amp; isAudioBluetoothConnected())</b>
<b class="nc"><i>1256</i>&nbsp;            sendCommand(new DeviceCommands.DisconnectAudio());</b>
<b class="nc"><i>1257</i>&nbsp;    }</b>
<i>1258</i>&nbsp;
<i>1259</i>&nbsp;    /**
<i>1260</i>&nbsp;     * Starts a Low Energy connection process if a Melomind is connected for Audio Streaming in A2DP.
<i>1261</i>&nbsp;     */
<i>1262</i>&nbsp;    private void connectBLEFromA2DP(@NonNull String newDeviceBleName) {
<b class="nc"><i>1263</i>&nbsp;        LogUtils.i(TAG, &quot;connect BLE from a2dp &quot;);</b>
<b class="nc"><i>1264</i>&nbsp;        if(isAudioBluetoothConnected()){</b>
<b class="nc"><i>1265</i>&nbsp;            BtState currentStateBeforeDisconnection = getCurrentState();</b>
<b class="nc"><i>1266</i>&nbsp;            if(bluetoothForDataStreaming.isConnected() &amp;&amp; !((MbtBluetoothLE)bluetoothForDataStreaming).isCurrentDeviceNameEqual(newDeviceBleName)) //Disconnecting another melomind if already one connected in BLE</b>
<b class="nc"><i>1267</i>&nbsp;                bluetoothForDataStreaming.disconnect();</b>
<i>1268</i>&nbsp;
<b class="nc"><i>1269</i>&nbsp;            deviceNameRequested = newDeviceBleName;</b>
<b class="nc"><i>1270</i>&nbsp;            if(!currentStateBeforeDisconnection.equals(BtState.IDLE)) {</b>
<i>1271</i>&nbsp;                try {
<b class="nc"><i>1272</i>&nbsp;                    asyncSwitchOperation.waitOperationResult(8000);</b>
<b class="nc"><i>1273</i>&nbsp;                }catch (CancellationException | InterruptedException | ExecutionException | TimeoutException e) {</b>
<b class="nc"><i>1274</i>&nbsp;                    LogUtils.w(TAG, &quot;Exception raised during disconnection &quot;+e);</b>
<b class="nc"><i>1275</i>&nbsp;                }</b>
<b class="nc"><i>1276</i>&nbsp;                MbtEventBus.postEvent(new StartOrContinueConnectionRequestEvent(false, deviceNameRequested, deviceQrCodeRequested, deviceTypeRequested, mtu)); //current state should be IDLE</b>
<i>1277</i>&nbsp;            }
<i>1278</i>&nbsp;        }
<b class="nc"><i>1279</i>&nbsp;    }</b>
<i>1280</i>&nbsp;
<i>1281</i>&nbsp;    private void setRequestAsProcessing(){
<b class="fc"><i>1282</i>&nbsp;        Log.d(TAG, &quot;Processing request&quot;);</b>
<b class="fc"><i>1283</i>&nbsp;        requestBeingProcessed = true;</b>
<b class="fc"><i>1284</i>&nbsp;    }</b>
<i>1285</i>&nbsp;
<i>1286</i>&nbsp;    private void setRequestAsProcessed() {
<b class="fc"><i>1287</i>&nbsp;        setRequestAsProcessed(true);</b>
<b class="fc"><i>1288</i>&nbsp;    }</b>
<i>1289</i>&nbsp;
<i>1290</i>&nbsp;    private void setRequestAsProcessed(boolean displayLog) {
<b class="fc"><i>1291</i>&nbsp;        if(displayLog)</b>
<b class="fc"><i>1292</i>&nbsp;            LogUtils.d(TAG, &quot;Request processed&quot;);</b>
<b class="fc"><i>1293</i>&nbsp;        requestBeingProcessed = false;</b>
<b class="fc"><i>1294</i>&nbsp;    }</b>
<i>1295</i>&nbsp;
<i>1296</i>&nbsp;    /**
<i>1297</i>&nbsp;     * Handle a request of an external unit to enable and disable the mobile device bluetooth
<i>1298</i>&nbsp;     * and reset the pairing keys of the previously connected device.
<i>1299</i>&nbsp;     * @param event the reset event that holds the name of the device previously connected
<i>1300</i>&nbsp;     */
<i>1301</i>&nbsp;    @Subscribe
<i>1302</i>&nbsp;    public void onResetBluetooth(ResetBluetoothEvent event) {
<b class="nc"><i>1303</i>&nbsp;        if (bluetoothForDataStreaming instanceof MbtBluetoothLE) {</b>
<b class="nc"><i>1304</i>&nbsp;            bluetoothForDataStreaming.resetMobileDeviceBluetoothAdapter();</b>
<b class="nc"><i>1305</i>&nbsp;            ((MbtBluetoothLE)bluetoothForDataStreaming).clearMobileDeviceCache();</b>
<b class="nc"><i>1306</i>&nbsp;            ((MbtBluetoothLE)bluetoothForDataStreaming).unpairDevice(getCurrentDevice());</b>
<i>1307</i>&nbsp;        }
<b class="nc"><i>1308</i>&nbsp;        MbtEventBus.postEvent(new BluetoothResponseEvent(DeviceCommandEvent.OTA_BLUETOOTH_RESET, null));</b>
<b class="nc"><i>1309</i>&nbsp;    }</b>
<i>1310</i>&nbsp;
<i>1311</i>&nbsp;    /**
<i>1312</i>&nbsp;     * Notify the event subscribers when a message/response of the headset device
<i>1313</i>&nbsp;     * is received by the Bluetooth unit
<i>1314</i>&nbsp;     */
<i>1315</i>&nbsp;    public void notifyEventReceived(DeviceCommandEvent eventIdentifier, Object eventData) {
<b class="nc"><i>1316</i>&nbsp;        MbtEventBus.postEvent(new BluetoothResponseEvent(eventIdentifier, eventData));</b>
<b class="nc"><i>1317</i>&nbsp;    }</b>
<i>1318</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2020-01-08 18:01</div>
</div>
</body>
</html>
