


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: MbtBluetoothLE</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">core.bluetooth.lowenergy</a> ]
</div>

<h1>Coverage Summary for Class: MbtBluetoothLE (core.bluetooth.lowenergy)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MbtBluetoothLE</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (27/ 45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    47.6%
  </span>
  <span class="absValue">
    (131/ 275)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MbtBluetoothLE$1</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10%
  </span>
  <span class="absValue">
    (1/ 10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothLE$1$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MbtBluetoothLE$2</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5.9%
  </span>
  <span class="absValue">
    (1/ 17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    54.7%
  </span>
  <span class="absValue">
    (29/ 53)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43.6%
  </span>
  <span class="absValue">
    (133/ 305)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;package core.bluetooth.lowenergy;
<i>2</i>&nbsp;
<i>3</i>&nbsp;
<i>4</i>&nbsp;import android.Manifest;
<i>5</i>&nbsp;import android.bluetooth.BluetoothDevice;
<i>6</i>&nbsp;import android.bluetooth.BluetoothGatt;
<i>7</i>&nbsp;import android.bluetooth.BluetoothGattCallback;
<i>8</i>&nbsp;import android.bluetooth.BluetoothGattCharacteristic;
<i>9</i>&nbsp;import android.bluetooth.BluetoothGattDescriptor;
<i>10</i>&nbsp;import android.bluetooth.le.BluetoothLeScanner;
<i>11</i>&nbsp;import android.bluetooth.le.ScanCallback;
<i>12</i>&nbsp;import android.bluetooth.le.ScanFilter;
<i>13</i>&nbsp;import android.bluetooth.le.ScanResult;
<i>14</i>&nbsp;import android.bluetooth.le.ScanSettings;
<i>15</i>&nbsp;import android.content.Context;
<i>16</i>&nbsp;import android.content.Intent;
<i>17</i>&nbsp;import android.os.Handler;
<i>18</i>&nbsp;import android.os.ParcelUuid;
<i>19</i>&nbsp;import android.support.annotation.NonNull;
<i>20</i>&nbsp;import android.util.Log;
<i>21</i>&nbsp;
<i>22</i>&nbsp;import java.lang.reflect.InvocationTargetException;
<i>23</i>&nbsp;import java.lang.reflect.Method;
<i>24</i>&nbsp;import java.util.ArrayList;
<i>25</i>&nbsp;import java.util.Arrays;
<i>26</i>&nbsp;import java.util.List;
<i>27</i>&nbsp;import java.util.UUID;
<i>28</i>&nbsp;
<i>29</i>&nbsp;import command.BluetoothCommands;
<i>30</i>&nbsp;import command.CommandInterface;
<i>31</i>&nbsp;import command.DeviceCommand;
<i>32</i>&nbsp;
<i>33</i>&nbsp;import command.DeviceCommandEvent;
<i>34</i>&nbsp;import command.OADCommands;
<i>35</i>&nbsp;import config.MbtConfig;
<i>36</i>&nbsp;import core.bluetooth.BtProtocol;
<i>37</i>&nbsp;import core.bluetooth.BtState;
<i>38</i>&nbsp;import core.bluetooth.BluetoothInterfaces;
<i>39</i>&nbsp;import core.bluetooth.MbtBluetoothManager;
<i>40</i>&nbsp;import core.bluetooth.MbtDataBluetooth;
<i>41</i>&nbsp;import core.bluetooth.StreamState;
<i>42</i>&nbsp;import core.device.model.DeviceInfo;
<i>43</i>&nbsp;import core.device.model.MelomindDevice;
<i>44</i>&nbsp;import core.device.model.MelomindsQRDataBase;
<i>45</i>&nbsp;import engine.clientevents.BaseError;
<i>46</i>&nbsp;import engine.clientevents.BluetoothError;
<i>47</i>&nbsp;import engine.clientevents.ConnectionStateReceiver;
<i>48</i>&nbsp;import features.MbtFeatures;
<i>49</i>&nbsp;import utils.BitUtils;
<i>50</i>&nbsp;import utils.BroadcastUtils;
<i>51</i>&nbsp;import utils.LogUtils;
<i>52</i>&nbsp;
<i>53</i>&nbsp;import static command.DeviceCommandEvent.CMD_CODE_CONNECT_IN_A2DP_JACK_CONNECTED;
<i>54</i>&nbsp;import static command.DeviceCommandEvent.CMD_CODE_CONNECT_IN_A2DP_SUCCESS;
<i>55</i>&nbsp;import static command.DeviceCommandEvent.MBX_CONNECT_IN_A2DP;
<i>56</i>&nbsp;
<i>57</i>&nbsp;/**
<i>58</i>&nbsp; *
<i>59</i>&nbsp; * This class contains all required methods to interact with a LE bluetooth peripheral, such as Melomind.
<i>60</i>&nbsp; *
<i>61</i>&nbsp; * &lt;p&gt;In order to work {@link Manifest.permission#BLUETOOTH} and {@link Manifest.permission#BLUETOOTH_ADMIN} permissions
<i>62</i>&nbsp; * are required &lt;/p&gt;
<i>63</i>&nbsp; *
<i>64</i>&nbsp; * Created by Etienne on 08/02/2018.
<i>65</i>&nbsp; *
<i>66</i>&nbsp; */
<i>67</i>&nbsp;
<b class="nc"><i>68</i>&nbsp;public class MbtBluetoothLE</b>
<i>69</i>&nbsp;        extends MbtDataBluetooth
<i>70</i>&nbsp;        implements BluetoothInterfaces.IDeviceInfoMonitor {
<i>71</i>&nbsp;
<b class="fc"><i>72</i>&nbsp;    private static final String TAG = MbtBluetoothLE.class.getSimpleName();</b>
<i>73</i>&nbsp;
<i>74</i>&nbsp;    private final static boolean START = true;
<i>75</i>&nbsp;    private final static boolean STOP = false;
<i>76</i>&nbsp;
<i>77</i>&nbsp;    private final static String CONNECT_GATT_METHOD = &quot;connectGatt&quot;;
<i>78</i>&nbsp;    private final static String REMOVE_BOND_METHOD = &quot;removeBond&quot;;
<i>79</i>&nbsp;    private final static String REFRESH_METHOD = &quot;refresh&quot;;
<i>80</i>&nbsp;
<i>81</i>&nbsp;    /**
<i>82</i>&nbsp;     * An internal event used to notify MbtBluetoothLE that A2DP has disconnected.
<i>83</i>&nbsp;     */
<i>84</i>&nbsp;
<i>85</i>&nbsp;    private MbtGattController mbtGattController;
<i>86</i>&nbsp;
<i>87</i>&nbsp;    private BluetoothLeScanner bluetoothLeScanner;
<i>88</i>&nbsp;
<i>89</i>&nbsp;    BluetoothGatt gatt;
<i>90</i>&nbsp;
<b class="fc"><i>91</i>&nbsp;    private ConnectionStateReceiver receiver = new ConnectionStateReceiver() {</b>
<i>92</i>&nbsp;        @Override
<b class="nc"><i>93</i>&nbsp;        public void onError(BaseError error, String additionalInfo) { }</b>
<i>94</i>&nbsp;
<i>95</i>&nbsp;        @Override
<i>96</i>&nbsp;        public void onReceive(Context context, Intent intent) {
<b class="nc"><i>97</i>&nbsp;            String action = intent.getAction();</b>
<b class="nc"><i>98</i>&nbsp;            if(action != null) {</b>
<b class="nc"><i>99</i>&nbsp;                final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</b>
<b class="nc"><i>100</i>&nbsp;                LogUtils.d(TAG, &quot;received intent &quot; + action + &quot; for device &quot; + (device != null ? device.getName() : null));</b>
<b class="nc"><i>101</i>&nbsp;                if (action.equals(BluetoothDevice.ACTION_BOND_STATE_CHANGED)){</b>
<b class="nc"><i>102</i>&nbsp;                    if (intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, 0) == BluetoothDevice.BOND_BONDED) {</b>
<b class="nc"><i>103</i>&nbsp;                        new Handler().postDelayed(new Runnable() {</b>
<i>104</i>&nbsp;                            @Override
<i>105</i>&nbsp;                            public void run() {
<b class="nc"><i>106</i>&nbsp;                                if (getCurrentState().equals(BtState.BONDING))</b>
<b class="nc"><i>107</i>&nbsp;                                    updateConnectionState(true); //current state is set to BONDED &amp; and future is completed</b>
<i>108</i>&nbsp;                            }
<i>109</i>&nbsp;                        }, 1000);
<i>110</i>&nbsp;                    }
<i>111</i>&nbsp;                }
<i>112</i>&nbsp;            }
<b class="nc"><i>113</i>&nbsp;        }</b>
<i>114</i>&nbsp;    };
<i>115</i>&nbsp;
<i>116</i>&nbsp;    /**
<i>117</i>&nbsp;     * callback used when scanning using bluetooth Low Energy scanner.
<i>118</i>&nbsp;     */
<b class="fc"><i>119</i>&nbsp;    @NonNull</b>
<b class="fc"><i>120</i>&nbsp;    private ScanCallback leScanCallback = new ScanCallback() {</b>
<i>121</i>&nbsp;
<i>122</i>&nbsp;        public void onScanResult(int callbackType, @NonNull ScanResult result) { //Callback when a BLE advertisement has been found.
<b class="nc"><i>123</i>&nbsp;            if(getCurrentState().equals(BtState.SCAN_STARTED)){</b>
<b class="nc"><i>124</i>&nbsp;                super.onScanResult(callbackType, result);</b>
<b class="nc"><i>125</i>&nbsp;                final BluetoothDevice device = result.getDevice();</b>
<b class="nc"><i>126</i>&nbsp;                LogUtils.i(TAG, String.format(&quot;Stopping Low Energy Scan -&gt; device detected &quot; + &quot;with name &#39;%s&#39; and MAC address &#39;%s&#39; &quot;, device.getName(), device.getAddress()));</b>
<b class="nc"><i>127</i>&nbsp;                currentDevice = device;</b>
<b class="nc"><i>128</i>&nbsp;                updateConnectionState(true); //current state is set to DEVICE_FOUND and future is completed</b>
<i>129</i>&nbsp;            }
<b class="nc"><i>130</i>&nbsp;        }</b>
<i>131</i>&nbsp;
<i>132</i>&nbsp;        public final void onScanFailed(final int errorCode) { //Callback when scan could not be started.
<b class="nc"><i>133</i>&nbsp;            super.onScanFailed(errorCode);</b>
<b class="nc"><i>134</i>&nbsp;            String msg = &quot;Could not start scan. Reason -&gt; &quot;;</b>
<b class="nc"><i>135</i>&nbsp;            if(errorCode == SCAN_FAILED_ALREADY_STARTED) {</b>
<b class="nc"><i>136</i>&nbsp;                msg += &quot;Scan already started!&quot;;</b>
<b class="nc"><i>137</i>&nbsp;                notifyConnectionStateChanged(BtState.SCAN_FAILED_ALREADY_STARTED);</b>
<i>138</i>&nbsp;            }else{
<b class="nc"><i>139</i>&nbsp;                msg += &quot;Scan failed. No more details.&quot;;</b>
<b class="nc"><i>140</i>&nbsp;                notifyConnectionStateChanged(BtState.SCAN_FAILURE);</b>
<i>141</i>&nbsp;            }
<b class="nc"><i>142</i>&nbsp;            LogUtils.e(TAG, msg);</b>
<b class="nc"><i>143</i>&nbsp;        }</b>
<i>144</i>&nbsp;    };
<i>145</i>&nbsp;
<i>146</i>&nbsp;
<i>147</i>&nbsp;    /**
<i>148</i>&nbsp;     * public constructor that will instanciate this class. It also instanciate a new
<i>149</i>&nbsp;     * {@link MbtGattController MbtGattController} instance
<i>150</i>&nbsp;     * @param context the application context
<i>151</i>&nbsp;     * @param mbtBluetoothManager the Bluetooth manager that performs requests and receives results.
<i>152</i>&nbsp;     */
<i>153</i>&nbsp;    public MbtBluetoothLE(@NonNull Context context, MbtBluetoothManager mbtBluetoothManager) {
<b class="fc"><i>154</i>&nbsp;        super(context, BtProtocol.BLUETOOTH_LE, mbtBluetoothManager);</b>
<b class="fc"><i>155</i>&nbsp;        this.mbtGattController = new MbtGattController(context, this);</b>
<b class="fc"><i>156</i>&nbsp;    }</b>
<i>157</i>&nbsp;
<i>158</i>&nbsp;    /**
<i>159</i>&nbsp;     * Start bluetooth low energy scanner in order to find BLE device that matches the specific filters.
<i>160</i>&nbsp;     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method will consume your mobile/tablet battery. Please consider calling
<i>161</i>&nbsp;     * {@link #stopScan()} when scanning is no longer needed.&lt;/p&gt;
<i>162</i>&nbsp;     * @return Each found device that matches the specified filters
<i>163</i>&nbsp;     */
<i>164</i>&nbsp;    @Override
<i>165</i>&nbsp;    public boolean startScan() {
<b class="fc"><i>166</i>&nbsp;        boolean filterOnDeviceService = true;</b>
<i>167</i>&nbsp;
<b class="fc"><i>168</i>&nbsp;        LogUtils.i(TAG,&quot; start low energy scan on device &quot;+mbtBluetoothManager.getDeviceNameRequested());</b>
<b class="fc"><i>169</i>&nbsp;        List&lt;ScanFilter&gt; mFilters = new ArrayList&lt;&gt;();</b>
<i>170</i>&nbsp;
<b class="fc"><i>171</i>&nbsp;        if (super.bluetoothAdapter == null || super.bluetoothAdapter.getBluetoothLeScanner() == null){</b>
<b class="fc"><i>172</i>&nbsp;            Log.e(TAG, &quot;Unable to get LE scanner&quot;);</b>
<b class="fc"><i>173</i>&nbsp;            notifyConnectionStateChanged(BtState.SCAN_FAILURE);</b>
<b class="fc"><i>174</i>&nbsp;            return false;</b>
<i>175</i>&nbsp;        }else
<b class="nc"><i>176</i>&nbsp;            this.bluetoothLeScanner = super.bluetoothAdapter.getBluetoothLeScanner();</b>
<i>177</i>&nbsp;
<b class="nc"><i>178</i>&nbsp;        currentDevice = null;</b>
<i>179</i>&nbsp;
<b class="nc"><i>180</i>&nbsp;        if (filterOnDeviceService) {</b>
<b class="nc"><i>181</i>&nbsp;            final ScanFilter.Builder filterService = new ScanFilter.Builder()</b>
<b class="nc"><i>182</i>&nbsp;                    .setServiceUuid(new ParcelUuid(MelomindCharacteristics.SERVICE_MEASUREMENT));</b>
<i>183</i>&nbsp;
<b class="nc"><i>184</i>&nbsp;            if(mbtBluetoothManager.getDeviceNameRequested() != null)</b>
<b class="nc"><i>185</i>&nbsp;                filterService.setDeviceName(mbtBluetoothManager.getDeviceNameRequested());</b>
<i>186</i>&nbsp;
<b class="nc"><i>187</i>&nbsp;            mFilters.add(filterService.build());</b>
<i>188</i>&nbsp;        }
<i>189</i>&nbsp;
<b class="nc"><i>190</i>&nbsp;        final ScanSettings settings = new ScanSettings.Builder()</b>
<b class="nc"><i>191</i>&nbsp;                .setReportDelay(0)</b>
<b class="nc"><i>192</i>&nbsp;                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)</b>
<b class="nc"><i>193</i>&nbsp;                .build();</b>
<i>194</i>&nbsp;
<b class="nc"><i>195</i>&nbsp;        LogUtils.i(TAG, String.format(&quot;Starting Low Energy Scan with filtering on name &#39;%s&#39; and service UUID &#39;%s&#39;&quot;, mbtBluetoothManager.getDeviceNameRequested(), MelomindCharacteristics.SERVICE_MEASUREMENT));</b>
<b class="nc"><i>196</i>&nbsp;        this.bluetoothLeScanner.startScan(mFilters, settings, this.leScanCallback);</b>
<b class="nc"><i>197</i>&nbsp;        if(getCurrentState().equals(BtState.READY_FOR_BLUETOOTH_OPERATION))</b>
<b class="nc"><i>198</i>&nbsp;            mbtBluetoothManager.updateConnectionState(false); //current state is set to SCAN_STARTED</b>
<b class="nc"><i>199</i>&nbsp;        return true; //true : scan is started</b>
<i>200</i>&nbsp;
<i>201</i>&nbsp;    }
<i>202</i>&nbsp;
<i>203</i>&nbsp;    /**
<i>204</i>&nbsp;     * Stops the currently bluetooth low energy scanner.
<i>205</i>&nbsp;     * If a lock is currently waiting, the lock is disabled.
<i>206</i>&nbsp;     */
<i>207</i>&nbsp;    @Override
<i>208</i>&nbsp;    public void stopScan() {
<b class="fc"><i>209</i>&nbsp;        LogUtils.i(TAG, &quot;Stopping Low Energy scan&quot;);</b>
<b class="fc"><i>210</i>&nbsp;        if(this.bluetoothLeScanner != null)</b>
<b class="nc"><i>211</i>&nbsp;            this.bluetoothLeScanner.stopScan(this.leScanCallback);</b>
<b class="fc"><i>212</i>&nbsp;        if(!getCurrentState().equals(BtState.DEVICE_FOUND) &amp;&amp; !getCurrentState().equals(BtState.DATA_BT_CONNECTING))</b>
<b class="fc"><i>213</i>&nbsp;            currentDevice = null;</b>
<b class="fc"><i>214</i>&nbsp;    }</b>
<i>215</i>&nbsp;
<i>216</i>&nbsp;    /**
<i>217</i>&nbsp;     * This method sends a request to the headset to &lt;strong&gt;&lt;code&gt;START&lt;/code&gt;&lt;/strong&gt;
<i>218</i>&nbsp;     * the EEG raw data acquisition process and
<i>219</i>&nbsp;     * enables Bluetooth Low Energy notification to receive the raw data.
<i>220</i>&nbsp;     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; calling this method will start the raw EEG data acquisition process
<i>221</i>&nbsp;     * on the headset which will &lt;strong&gt;consume battery life&lt;/strong&gt;. Please consider calling
<i>222</i>&nbsp;     * {@link #stopStream()} when EEG raw data are no longer needed.&lt;/p&gt;
<i>223</i>&nbsp;     *
<i>224</i>&nbsp;     * If there is already a streaming session in progress, nothing happens and true is returned.
<i>225</i>&nbsp;     *
<i>226</i>&nbsp;     * @return              &lt;code&gt;true&lt;/code&gt; if request has been sent correctly
<i>227</i>&nbsp;     *                      &lt;code&gt;false&lt;/code&gt; on immediate error
<i>228</i>&nbsp;     */
<i>229</i>&nbsp;    @Override
<i>230</i>&nbsp;    public synchronized boolean startStream() {
<b class="fc"><i>231</i>&nbsp;        return switchStream(START);</b>
<i>232</i>&nbsp;    }
<i>233</i>&nbsp;
<i>234</i>&nbsp;    /**
<i>235</i>&nbsp;     * Enable notifications on HeadsetStatus characteristic in order to have the saturation and DC Offset values
<i>236</i>&nbsp;     */
<i>237</i>&nbsp;    public boolean activateDeviceStatusMonitoring(){
<b class="fc"><i>238</i>&nbsp;        if (!checkServiceAndCharacteristicValidity(MelomindCharacteristics.SERVICE_MEASUREMENT, MelomindCharacteristics.CHARAC_HEADSET_STATUS))</b>
<b class="fc"><i>239</i>&nbsp;            return false;</b>
<i>240</i>&nbsp;
<b class="nc"><i>241</i>&nbsp;        return enableOrDisableNotificationsOnCharacteristic(true, gatt.getService(MelomindCharacteristics.SERVICE_MEASUREMENT).getCharacteristic(MelomindCharacteristics.CHARAC_HEADSET_STATUS));</b>
<i>242</i>&nbsp;    }
<i>243</i>&nbsp;
<i>244</i>&nbsp;
<i>245</i>&nbsp;    /**
<i>246</i>&nbsp;     * This method sends a request to the headset to &lt;strong&gt;&lt;code&gt;STOP&lt;/code&gt;&lt;/strong&gt;
<i>247</i>&nbsp;     * the EEG raw data acquisition process, therefore disabling the Bluetooth Low Energy notification
<i>248</i>&nbsp;     * and cleaning reference to previously registered listener.
<i>249</i>&nbsp;     * &lt;p&gt;Calling this method will &lt;strong&gt;preserve battery life&lt;/strong&gt; by halting the raw EEG
<i>250</i>&nbsp;     * data acquisition process on the headset.&lt;/p&gt;
<i>251</i>&nbsp;     *
<i>252</i>&nbsp;     * If there is no streaming session in progress, nothing happens and true is returned.
<i>253</i>&nbsp;     *
<i>254</i>&nbsp;     * @return true upon correct EEG disability request, false on immediate error
<i>255</i>&nbsp;     */
<i>256</i>&nbsp;    @Override
<i>257</i>&nbsp;    public boolean stopStream() {
<b class="fc"><i>258</i>&nbsp;        return switchStream(STOP);</b>
<i>259</i>&nbsp;    }
<i>260</i>&nbsp;
<i>261</i>&nbsp;    /**
<i>262</i>&nbsp;     * This method sends a request to the headset to &lt;strong&gt;&lt;code&gt;START&lt;/code&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;STOP&lt;/code&gt;&lt;/strong&gt;
<i>263</i>&nbsp;     * the EEG raw data acquisition process and
<i>264</i>&nbsp;     * &lt;strong&gt;&lt;code&gt;ENABLES&lt;/code&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;DISABLED&lt;/code&gt;&lt;/strong&gt;
<i>265</i>&nbsp;     * Bluetooth Low Energy notification to receive the raw data.
<i>266</i>&nbsp;     * If there is already a streaming session started or stopped, nothing happens and true is returned.
<i>267</i>&nbsp;     *
<i>268</i>&nbsp;     * @return              &lt;code&gt;true&lt;/code&gt; if request has been sent correctly
<i>269</i>&nbsp;     *                      &lt;code&gt;false&lt;/code&gt; on immediate error
<i>270</i>&nbsp;     */
<i>271</i>&nbsp;    private boolean switchStream(boolean isStart) {
<b class="fc"><i>272</i>&nbsp;        if(isStreaming() == isStart)</b>
<b class="fc"><i>273</i>&nbsp;            return true;</b>
<i>274</i>&nbsp;
<b class="fc"><i>275</i>&nbsp;        if(!checkServiceAndCharacteristicValidity(MelomindCharacteristics.SERVICE_MEASUREMENT, MelomindCharacteristics.CHARAC_MEASUREMENT_EEG))</b>
<b class="fc"><i>276</i>&nbsp;            return false;</b>
<i>277</i>&nbsp;
<i>278</i>&nbsp;        try {
<b class="fc"><i>279</i>&nbsp;            Thread.sleep(50); //Adding small sleep to &quot;free&quot; bluetooth</b>
<b class="nc"><i>280</i>&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc"><i>281</i>&nbsp;            e.printStackTrace();</b>
<b class="fc"><i>282</i>&nbsp;        }</b>
<i>283</i>&nbsp;
<b class="fc"><i>284</i>&nbsp;        return enableOrDisableNotificationsOnCharacteristic(isStart,</b>
<b class="fc"><i>285</i>&nbsp;                gatt.getService(MelomindCharacteristics.SERVICE_MEASUREMENT)</b>
<b class="fc"><i>286</i>&nbsp;                        .getCharacteristic(MelomindCharacteristics.CHARAC_MEASUREMENT_EEG));</b>
<i>287</i>&nbsp;    }
<i>288</i>&nbsp;
<i>289</i>&nbsp;
<i>290</i>&nbsp;    /**
<i>291</i>&nbsp;     * Whenever there is a new headset status received, this method is called to notify the bluetooth manager about it.
<i>292</i>&nbsp;     * @param payload the new headset status as a raw byte array. This byte array has to be parsed afterward.
<i>293</i>&nbsp;     */
<i>294</i>&nbsp;    void notifyNewHeadsetStatus(byte[] payload){
<b class="nc"><i>295</i>&nbsp;        this.mbtBluetoothManager.notifyNewHeadsetStatus(payload);</b>
<b class="nc"><i>296</i>&nbsp;    }</b>
<i>297</i>&nbsp;
<i>298</i>&nbsp;    /**
<i>299</i>&nbsp;     * Enable or disable notifications on specific characteristic provinding this characteristic is &quot;notification ready&quot;.
<i>300</i>&nbsp;     * @param enableNotification enabling if set to true, false otherwise
<i>301</i>&nbsp;     * @param characteristic the characteristic to enable or disable notification on.
<i>302</i>&nbsp;     *
<i>303</i>&nbsp;     * This operation is synchronous, meaning the thread running this method is blocked until the operation completes.
<i>304</i>&nbsp;     * @return  &lt;code&gt;true&lt;/code&gt; if the notification has been successfully established within the 2 seconds of allotted time,
<i>305</i>&nbsp;     * or &lt;code&gt;false&lt;/code&gt; for any error
<i>306</i>&nbsp;     */
<i>307</i>&nbsp;    synchronized boolean enableOrDisableNotificationsOnCharacteristic(boolean enableNotification, @NonNull BluetoothGattCharacteristic characteristic) {
<b class="fc"><i>308</i>&nbsp;        if(!isConnected() &amp;&amp; !getCurrentState().equals(BtState.SENDIND_QR_CODE))</b>
<b class="fc"><i>309</i>&nbsp;            return false;</b>
<i>310</i>&nbsp;
<b class="fc"><i>311</i>&nbsp;        LogUtils.i(TAG, &quot;Now enabling local notification for characteristic: &quot; + characteristic.getUuid());</b>
<b class="fc"><i>312</i>&nbsp;        if (!this.gatt.setCharacteristicNotification(characteristic, enableNotification)) {</b>
<b class="fc"><i>313</i>&nbsp;            LogUtils.e(TAG, &quot;Failed to enable local notification for characteristic: &quot; + characteristic.getUuid());</b>
<b class="fc"><i>314</i>&nbsp;            return false;</b>
<i>315</i>&nbsp;        }
<i>316</i>&nbsp;
<b class="fc"><i>317</i>&nbsp;        final BluetoothGattDescriptor notificationDescriptor =</b>
<b class="fc"><i>318</i>&nbsp;                characteristic.getDescriptor(MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID);</b>
<b class="fc"><i>319</i>&nbsp;        if (notificationDescriptor == null) {</b>
<b class="nc"><i>320</i>&nbsp;            LogUtils.e(TAG, String.format(&quot;Error: characteristic with &quot; +</b>
<i>321</i>&nbsp;                            &quot;UUID &lt;%s&gt; does not have a descriptor (UUID &lt;%s&gt;) to enable notification remotely!&quot;,
<b class="nc"><i>322</i>&nbsp;                    characteristic.getUuid().toString(), MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID.toString()));</b>
<b class="nc"><i>323</i>&nbsp;            return false;</b>
<i>324</i>&nbsp;        }
<i>325</i>&nbsp;
<b class="fc"><i>326</i>&nbsp;        LogUtils.i(TAG, &quot;Now enabling remote notification for characteristic: &quot; + characteristic.getUuid());</b>
<b class="fc"><i>327</i>&nbsp;        if (!notificationDescriptor.setValue(enableNotification ?</b>
<i>328</i>&nbsp;                BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE :
<i>329</i>&nbsp;                BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE)) {
<b class="nc"><i>330</i>&nbsp;            final StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>331</i>&nbsp;            for (final byte value : enableNotification ?</b>
<i>332</i>&nbsp;                    BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE :
<i>333</i>&nbsp;                    BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE) {
<b class="nc"><i>334</i>&nbsp;                sb.append(value);</b>
<b class="nc"><i>335</i>&nbsp;                sb.append(&#39;;&#39;);</b>
<i>336</i>&nbsp;            }
<b class="nc"><i>337</i>&nbsp;            LogUtils.e(TAG, String.format(&quot;Error: characteristic&#39;s notification descriptor with &quot; +</b>
<i>338</i>&nbsp;                            &quot;UUID &lt;%s&gt; could not store the ENABLE notification value &lt;%s&gt;.&quot;,
<b class="nc"><i>339</i>&nbsp;                    MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID.toString(), sb.toString()));</b>
<b class="nc"><i>340</i>&nbsp;            return false;</b>
<i>341</i>&nbsp;        }
<i>342</i>&nbsp;
<i>343</i>&nbsp;        try {
<b class="fc"><i>344</i>&nbsp;            Thread.sleep(1000);</b>
<b class="nc"><i>345</i>&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc"><i>346</i>&nbsp;            e.printStackTrace();</b>
<b class="fc"><i>347</i>&nbsp;        }</b>
<i>348</i>&nbsp;
<b class="fc"><i>349</i>&nbsp;        if (!this.gatt.writeDescriptor(notificationDescriptor)) {</b>
<b class="nc"><i>350</i>&nbsp;            LogUtils.e(TAG, &quot;Error: failed to initiate write descriptor operation in order to remotely &quot; +</b>
<b class="nc"><i>351</i>&nbsp;                    &quot;enable notification for characteristic: &quot; + characteristic.getUuid());</b>
<b class="nc"><i>352</i>&nbsp;            return false;</b>
<i>353</i>&nbsp;        }
<i>354</i>&nbsp;
<b class="fc"><i>355</i>&nbsp;        LogUtils.i(TAG, &quot;Successfully initiated write descriptor operation in order to remotely &quot; +</b>
<i>356</i>&nbsp;                &quot;enable notification... now waiting for confirmation from headset.&quot;);
<i>357</i>&nbsp;
<b class="fc"><i>358</i>&nbsp;        Boolean result = (Boolean) startWaitingOperation(MbtConfig.getBluetoothA2DpConnectionTimeout());</b>
<b class="fc"><i>359</i>&nbsp;        return result == null ? false : result;</b>
<i>360</i>&nbsp;
<i>361</i>&nbsp;    }
<i>362</i>&nbsp;
<i>363</i>&nbsp;    /**
<i>364</i>&nbsp;     * This method removes bonding of the device.
<i>365</i>&nbsp;     */
<i>366</i>&nbsp;    public void unpairDevice(BluetoothDevice device) {
<i>367</i>&nbsp;        try {
<b class="nc"><i>368</i>&nbsp;            Method m = device.getClass()</b>
<b class="nc"><i>369</i>&nbsp;                    .getMethod(REMOVE_BOND_METHOD, (Class[]) null);</b>
<b class="nc"><i>370</i>&nbsp;            m.invoke(device, (Object[]) null);</b>
<b class="nc"><i>371</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i>372</i>&nbsp;            Log.e(TAG, e.getMessage());</b>
<b class="nc"><i>373</i>&nbsp;        }</b>
<b class="nc"><i>374</i>&nbsp;    }</b>
<i>375</i>&nbsp;
<i>376</i>&nbsp;    /**
<i>377</i>&nbsp;     * Starts the connect operation in order to connect the {@link BluetoothDevice bluetooth device} (peripheral)
<i>378</i>&nbsp;     * to the terminal (central).
<i>379</i>&nbsp;     * If the operation starts successfully, a new {@link BluetoothGatt gatt} instance will be stored.
<i>380</i>&nbsp;     * @param context the context which the connection event takes place in.
<i>381</i>&nbsp;     * @param device the bluetooth device to connect to.
<i>382</i>&nbsp;     * @return true if operation has correctly started, false otherwise.
<i>383</i>&nbsp;     */
<i>384</i>&nbsp;    @Override
<i>385</i>&nbsp;    public boolean connect(Context context, BluetoothDevice device) {
<b class="fc"><i>386</i>&nbsp;        if(device == null || context == null)</b>
<b class="fc"><i>387</i>&nbsp;            return false;</b>
<b class="fc"><i>388</i>&nbsp;        LogUtils.i(TAG,&quot; connect in Low Energy &quot;+device.getName()+&quot; address is &quot;+device.getAddress());</b>
<b class="fc"><i>389</i>&nbsp;        BroadcastUtils.registerReceiverIntents(context, receiver, BluetoothDevice.ACTION_BOND_STATE_CHANGED);</b>
<i>390</i>&nbsp;
<i>391</i>&nbsp;        //Using reflexion here because min API is 21 and transport layer is not available publicly until API 23
<i>392</i>&nbsp;        try {
<b class="fc"><i>393</i>&nbsp;            final Method connectGattMethod = device.getClass()</b>
<b class="fc"><i>394</i>&nbsp;                    .getMethod(CONNECT_GATT_METHOD,</b>
<i>395</i>&nbsp;                            Context.class, boolean.class, BluetoothGattCallback.class, int.class);
<i>396</i>&nbsp;
<b class="fc"><i>397</i>&nbsp;            final int transport = device.getClass().getDeclaredField(&quot;TRANSPORT_LE&quot;).getInt(null);</b>
<b class="fc"><i>398</i>&nbsp;            this.gatt = (BluetoothGatt) connectGattMethod.invoke(device, context, false, mbtGattController, transport);</b>
<b class="fc"><i>399</i>&nbsp;            return true;</b>
<i>400</i>&nbsp;
<b class="nc"><i>401</i>&nbsp;        } catch (@NonNull final NoSuchMethodException | NoSuchFieldException | IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc"><i>402</i>&nbsp;            final String errorMsg = &quot; -&gt; &quot; + e.getMessage();</b>
<b class="nc"><i>403</i>&nbsp;            if (e instanceof NoSuchMethodException)</b>
<b class="nc"><i>404</i>&nbsp;                LogUtils.e(TAG, &quot;Failed to find connectGatt method via reflexion&quot; + errorMsg);</b>
<b class="nc"><i>405</i>&nbsp;            else if (e instanceof NoSuchFieldException)</b>
<b class="nc"><i>406</i>&nbsp;                LogUtils.e(TAG, &quot;Failed to find Transport LE field via reflexion&quot; + errorMsg);</b>
<b class="nc"><i>407</i>&nbsp;            else if (e instanceof IllegalAccessException)</b>
<b class="nc"><i>408</i>&nbsp;                LogUtils.e(TAG, &quot;Failed to access Transport LE field via reflexion&quot; + errorMsg);</b>
<i>409</i>&nbsp;            else
<b class="nc"><i>410</i>&nbsp;                LogUtils.e(TAG, &quot;Failed to invoke connectGatt method via reflexion&quot; + errorMsg);</b>
<b class="nc"><i>411</i>&nbsp;            Log.getStackTraceString(e);</b>
<i>412</i>&nbsp;        }
<b class="nc"><i>413</i>&nbsp;        return false;</b>
<i>414</i>&nbsp;    }
<i>415</i>&nbsp;
<i>416</i>&nbsp;
<i>417</i>&nbsp;    /**
<i>418</i>&nbsp;     * Disconnects from the currently connected {@link BluetoothGatt gatt instance} and sets it to null
<i>419</i>&nbsp;     */
<i>420</i>&nbsp;    @Override
<i>421</i>&nbsp;    public boolean disconnect() {
<b class="fc"><i>422</i>&nbsp;        LogUtils.i(TAG, &quot;Disconnect in low energy&quot;);</b>
<b class="fc"><i>423</i>&nbsp;        if(this.gatt != null){</b>
<b class="fc"><i>424</i>&nbsp;            this.gatt.disconnect();</b>
<i>425</i>&nbsp;        }
<b class="fc"><i>426</i>&nbsp;        this.gatt = null;</b>
<b class="fc"><i>427</i>&nbsp;        return false;</b>
<i>428</i>&nbsp;    }
<i>429</i>&nbsp;
<i>430</i>&nbsp;    public boolean isCurrentDeviceNameEqual(String deviceName){
<b class="nc"><i>431</i>&nbsp;        return (gatt != null &amp;&amp; gatt.getDevice() != null &amp;&amp; gatt.getDevice().getName().equals(deviceName));</b>
<i>432</i>&nbsp;    }
<i>433</i>&nbsp;
<i>434</i>&nbsp;    public String getBleDeviceNameFromA2dp(String deviceName, Context mContext){
<b class="nc"><i>435</i>&nbsp;        return MelomindDevice.isDeviceNameValidForMelomind(deviceName) ?</b>
<b class="nc"><i>436</i>&nbsp;                deviceName.replace(MbtFeatures.A2DP_DEVICE_NAME_PREFIX, MbtFeatures.MELOMIND_DEVICE_NAME_PREFIX) : //audio_ prefix is replaced by a melo_ prefix</b>
<b class="nc"><i>437</i>&nbsp;                new MelomindsQRDataBase(mContext,  true).get(deviceName);</b>
<i>438</i>&nbsp;    }
<i>439</i>&nbsp;
<i>440</i>&nbsp;    @Override
<i>441</i>&nbsp;    public boolean isConnected() {
<b class="fc"><i>442</i>&nbsp;        return (getCurrentState() == BtState.CONNECTED_AND_READY || getCurrentState() == BtState.CONNECTED);</b>
<i>443</i>&nbsp;    }
<i>444</i>&nbsp;
<i>445</i>&nbsp;
<i>446</i>&nbsp;    public boolean isConnectedDeviceReadyForCommand() {
<b class="fc"><i>447</i>&nbsp;        return (getCurrentState().ordinal() &gt;= BtState.DATA_BT_CONNECTION_SUCCESS.ordinal());</b>
<i>448</i>&nbsp;    }
<i>449</i>&nbsp;
<i>450</i>&nbsp;    /**
<i>451</i>&nbsp;     * Starts a read operation on a specific characteristic
<i>452</i>&nbsp;     * @param characteristic the characteristic to read
<i>453</i>&nbsp;     * @return immediatly false on error, true true if read operation has st
<i>454</i>&nbsp;     * arted correctly
<i>455</i>&nbsp;     */
<i>456</i>&nbsp;    boolean startReadOperation(@NonNull UUID characteristic){
<b class="fc"><i>457</i>&nbsp;        if(!isConnected() &amp;&amp; !getCurrentState().equals(BtState.DISCOVERING_SUCCESS) &amp;&amp; !getCurrentState().isReadingDeviceInfoState() &amp;&amp; !getCurrentState().equals(BtState.BONDING)) {</b>
<b class="fc"><i>458</i>&nbsp;            notifyConnectionStateChanged( getCurrentState().equals(BtState.BONDING) ?</b>
<i>459</i>&nbsp;                    BtState.BONDING_FAILURE : BtState.READING_FAILURE);
<b class="fc"><i>460</i>&nbsp;            return false;</b>
<i>461</i>&nbsp;        }
<b class="nc"><i>462</i>&nbsp;        UUID service = (characteristic.equals(MelomindCharacteristics.CHARAC_INFO_FIRMWARE_VERSION)</b>
<b class="nc"><i>463</i>&nbsp;                || characteristic.equals(MelomindCharacteristics.CHARAC_INFO_HARDWARE_VERSION)</b>
<b class="nc"><i>464</i>&nbsp;                || characteristic.equals(MelomindCharacteristics.CHARAC_INFO_SERIAL_NUMBER)</b>
<b class="nc"><i>465</i>&nbsp;                || characteristic.equals(MelomindCharacteristics.CHARAC_INFO_MODEL_NUMBER)) ?</b>
<i>466</i>&nbsp;                MelomindCharacteristics.SERVICE_DEVICE_INFOS : MelomindCharacteristics.SERVICE_MEASUREMENT;
<i>467</i>&nbsp;
<b class="nc"><i>468</i>&nbsp;        if(!checkServiceAndCharacteristicValidity(service, characteristic)) {</b>
<b class="nc"><i>469</i>&nbsp;            notifyConnectionStateChanged( getCurrentState().equals(BtState.BONDING) ?</b>
<i>470</i>&nbsp;                    BtState.BONDING_FAILURE : BtState.READING_FAILURE);
<b class="nc"><i>471</i>&nbsp;            return false;</b>
<i>472</i>&nbsp;        }
<i>473</i>&nbsp;
<b class="nc"><i>474</i>&nbsp;        if (!this.gatt.readCharacteristic(gatt.getService(service).getCharacteristic(characteristic))) {</b>
<b class="nc"><i>475</i>&nbsp;            LogUtils.e(TAG, &quot;Error: failed to initiate read characteristic operation&quot;);</b>
<b class="nc"><i>476</i>&nbsp;            if(getCurrentState().equals(BtState.BONDING) || getCurrentState().isReadingDeviceInfoState())</b>
<b class="nc"><i>477</i>&nbsp;                notifyConnectionStateChanged( getCurrentState().equals(BtState.BONDING) ? // bonding is triggered by a reading battery operation</b>
<i>478</i>&nbsp;                        BtState.BONDING_FAILURE : BtState.READING_FAILURE);
<b class="nc"><i>479</i>&nbsp;            return false;</b>
<i>480</i>&nbsp;        }
<i>481</i>&nbsp;        //if(getCurrentState().isReadingDeviceInfoState())
<i>482</i>&nbsp;
<b class="nc"><i>483</i>&nbsp;        LogUtils.i(TAG, &quot;Successfully initiated read characteristic operation&quot;);</b>
<b class="nc"><i>484</i>&nbsp;        return true;</b>
<i>485</i>&nbsp;    }
<i>486</i>&nbsp;
<i>487</i>&nbsp;    /**
<i>488</i>&nbsp;     * Starts a write operation on a specific characteristic
<i>489</i>&nbsp;     * @param characteristic the characteristic to perform write operation on
<i>490</i>&nbsp;     * @param payload the payload to write to the characteristic
<i>491</i>&nbsp;     * @return immediatly false on error, true otherwise
<i>492</i>&nbsp;     */
<i>493</i>&nbsp;    synchronized boolean startWriteOperation(@NonNull UUID service, @NonNull UUID characteristic, byte[] payload){
<b class="fc"><i>494</i>&nbsp;        if(!checkServiceAndCharacteristicValidity(service, characteristic)) {</b>
<b class="fc"><i>495</i>&nbsp;            LogUtils.e(TAG, &quot;Error: failed to check service and characteristic validity&quot; + characteristic.toString());</b>
<b class="fc"><i>496</i>&nbsp;            return false;</b>
<i>497</i>&nbsp;        }
<i>498</i>&nbsp;
<i>499</i>&nbsp;        //Send buffer
<b class="fc"><i>500</i>&nbsp;        this.gatt.getService(service).getCharacteristic(characteristic).setValue(payload);</b>
<i>501</i>&nbsp;        //Log.d(TAG, &quot;write &quot;+ Arrays.toString(gatt.getService(service).getCharacteristic(characteristic).getValue()));
<b class="fc"><i>502</i>&nbsp;        if (!this.gatt.writeCharacteristic(gatt.getService(service).getCharacteristic(characteristic))) { //the mbtgattcontroller onCharacteristicWrite callback is invoked, reporting the result of the operation.</b>
<b class="fc"><i>503</i>&nbsp;            LogUtils.e(TAG, &quot;Error: failed to write characteristic &quot; + characteristic.toString());</b>
<b class="fc"><i>504</i>&nbsp;            return false;</b>
<i>505</i>&nbsp;        }
<i>506</i>&nbsp;
<b class="fc"><i>507</i>&nbsp;        return true;</b>
<i>508</i>&nbsp;    }
<i>509</i>&nbsp;
<i>510</i>&nbsp;
<i>511</i>&nbsp;    /**
<i>512</i>&nbsp;     * Checks whether the service and characteristic about to be used to communicate with the remote device.
<i>513</i>&nbsp;     * @param service the service to check
<i>514</i>&nbsp;     * @param characteristic the characteristic to check
<i>515</i>&nbsp;     * @return false if something not valid, true otherwise
<i>516</i>&nbsp;     */
<i>517</i>&nbsp;    boolean checkServiceAndCharacteristicValidity(@NonNull UUID service, @NonNull UUID characteristic){
<b class="fc"><i>518</i>&nbsp;        return gatt != null &amp;&amp;</b>
<b class="fc"><i>519</i>&nbsp;                gatt.getService(service) != null &amp;&amp;</b>
<b class="fc"><i>520</i>&nbsp;                gatt.getService(service).getCharacteristic(characteristic) != null;</b>
<i>521</i>&nbsp;    }
<i>522</i>&nbsp;
<i>523</i>&nbsp;    /**
<i>524</i>&nbsp;     * Checks if the charateristic has notifications already enabled or not.
<i>525</i>&nbsp;     * @param service the Service UUID that holds the characteristic
<i>526</i>&nbsp;     * @param characteristic the characteristic UUID.
<i>527</i>&nbsp;     * @return true is already enabled notifications, false otherwise.
<i>528</i>&nbsp;     */
<i>529</i>&nbsp;    boolean isNotificationEnabledOnCharacteristic(@NonNull UUID service, @NonNull UUID characteristic){
<b class="fc"><i>530</i>&nbsp;        if(!checkServiceAndCharacteristicValidity(service, characteristic))</b>
<b class="fc"><i>531</i>&nbsp;            return false;</b>
<i>532</i>&nbsp;
<b class="fc"><i>533</i>&nbsp;        if(this.gatt.getService(service).getCharacteristic(characteristic).getDescriptor(MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID) == null)</b>
<b class="nc"><i>534</i>&nbsp;            return false;</b>
<i>535</i>&nbsp;
<b class="fc"><i>536</i>&nbsp;        return Arrays.equals(this.gatt.getService(service).getCharacteristic(characteristic).getDescriptor(MelomindCharacteristics.NOTIFICATION_DESCRIPTOR_UUID).getValue(), BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);</b>
<i>537</i>&nbsp;    }
<i>538</i>&nbsp;
<i>539</i>&nbsp;    /**
<i>540</i>&nbsp;     * Initiates a read battery operation on this correct BtProtocol
<i>541</i>&nbsp;     */
<i>542</i>&nbsp;    public boolean readBattery() {
<b class="fc"><i>543</i>&nbsp;        LogUtils.i(TAG, &quot;read battery&quot;);</b>
<b class="fc"><i>544</i>&nbsp;        return startReadOperation(MelomindCharacteristics.CHARAC_MEASUREMENT_BATTERY_LEVEL);</b>
<i>545</i>&nbsp;    }
<i>546</i>&nbsp;
<i>547</i>&nbsp;    /**
<i>548</i>&nbsp;     * Initiates a read firmware version operation on this correct BtProtocol
<i>549</i>&nbsp;     */
<i>550</i>&nbsp;    public boolean readFwVersion(){
<b class="fc"><i>551</i>&nbsp;        LogUtils.i(TAG, &quot;read firmware version&quot;);</b>
<b class="fc"><i>552</i>&nbsp;        return startReadOperation(MelomindCharacteristics.CHARAC_INFO_FIRMWARE_VERSION);</b>
<i>553</i>&nbsp;    }
<i>554</i>&nbsp;    /**
<i>555</i>&nbsp;     * Initiates a read hardware version operation on this correct BtProtocol
<i>556</i>&nbsp;     */
<i>557</i>&nbsp;    public boolean readHwVersion(){
<b class="fc"><i>558</i>&nbsp;        LogUtils.i(TAG, &quot;read hardware version&quot;);</b>
<b class="fc"><i>559</i>&nbsp;        return startReadOperation(MelomindCharacteristics.CHARAC_INFO_HARDWARE_VERSION);</b>
<i>560</i>&nbsp;    }
<i>561</i>&nbsp;
<i>562</i>&nbsp;    /**
<i>563</i>&nbsp;     * Initiates a read serial number operation on this correct BtProtocol
<i>564</i>&nbsp;     */
<i>565</i>&nbsp;    public boolean readSerialNumber(){
<b class="fc"><i>566</i>&nbsp;        LogUtils.i(TAG, &quot;read serial number requested&quot;);</b>
<b class="fc"><i>567</i>&nbsp;        return startReadOperation(MelomindCharacteristics.CHARAC_INFO_SERIAL_NUMBER);</b>
<i>568</i>&nbsp;    }
<i>569</i>&nbsp;
<i>570</i>&nbsp;    /**
<i>571</i>&nbsp;     * Initiates a read model number operation on this correct BtProtocol
<i>572</i>&nbsp;     */
<i>573</i>&nbsp;    public boolean readModelNumber(){
<b class="nc"><i>574</i>&nbsp;        LogUtils.i(TAG, &quot;read product name&quot;);</b>
<b class="nc"><i>575</i>&nbsp;        return startReadOperation(MelomindCharacteristics.CHARAC_INFO_MODEL_NUMBER);</b>
<i>576</i>&nbsp;    }
<i>577</i>&nbsp;
<i>578</i>&nbsp;    /**
<i>579</i>&nbsp;     * Callback called by the {@link MbtGattController gatt controller} when the notification state has changed.
<i>580</i>&nbsp;     * @param isSuccess if the modification state is correctly changed
<i>581</i>&nbsp;     * @param characteristic the characteristic which had its notification state changed
<i>582</i>&nbsp;     * @param wasEnableRequest if the request was to enable (true) or disable (false) request.
<i>583</i>&nbsp;     */
<i>584</i>&nbsp;    void onNotificationStateChanged(boolean isSuccess, BluetoothGattCharacteristic characteristic, boolean wasEnableRequest) {
<b class="fc"><i>585</i>&nbsp;        if(MelomindCharacteristics.CHARAC_MEASUREMENT_EEG.equals(characteristic.getUuid())){</b>
<b class="nc"><i>586</i>&nbsp;            if(wasEnableRequest &amp;&amp; isSuccess){</b>
<b class="nc"><i>587</i>&nbsp;                notifyStreamStateChanged(StreamState.STARTED);</b>
<b class="nc"><i>588</i>&nbsp;            }else if(!wasEnableRequest &amp;&amp; isSuccess){</b>
<b class="nc"><i>589</i>&nbsp;                notifyStreamStateChanged(StreamState.STOPPED);</b>
<b class="nc"><i>590</i>&nbsp;            }else{notifyStreamStateChanged(StreamState.FAILED);}</b>
<b class="fc"><i>591</i>&nbsp;        }else if (MelomindCharacteristics.CHARAC_MEASUREMENT_MAILBOX.equals(characteristic.getUuid())){</b>
<i>592</i>&nbsp;            //TODO see what&#39;s important here
<b class="fc"><i>593</i>&nbsp;        }else if (MelomindCharacteristics.CHARAC_HEADSET_STATUS.equals(characteristic.getUuid())){</b>
<i>594</i>&nbsp;            //TODO see what&#39;s important here
<i>595</i>&nbsp;        }
<b class="fc"><i>596</i>&nbsp;    }</b>
<i>597</i>&nbsp;
<i>598</i>&nbsp;    /**
<i>599</i>&nbsp;     * Close gatt if the current state is connected &amp; ready or upgrading
<i>600</i>&nbsp;     * @param gatt
<i>601</i>&nbsp;     */
<i>602</i>&nbsp;    void onStateDisconnected(@NonNull BluetoothGatt gatt) {
<b class="nc"><i>603</i>&nbsp;        if(gatt != null &amp;&amp; getCurrentState().ordinal() &gt;= BtState.CONNECTED_AND_READY.ordinal())</b>
<b class="nc"><i>604</i>&nbsp;            gatt.close();</b>
<i>605</i>&nbsp;
<b class="nc"><i>606</i>&nbsp;        notifyConnectionStateChanged(BtState.DATA_BT_DISCONNECTED);</b>
<b class="nc"><i>607</i>&nbsp;    }</b>
<i>608</i>&nbsp;
<i>609</i>&nbsp;    void onStateDisconnecting() {
<b class="nc"><i>610</i>&nbsp;        notifyConnectionStateChanged(BtState.DISCONNECTING);</b>
<b class="nc"><i>611</i>&nbsp;    }</b>
<i>612</i>&nbsp;
<i>613</i>&nbsp;    void onStateConnecting() {
<b class="nc"><i>614</i>&nbsp;        if (getCurrentState().equals(BtState.DEVICE_FOUND))</b>
<b class="nc"><i>615</i>&nbsp;            this.updateConnectionState(false);//current state is set to DATA_BT_CONNECTING</b>
<b class="nc"><i>616</i>&nbsp;    }</b>
<i>617</i>&nbsp;
<i>618</i>&nbsp;    void onStateConnected() {
<b class="nc"><i>619</i>&nbsp;        if (getCurrentState().equals(BtState.DATA_BT_CONNECTING) || getCurrentState().equals(BtState.SCAN_STARTED))</b>
<b class="nc"><i>620</i>&nbsp;            updateConnectionState(true);//current state is set to DATA_BT_CONNECTION_SUCCESS and future is completed</b>
<b class="nc"><i>621</i>&nbsp;        else if(getCurrentState().equals(BtState.IDLE) || getCurrentState().equals(BtState.UPGRADING))</b>
<b class="nc"><i>622</i>&nbsp;            this.notifyConnectionStateChanged(BtState.CONNECTED_AND_READY);</b>
<b class="nc"><i>623</i>&nbsp;    }</b>
<i>624</i>&nbsp;
<i>625</i>&nbsp;    /**
<i>626</i>&nbsp;     * Callback triggered by the {@link MbtGattController} callback when the connection state has changed.
<i>627</i>&nbsp;     * @param newState the new {@link BtState state}
<i>628</i>&nbsp;     */
<i>629</i>&nbsp;    @Override
<i>630</i>&nbsp;    public void notifyConnectionStateChanged(@NonNull BtState newState) {
<b class="fc"><i>631</i>&nbsp;        super.notifyConnectionStateChanged(newState);</b>
<i>632</i>&nbsp;
<b class="fc"><i>633</i>&nbsp;        if (newState.equals(BtState.DATA_BT_DISCONNECTED)) {</b>
<b class="fc"><i>634</i>&nbsp;            if (isStreaming())</b>
<b class="fc"><i>635</i>&nbsp;                notifyStreamStateChanged(StreamState.DISCONNECTED);</b>
<b class="fc"><i>636</i>&nbsp;            BroadcastUtils.unregisterReceiver(context, receiver);</b>
<i>637</i>&nbsp;        }
<b class="fc"><i>638</i>&nbsp;    }</b>
<i>639</i>&nbsp;
<i>640</i>&nbsp;    /**
<i>641</i>&nbsp;     * Callback triggered by the {@link MbtGattController} callback
<i>642</i>&nbsp;     * when an event -not related to a mailbox request sent by the SDK- occurs
<i>643</i>&nbsp;     * @param mailboxEvent the event that occurs
<i>644</i>&nbsp;     * @param eventData the data associated to the mailbox event detected
<i>645</i>&nbsp;     */
<i>646</i>&nbsp;    void notifyEventReceived(DeviceCommandEvent mailboxEvent, byte[] eventData) {
<b class="nc"><i>647</i>&nbsp;        mbtBluetoothManager.notifyEventReceived(mailboxEvent, eventData);</b>
<b class="nc"><i>648</i>&nbsp;    }</b>
<i>649</i>&nbsp;
<i>650</i>&nbsp;    void notifyConnectionResponseReceived(DeviceCommandEvent mailboxEvent, byte mailboxResponse) {
<b class="nc"><i>651</i>&nbsp;        if (!mbtGattController.isConnectionMailboxEvent(mailboxEvent)){</b>
<b class="nc"><i>652</i>&nbsp;            LogUtils.e(TAG, &quot;Error : received response is not related to Bluetooth connection&quot;);</b>
<b class="nc"><i>653</i>&nbsp;            return;</b>
<i>654</i>&nbsp;        }
<b class="nc"><i>655</i>&nbsp;        LogUtils.i(TAG, &quot;Received response for &quot; + (mailboxEvent == DeviceCommandEvent.MBX_CONNECT_IN_A2DP ? &quot;connection&quot; : &quot;disconnection&quot;) + &quot; : &quot; + mailboxResponse);</b>
<i>656</i>&nbsp;
<b class="nc"><i>657</i>&nbsp;        if(mailboxEvent == DeviceCommandEvent.MBX_CONNECT_IN_A2DP){</b>
<b class="nc"><i>658</i>&nbsp;            if(BitUtils.areByteEquals(MBX_CONNECT_IN_A2DP.getResponseCodeForKey(CMD_CODE_CONNECT_IN_A2DP_JACK_CONNECTED), mailboxResponse))</b>
<b class="nc"><i>659</i>&nbsp;                mbtBluetoothManager.notifyConnectionStateChanged(BtState.JACK_CABLE_CONNECTED);</b>
<i>660</i>&nbsp;
<b class="nc"><i>661</i>&nbsp;            else if(BitUtils.areByteEquals(MBX_CONNECT_IN_A2DP.getResponseCodeForKey(CMD_CODE_CONNECT_IN_A2DP_SUCCESS), mailboxResponse))</b>
<b class="nc"><i>662</i>&nbsp;                mbtBluetoothManager.notifyConnectionStateChanged(BtState.AUDIO_BT_CONNECTION_SUCCESS);</b>
<i>663</i>&nbsp;        }else
<b class="nc"><i>664</i>&nbsp;            mbtBluetoothManager.notifyConnectionStateChanged(BtState.AUDIO_BT_DISCONNECTED);</b>
<b class="nc"><i>665</i>&nbsp;    }</b>
<i>666</i>&nbsp;
<i>667</i>&nbsp;    void updateConnectionState(boolean isCompleted){
<b class="nc"><i>668</i>&nbsp;        mbtBluetoothManager.updateConnectionState(isCompleted); //do nothing if the current state is CONNECTED_AND_READY</b>
<b class="nc"><i>669</i>&nbsp;    }</b>
<i>670</i>&nbsp;
<i>671</i>&nbsp;    /**
<i>672</i>&nbsp;     * This method handle a single command in order to
<i>673</i>&nbsp;     * reconfigure some headset or bluetooth streaming parameters
<i>674</i>&nbsp;     * or get values stored by the headset
<i>675</i>&nbsp;     * or ask the headset to perform an action.
<i>676</i>&nbsp;     * The command&#39;s parameters are bundled in a {@link command.CommandInterface.MbtCommand instance}
<i>677</i>&nbsp;     * that can provide a nullable response callback.
<i>678</i>&nbsp;     * All method inside are blocking.
<i>679</i>&nbsp;     * @param command is the {@link command.CommandInterface.MbtCommand} object that defines the type of command to send
<i>680</i>&nbsp;     * and the associated command parameters.
<i>681</i>&nbsp;     * One of this parameter is an optional callback that returns the response
<i>682</i>&nbsp;     * sent by the headset to the SDK once the command is received.
<i>683</i>&nbsp;     */
<i>684</i>&nbsp;    public void sendCommand(CommandInterface.MbtCommand command){
<b class="fc"><i>685</i>&nbsp;        Object response = null;</b>
<i>686</i>&nbsp;
<b class="fc"><i>687</i>&nbsp;        if (!isConnectedDeviceReadyForCommand()){ //error returned if no headset is connected</b>
<b class="fc"><i>688</i>&nbsp;            LogUtils.e(TAG, &quot;Command not sent : &quot;+command);</b>
<b class="fc"><i>689</i>&nbsp;            command.onError(BluetoothError.ERROR_NOT_CONNECTED, null);</b>
<i>690</i>&nbsp;        } else { //any command is not sent if no device is connected
<b class="fc"><i>691</i>&nbsp;            if (command.isValid()){//any invalid command is not sent : validity criteria are defined in each Bluetooth implemented class , the onError callback is triggered in the constructor of the command object</b>
<b class="fc"><i>692</i>&nbsp;                LogUtils.d(TAG, &quot;Valid command : &quot;+command);</b>
<b class="fc"><i>693</i>&nbsp;                boolean requestSent = sendRequestData(command);</b>
<i>694</i>&nbsp;
<b class="fc"><i>695</i>&nbsp;                if(!requestSent) {</b>
<b class="fc"><i>696</i>&nbsp;                    LogUtils.e(TAG, &quot;Command sending failed&quot;);</b>
<b class="fc"><i>697</i>&nbsp;                    command.onError(BluetoothError.ERROR_REQUEST_OPERATION, null);</b>
<i>698</i>&nbsp;
<i>699</i>&nbsp;                }else {
<b class="fc"><i>700</i>&nbsp;                    command.onRequestSent();</b>
<i>701</i>&nbsp;
<b class="fc"><i>702</i>&nbsp;                    if (command.isResponseExpected()) {</b>
<b class="fc"><i>703</i>&nbsp;                        response = startWaitingOperation(11000);</b>
<b class="fc"><i>704</i>&nbsp;                        command.onResponseReceived(response);</b>
<i>705</i>&nbsp;                    }
<i>706</i>&nbsp;                }
<b class="fc"><i>707</i>&nbsp;            }else</b>
<b class="fc"><i>708</i>&nbsp;                LogUtils.w(TAG, &quot;Command not sent : &quot;+command);</b>
<i>709</i>&nbsp;        }
<i>710</i>&nbsp;
<b class="fc"><i>711</i>&nbsp;        mbtBluetoothManager.notifyResponseReceived(response, command);//return null response to the client if request has not been sent</b>
<b class="fc"><i>712</i>&nbsp;    }</b>
<i>713</i>&nbsp;
<i>714</i>&nbsp;    private boolean sendRequestData(CommandInterface.MbtCommand command){
<b class="fc"><i>715</i>&nbsp;        if(command instanceof BluetoothCommands.Mtu)</b>
<b class="fc"><i>716</i>&nbsp;            return changeMTU(((Integer)command.serialize()));</b>
<i>717</i>&nbsp;
<b class="fc"><i>718</i>&nbsp;        else if(command instanceof DeviceCommand)</b>
<b class="fc"><i>719</i>&nbsp;            return writeCharacteristic((byte[])command.serialize(),</b>
<i>720</i>&nbsp;                    MelomindCharacteristics.SERVICE_MEASUREMENT,
<i>721</i>&nbsp;                    command instanceof OADCommands.TransferPacket ?
<i>722</i>&nbsp;                            MelomindCharacteristics.CHARAC_MEASUREMENT_OAD_PACKETS_TRANSFER :
<i>723</i>&nbsp;                            MelomindCharacteristics.CHARAC_MEASUREMENT_MAILBOX,
<i>724</i>&nbsp;                    !(command instanceof OADCommands.TransferPacket));
<i>725</i>&nbsp;
<b class="fc"><i>726</i>&nbsp;        return false;</b>
<i>727</i>&nbsp;    }
<i>728</i>&nbsp;
<i>729</i>&nbsp;    /**
<i>730</i>&nbsp;     * Initiates a change MTU request in order to have bigger (or smaller) bluetooth notifications.
<i>731</i>&nbsp;     * The default size is also the minimum size : 23
<i>732</i>&nbsp;     * The maximum size is set to 121.
<i>733</i>&nbsp;     * This method is synchronous and blocks the calling thread until operation is complete.
<i>734</i>&nbsp;     *
<i>735</i>&nbsp;     *
<i>736</i>&nbsp;     * See {@link BluetoothGatt#requestMtu(int)} for more info.
<i>737</i>&nbsp;     *
<i>738</i>&nbsp;     * @param newMTU the new MTU value.
<i>739</i>&nbsp;     *
<i>740</i>&nbsp;     * @return false if request dod not start as planned, true otherwise.
<i>741</i>&nbsp;     */
<i>742</i>&nbsp;    boolean changeMTU(final int newMTU) {
<b class="fc"><i>743</i>&nbsp;        LogUtils.i(TAG, &quot;change mtu &quot; + newMTU);</b>
<i>744</i>&nbsp;
<b class="fc"><i>745</i>&nbsp;        if(this.gatt == null)</b>
<b class="fc"><i>746</i>&nbsp;            return false;</b>
<i>747</i>&nbsp;
<b class="fc"><i>748</i>&nbsp;        return this.gatt.requestMtu(newMTU);</b>
<i>749</i>&nbsp;    }
<i>750</i>&nbsp;
<i>751</i>&nbsp;    private boolean writeCharacteristic(@NonNull byte[] buffer, UUID service, UUID characteristic, boolean enableNotification) {
<i>752</i>&nbsp;        //Log.d(TAG, &quot;write characteristic &quot;+characteristic+ &quot; for service &quot;+service);
<b class="fc"><i>753</i>&nbsp;        if (buffer.length == 0)</b>
<b class="nc"><i>754</i>&nbsp;            return false;</b>
<i>755</i>&nbsp;
<b class="fc"><i>756</i>&nbsp;        if(!isNotificationEnabledOnCharacteristic(service, characteristic) &amp;&amp; enableNotification){</b>
<b class="nc"><i>757</i>&nbsp;            enableOrDisableNotificationsOnCharacteristic(true, gatt.getService(service).getCharacteristic(characteristic));</b>
<i>758</i>&nbsp;        }
<i>759</i>&nbsp;
<b class="fc"><i>760</i>&nbsp;        if (!startWriteOperation(service, characteristic, buffer)){</b>
<b class="nc"><i>761</i>&nbsp;            LogUtils.e(TAG, &quot;Failed to send the command the the headset&quot;);</b>
<b class="nc"><i>762</i>&nbsp;            return false;</b>
<i>763</i>&nbsp;        }
<i>764</i>&nbsp;//        else
<i>765</i>&nbsp;//            LogUtils.d(TAG, &quot;Command sent to the headset&quot;);
<b class="fc"><i>766</i>&nbsp;        return true;</b>
<i>767</i>&nbsp;    }
<i>768</i>&nbsp;
<i>769</i>&nbsp;    /**
<i>770</i>&nbsp;     * Once a device is connected in Bluetooth Low Energy / SPP for data streaming, we consider that the Bluetooth connection process is not fully completed.
<i>771</i>&nbsp;     * The services offered by a remote device as well as their characteristics and descriptors are discovered to ensure that Data Streaming can be performed.
<i>772</i>&nbsp;     * It means that the Bluetooth Manager retrieve all the services, which can be seen as categories of data that the headset is transmitting
<i>773</i>&nbsp;     * This is an asynchronous operation.
<i>774</i>&nbsp;     * Once service discovery is completed, the BluetoothGattCallback.onServicesDiscovered callback is triggered.
<i>775</i>&nbsp;     * If the discovery was successful, the remote services can be retrieved using the getServices function
<i>776</i>&nbsp;     */
<i>777</i>&nbsp;    public void discoverServices() {
<b class="nc"><i>778</i>&nbsp;        LogUtils.i(TAG, &quot;start discover services&quot;);</b>
<b class="nc"><i>779</i>&nbsp;        updateConnectionState(false); //current state is set to DISCOVERING_SERVICES</b>
<b class="nc"><i>780</i>&nbsp;        if(!gatt.discoverServices()){</b>
<b class="nc"><i>781</i>&nbsp;            notifyConnectionStateChanged(BtState.DISCOVERING_FAILURE);</b>
<b class="nc"><i>782</i>&nbsp;            LogUtils.i(TAG, &quot; discover services failed&quot;);</b>
<i>783</i>&nbsp;        }
<b class="nc"><i>784</i>&nbsp;    }</b>
<i>785</i>&nbsp;
<i>786</i>&nbsp;    /**
<i>787</i>&nbsp;     * Starts a read operation of the Battery charge level to trigger an automatic bonding.
<i>788</i>&nbsp;     * If the headset is already bonded, it will return the value of the battery level.
<i>789</i>&nbsp;     * If the headset is not already bonded, it will bond and return an authentication failed status code (0x89 GATT_AUTH_FAIL)
<i>790</i>&nbsp;     * in the {@link MbtGattController#onCharacteristicRead(BluetoothGatt, BluetoothGattCharacteristic, int)}onCharacteristicRead callback
<i>791</i>&nbsp;     */
<i>792</i>&nbsp;    public void bond() {
<b class="nc"><i>793</i>&nbsp;        LogUtils.i(TAG, &quot;start bonding&quot;);</b>
<b class="nc"><i>794</i>&nbsp;        if(getCurrentState().equals(BtState.READING_SUCCESS))</b>
<b class="nc"><i>795</i>&nbsp;            updateConnectionState(false); //current state is set to BONDING</b>
<b class="nc"><i>796</i>&nbsp;        mbtBluetoothManager.startReadOperation(DeviceInfo.BATTERY); //trigger bonding indirectly</b>
<b class="nc"><i>797</i>&nbsp;    }</b>
<i>798</i>&nbsp;
<i>799</i>&nbsp;    public void notifyDeviceInfoReceived(@NonNull DeviceInfo deviceInfo, @NonNull String deviceValue){ // This method will be called when a DeviceInfoReceived is posted (fw or hw or serial number) by MbtBluetoothLE or MbtBluetoothSPP
<b class="nc"><i>800</i>&nbsp;        super.notifyDeviceInfoReceived(deviceInfo,deviceValue);</b>
<b class="nc"><i>801</i>&nbsp;        if(getCurrentState().isReadingDeviceInfoState())</b>
<b class="nc"><i>802</i>&nbsp;            updateConnectionState(true); //current state is set to READING_FIRMWARE_VERSION_SUCCESS or READING_HARDWARE_VERSION_SUCCESS or READING_SERIAL_NUMBER_SUCCESS or READING_SUCCESS if reading device info and future is completed</b>
<b class="nc"><i>803</i>&nbsp;    }</b>
<i>804</i>&nbsp;
<i>805</i>&nbsp;    protected void notifyBatteryReceived(int value) {
<b class="nc"><i>806</i>&nbsp;        if (getCurrentState().equals(BtState.BONDING))</b>
<b class="nc"><i>807</i>&nbsp;            updateConnectionState(true); //current state is set to BONDED</b>
<b class="nc"><i>808</i>&nbsp;        if(value != -1)</b>
<b class="nc"><i>809</i>&nbsp;            super.notifyBatteryReceived(value);</b>
<b class="nc"><i>810</i>&nbsp;    }</b>
<i>811</i>&nbsp;
<i>812</i>&nbsp;    /**
<i>813</i>&nbsp;     * This method uses reflexion to get the refresh hidden method from BluetoothGatt class. Is is used
<i>814</i>&nbsp;     * to clean up the cache that Android system uses when connecting to a known BluetoothGatt peripheral.
<i>815</i>&nbsp;     * It is recommanded to use it right after updating the firmware, especially when the bluetooth
<i>816</i>&nbsp;     * characteristics have been updated.
<i>817</i>&nbsp;     * @return true if method invocation worked, false otherwise
<i>818</i>&nbsp;     */
<i>819</i>&nbsp;    public boolean clearMobileDeviceCache() {
<b class="nc"><i>820</i>&nbsp;        LogUtils.d(TAG, &quot;Clear the cache&quot;);</b>
<i>821</i>&nbsp;        try {
<b class="nc"><i>822</i>&nbsp;            Method localMethod = gatt.getClass().getMethod(REFRESH_METHOD);</b>
<b class="nc"><i>823</i>&nbsp;            if (localMethod != null)</b>
<b class="nc"><i>824</i>&nbsp;                return (boolean) (Boolean) localMethod.invoke(gatt);</b>
<b class="nc"><i>825</i>&nbsp;        } catch (Exception localException) {</b>
<b class="nc"><i>826</i>&nbsp;            Log.e(TAG, &quot;An exception occurred while refreshing device&quot;);</b>
<b class="nc"><i>827</i>&nbsp;        }</b>
<b class="nc"><i>828</i>&nbsp;        return false;</b>
<i>829</i>&nbsp;    }
<i>830</i>&nbsp;
<i>831</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2020-01-08 18:01</div>
</div>
</body>
</html>
